AST dump for Allocators after pass scopeResolve.
Module use list: ChapelStandard CTypes Reflection ChapelLocks ChplConfig 

{
  function alignup[307150](arg ptr[307155] :
  (307153 call c_ptr[46891](?) void[4]), param arg alignment[307158]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    unknown mask[307181] "param"(307182 call - alignment[307158] 1)
    (307187 'end of statement')
    const iptr[307189] "const"(307190 call : ptr[307155] c_intptr[596])
    (307195 'end of statement')
    const alignedPtr[307197] "const"(307198 call &(307200 call + iptr[307189] mask[307181])(307204 call ~ mask[307181]))
    (307208 'end of statement')
    (307209 return(307210 call : alignedPtr[307197](307214 call c_ptr[46891](?) void[4])))
  }
  where {
    (307163 call &&(307165 call > alignment[307158] 0)(307169 call ==(307171 call & alignment[307158](307174 call - alignment[307158] 1)) 0))
  }
  { scopeless type
    (307161 call c_ptr[46891](?) void[4])
  }
  type Self[307257]
  {
    function Self[307257].allocate[307222](arg _mt[307232]:_MT[201], ref arg this[307225]:Self[307257] :
    Self[307257], arg n[307229] :
    int(64)[10]) : _unknown[42] "method" "no fn body"
    {
    }
    { scopeless type
      (307235 call c_ptr[46891](?) void[4])
    }
    function Self[307257].deallocate[307240](arg _mt[307252]:_MT[201], ref arg this[307243]:Self[307257] :
    Self[307257], arg p[307249] :
    (307247 call c_ptr[46891](?) void[4])) : _unknown[42] "method" "no fn body"
    {
    }
  }
  function newTypeCheckHelper[307262](arg T[307264]:_any[141](?)) param : _unknown[42] "private" "no return value for void"
  {
    if(307285 call _cond_test(307280 call !(307283 call isClassType T[307264])))
    {
      (307268 call compilerError(307269 call +(307271 call : T[307264] string[244]) " is not a class") 2)
    }
    if(307308 call _cond_test(307303 call !(307306 call isUnmanagedClassType T[307264])))
    {
      (307291 call compilerError(307292 call +(307294 call : T[307264] string[244]) " is not unmanaged") 2)
    }
  }
  function checkInterfaceHelper[307315](arg alloc[307317]:_any[141](?)) param : _unknown[42] "private" "no return value for void"
  {
    if(307340 call _cond_test(307334 call ==(307336 'implements interface' alloc[307317] allocator[307259]) 2))
    {
      (307322 call compilerError(307323 call +(307325 call :(307328 'typeof' alloc[307317]) string[244]) " does not implement 'allocator'") 2)
    }
  }
  function newWithAllocator[307368](ref arg alloc[307371] :
  record[51](?), arg T[307374]:_any[141](?)) : _unknown[42] "inline"
  {
    (307379 call checkInterfaceHelper alloc[307371])
    (307382 call newTypeCheckHelper T[307374])
    (307384 return(307385 'new with allocator' alloc[307371] T[307374]))
  }
  { scopeless type
    T[307374]
  }
  function newWithAllocator[307391](const  ref arg alloc[307394] :
  class[195](?), arg T[307397]:_any[141](?)) : _unknown[42] "inline"
  {
    (307402 call checkInterfaceHelper alloc[307394])
    (307405 call newTypeCheckHelper T[307397])
    (307407 return(307408 'new with allocator' alloc[307394] T[307397]))
  }
  { scopeless type
    T[307397]
  }
  function newWithAllocator[307414](ref arg alloc[307417] :
  record[51](?), arg T[307420]:_any[141](?), arg args[307423]:_any[141](?) ...) : _unknown[42] "inline"
  {
    (307429 call checkInterfaceHelper alloc[307417])
    (307432 call newTypeCheckHelper T[307420])
    (307434 return(307435 'new with allocator' alloc[307417] T[307420](307439 'expand_tuple' args[307423])))
  }
  { scopeless type
    T[307420]
  }
  function newWithAllocator[307443](const  ref arg alloc[307446] :
  class[195](?), arg T[307449]:_any[141](?), arg args[307452]:_any[141](?) ...) : _unknown[42] "inline"
  {
    (307458 call checkInterfaceHelper alloc[307446])
    (307461 call newTypeCheckHelper T[307449])
    (307463 return(307464 'new with allocator' alloc[307446] T[307449](307468 'expand_tuple' args[307452])))
  }
  { scopeless type
    T[307449]
  }
  function deleteWithAllocator[307490](ref arg alloc[307493] :
  record[51](?), arg objects[307498]:_any[141](?) ...) : _unknown[42] "inline" "no return value for void"
  {
    (307503 call checkInterfaceHelper alloc[307493])
    {
      unknown i[307505] "index var" 0
      unknown tmp[307555] "maybe param" "temp"
      (307572 'move' tmp[307555](307570 call chpl_compute_low_param_loop_bound 0(307565 call chpl_high_bound_count_for_param_loop 0(307562 call chpl_compute_count_param_loop k[307496]))))
      unknown tmp[307556] "maybe param" "temp"
      (307584 'move' tmp[307556](307582 call chpl_compute_high_param_loop_bound 0(307577 call chpl_high_bound_count_for_param_loop 0(307580 call chpl_compute_count_param_loop k[307496]))))
      unknown tmp[307557] "maybe param" "temp"
      (307587 'move' tmp[307557] 1)
      ParamForLoop[307589]
      { i[307505] tmp[307555] tmp[307556] tmp[307557]
        {
          (307515 call newTypeCheckHelper(307519 'typeof'(307517 call objects[307498] i[307505])))
          if(307551 call _cond_test(307550 call compiledForSingleLocale))
          {
            (307522 call chpl__deleteWithAllocator alloc[307493](307525 call objects[307498] i[307505]))
          }
          {
            {
              const tmp[307541] "const" "temp"
              (307542 'move' tmp[307541](307539 'deref'(307538 '_wide_get_locale'(307529 call objects[307498] i[307505]))))
              (307532 call chpl__deleteWithAllocator alloc[307493](307535 call objects[307498] i[307505]))
              (307545 'elided on block' 0 tmp[307541])
            }
          }
        }
      }
      label _unused_continueLabel[307559]
      label _breakLabel[307558]
    }
  }
  function deleteWithAllocator[307600](const  ref arg alloc[307603] :
  class[195](?), arg objects[307608]:_any[141](?) ...) : _unknown[42] "inline" "no return value for void"
  {
    (307613 call checkInterfaceHelper alloc[307603])
    {
      unknown i[307615] "index var" 0
      unknown tmp[307665] "maybe param" "temp"
      (307682 'move' tmp[307665](307680 call chpl_compute_low_param_loop_bound 0(307675 call chpl_high_bound_count_for_param_loop 0(307672 call chpl_compute_count_param_loop k[307606]))))
      unknown tmp[307666] "maybe param" "temp"
      (307694 'move' tmp[307666](307692 call chpl_compute_high_param_loop_bound 0(307687 call chpl_high_bound_count_for_param_loop 0(307690 call chpl_compute_count_param_loop k[307606]))))
      unknown tmp[307667] "maybe param" "temp"
      (307697 'move' tmp[307667] 1)
      ParamForLoop[307699]
      { i[307615] tmp[307665] tmp[307666] tmp[307667]
        {
          (307625 call newTypeCheckHelper(307629 'typeof'(307627 call objects[307608] i[307615])))
          if(307661 call _cond_test(307660 call compiledForSingleLocale))
          {
            (307632 call chpl__deleteWithAllocator alloc[307603](307635 call objects[307608] i[307615]))
          }
          {
            {
              const tmp[307651] "const" "temp"
              (307652 'move' tmp[307651](307649 'deref'(307648 '_wide_get_locale'(307639 call objects[307608] i[307615]))))
              (307642 call chpl__deleteWithAllocator alloc[307603](307645 call objects[307608] i[307615]))
              (307655 'elided on block' 0 tmp[307651])
            }
          }
        }
      }
      label _unused_continueLabel[307669]
      label _breakLabel[307668]
    }
  }
  function chpl__deleteWithAllocator[307710](const  ref arg alloc[307713] :
  class[195](?), const arg obj[307716]:_any[141](?)) : _unknown[42] "inline" "no return value for void"
  {
    unknown p[307720](307722 call c_ptrTo obj[307716])
    (307725 'end of statement')
    if(307738 call _cond_test(307734 call != obj[307716] nil[32]))
    {
      (307732 call(307729 call .(307726 call postfix! obj[307716]) c"deinit"))
    }
    (307749 call(307746 call . alloc[307713] c"deallocate") p[307720])
  }
  function chpl__deleteWithAllocator[307753](ref arg alloc[307756] :
  record[51](?), const arg obj[307759]:_any[141](?)) : _unknown[42] "inline" "no return value for void"
  {
    unknown p[307763](307765 call c_ptrTo obj[307759])
    (307768 'end of statement')
    if(307781 call _cond_test(307777 call != obj[307759] nil[32]))
    {
      (307775 call(307772 call .(307769 call postfix! obj[307759]) c"deinit"))
    }
    (307790 call(307787 call . alloc[307756] c"deallocate") p[307763])
  }
  function _LockWrapper[307838](?).lock[307809](arg _mt[307813]:_MT[201], arg this[307811]:_LockWrapper[307838](?)) : _unknown[42] "inline" "method" "primary method" "no return value for void"
  {
    (307820 call(307817 call .(410375 call . this[307811] c"lockVar") c"lock"))
  }
  function _LockWrapper[307838](?).unlock[307823](arg _mt[307827]:_MT[201], arg this[307825]:_LockWrapper[307838](?)) : _unknown[42] "inline" "method" "primary method" "no return value for void"
  {
    (307834 call(307831 call .(410380 call . this[307825] c"lockVar") c"unlock"))
  }
  type _LockWrapper[307838](?) val super[397693]:RootClass[236] "super class" unknown lockType[307796] "type variable" chpl_LocalSpinlock[85418] unknown lockVar[307803](307804 'new'(307806 call lockType[307796]))
  type _LockWrapper[459370](?)
  function mallocWrapper[307898].allocate[307842](arg _mt[307850]:_MT[201], arg this[307844]:mallocWrapper[307898], arg n[307847] :
  int(64)[10]) : _unknown[42] "method" "primary method"
  {
    (307856 return(307863 call allocate module=[222] CTypes[51217](307865 call int(64)[10] 8)(307871 call(307868 call . n[307847] c"safeCast") c_size_t[614])))
    (410384 'referenced modules list' CTypes[51217])
  }
  { scopeless type
    (307853 call c_ptr[46891](?) void[4])
  }
  function mallocWrapper[307898].deallocate[307876](arg _mt[307886]:_MT[201], arg this[307878]:mallocWrapper[307898], arg p[307883] :
  (307881 call c_ptr[46891](?) void[4])) : _unknown[42] "method" "primary method" "no return value for void"
  {
    (307893 call deallocate module=[222] CTypes[51217] p[307883])
    (410391 'referenced modules list' CTypes[51217])
  }
  type mallocWrapper[307898] val super[397704]:RootClass[236] "super class"
  type mallocWrapper[397696](?)
  function bumpPtrMemPool[308287](?).init[307951](arg _mt[307973]:_MT[201], arg this[307953]:bumpPtrMemPool[308287](?), arg size[307958] :
  (307956 call int(64)[10] 64), param arg parSafe[307963] :
  bool[19] =
  0, param arg alignment[307969] :
  int(64)[10] =
  16) : _unknown[42] "method" "primary method" "no return value for void"
  {
    (307976 call =(307979 call . this[307953] c"parSafe") parSafe[307963])
    (307983 call =(307986 call . this[307953] c"alignment") alignment[307969])
    if(308003 call _cond_test(307996 call <(307999 call . this[307953] c"alignment") 0))
    {
      (307991 call compilerError "alignment must be non-negative")
    }
    if(308030 call _cond_test(308014 call !=(308016 call &(308019 call . this[307953] c"alignment")(308022 call -(308025 call . this[307953] c"alignment") 1)) 0))
    {
      (308009 call compilerError "alignment must be a power of 2")
    }
    (308035 call =(308038 call . this[307953] c"size") size[307958])
    if(308061 call _cond_test 1)
    {
      if(308056 call _cond_test(308049 call <=(308052 call . this[307953] c"size") 0))
      {
        (308045 call halt "size must be positive")
      }
    }
    (308065 call =(459383 call . this[307953] c"basePtr")(308072 call allocate module=[222] CTypes[51217](308074 call int(64)[10] 8)(308083 call(308080 call .(308077 call . this[307953] c"size") c"safeCast") c_size_t[614])))
    (308085 call =(459389 call . this[307953] c"ptr")(459394 call . this[307953] c"basePtr"))
    (308093 call(308090 call . this[307953] c"chpl__initThisType"))
    (410404 'referenced modules list' CTypes[51217])
  }
  function bumpPtrMemPool[308287](?).deinit[308096](arg _mt[308100]:_MT[201], arg this[308098]:bumpPtrMemPool[308287](?)) : _unknown[42] "destructor" "method" "primary method" "no return value for void"
  {
    if(308111 call _cond_test(459404 call . this[308098] c"basePtr"))
    {
      (308107 call deallocate module=[222] CTypes[51217](459399 call . this[308098] c"basePtr"))
      (410412 'referenced modules list' CTypes[51217])
    }
  }
  function bumpPtrMemPool[308287](?)._lock[308118](arg _mt[308122]:_MT[201], arg this[308120]:bumpPtrMemPool[308287](?)) : _unknown[42] "method" "primary method" "no return value for void"
  {
    if(308132 call _cond_test(459409 call . this[308120] c"parSafe"))
    {
      (308129 call(308126 call .(410421 call . this[308120] c"lock_") c"lock"))
    }
  }
  function bumpPtrMemPool[308287](?)._unlock[308139](arg _mt[308143]:_MT[201], arg this[308141]:bumpPtrMemPool[308287](?)) : _unknown[42] "inline" "method" "primary method" "no return value for void"
  {
    if(308153 call _cond_test(459414 call . this[308141] c"parSafe"))
    {
      (308150 call(308147 call .(410426 call . this[308141] c"lock_") c"unlock"))
    }
  }
  function bumpPtrMemPool[308287](?).allocate[308160](arg _mt[308168]:_MT[201], arg this[308162]:bumpPtrMemPool[308287](?), arg n[308165] :
  int(64)[10]) : _unknown[42] "method" "primary method"
  {
    (308175 call(459419 call . this[308162] c"_lock"))
    if(308192 call _cond_test 1)
    {
      if(308187 call _cond_test(308183 call <= n[308165] 0))
      {
        (308179 call halt "n must be positive")
      }
    }
    if(308218 call _cond_test(308214 call >(459437 call . this[308162] c"alignment") 0))
    {
      (308196 call =(459426 call . this[308162] c"ptr")(308199 call :(308202 call alignup(459431 call . this[308162] c"ptr")(308205 call . this[308162] c"alignment"))(308209 call c_ptr[46891](?)(308211 call int(64)[10] 8))))
    }
    if(308251 call _cond_test 1)
    {
      if(308246 call _cond_test(308230 call >(308232 call :(308234 call +(459442 call . this[308162] c"ptr") n[308165]) c_intptr[596])(308239 call :(308241 call +(459449 call . this[308162] c"basePtr")(459454 call . this[308162] c"size")) c_intptr[596])))
      {
        (308226 call halt "out of memory")
      }
    }
    unknown p[308256](459461 call . this[308162] c"ptr")
    (308259 'end of statement')
    (308260 call +=(459466 call . this[308162] c"ptr") n[308165])
    (308265 call(459473 call . this[308162] c"_unlock"))
    (308266 return p[308256])
  }
  { scopeless type
    (308171 call c_ptr[46891](?) void[4])
  }
  function bumpPtrMemPool[308287](?).deallocate[308271](arg _mt[308281]:_MT[201], arg this[308273]:bumpPtrMemPool[308287](?), arg p[308278] :
  (308276 call c_ptr[46891](?) void[4])) : _unknown[42] "method" "primary method" "no return value for void"
  {
  }
  type bumpPtrMemPool[308287](?) val super[397715]:RootClass[236] "super class" unknown parSafe[307903] "param" 0 bool[19] unknown alignment[307909] "param" 16 int(64)[10] unknown size[307915](307917 call int(64)[10] 64) unknown basePtr[307922](307924 call c_ptr[46891](?)(307926 call int(64)[10] 8)) unknown ptr[307931](307933 call c_ptr[46891](?)(307935 call int(64)[10] 8)) unknown lock_[307940](307946 IfExpr  parSafe[307903] then
  { scopeless
    (307942 'new'(307944 call _LockWrapper[459370](?)))
  } else
  { scopeless
    none[48]
  } )
  type bumpPtrMemPool[397707](?) allocator[307259] mallocWrapper[397696](?)
  {
  } allocator[307259] bumpPtrMemPool[397707](?)
  {
  }
  (397034 'used modules list'(387060 'use' ChapelStandard[315387])(307139 'use' CTypes[51217])(307142 'use' Reflection[1804])(307146 'import' ChapelLocks[85420])(307148 'use' ChplConfig[29952]))
  (410370 'referenced modules list' ChapelLocks[85420])
}