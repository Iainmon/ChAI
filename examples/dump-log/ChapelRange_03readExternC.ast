AST dump for ChapelRange after pass readExternC.
Module use list: 

{
  { scopeless
    (107071 'use' ChapelBase)
    (107073 'use' HaltWrappers)
  }
  { scopeless
    (107077 'use' AutoMath)
    (107079 'use' DSIUtil)
    (107080 'use' Reflection)
  }
  (107084 'use' ChapelDebugPrint 'only' chpl_debug_writeln)
  { scopeless
    unknown debugChapelRange[107087] "config" "param" 0
    (107090 'end of statement')
  }
  { scopeless
    unknown useOptimizedRangeIterators[107092] "config" "param" 1
    (107095 'end of statement')
  }
  { scopeless
    unknown newSliceRule[107097] "config" "deprecated" "param" 1
    (107100 'end of statement')
  }
  { scopeless
    unknown newRangeLiteralType[107102] "config" "param" 0
    (107105 'end of statement')
  }
  { scopeless
    unknown unalignedMark[107107] "param" "private"(107108 call - 1)
    (107112 'end of statement')
  }
  type boundKind[107122] def both[107114]:boundKind[107122] def low[107116]:boundKind[107122] def high[107118]:boundKind[107122] def neither[107120]:boundKind[107122]
  {
  }
  type strideKind[107137] def one[107127]:strideKind[107137] def negOne[107129]:strideKind[107137] def positive[107131]:strideKind[107137] def negative[107133]:strideKind[107137] def any[107135]:strideKind[107137]
  {
  }
  type range[240](?) unknown idxType[107143] "type variable" int[10] unknown bounds[107147] "param"(107150 call . boundKind c"both") boundKind unknown strides[107156] "param"(107159 call . strideKind c"one") strideKind unknown _low[107165](107167 call chpl__idxTypeToIntIdxType idxType) unknown _high[107172](107174 call chpl__idxTypeToIntIdxType idxType) unknown _stride[107179](107191 IfExpr (107186 call(107183 call . strides c"isPosNegOne")) then
  { scopeless
    nothing
  } else
  { scopeless
    (107189 call chpl__rangeStrideType idxType)
  } ) unknown _alignment[107197](107207 IfExpr (107202 call(107199 call . strides c"isPosNegOne")) then
  { scopeless
    nothing
  } else
  { scopeless
    (107205 call chpl__rangeStrideType idxType)
  } )
  function _unknown[42].strType[107214](arg _mt[107220]:_MT[201], arg this[107217] :
  range) type : _unknown[42] "method" "no parens" "@unstable"
  {
    (107223 return(107225 call chpl__rangeStrideType idxType))
  }
  function _unknown[42].chpl__promotionType[107229](arg _mt[107235]:_MT[201], arg this[107232] :
  range) type : _unknown[42] "method"
  {
    (107238 return idxType)
  }
  function _unknown[42].chpl_integralIdxType[107242](arg _mt[107248]:_MT[201], arg this[107245] :
  range) type : _unknown[42] "method" "no parens"
  {
    (107251 return(107253 call chpl__idxTypeToIntIdxType idxType))
  }
  function isFiniteIdxType[107257](arg t[107259]:_any[141](?)) param : _unknown[42] "private"
  {
    (107262 return(107263 call ||(107266 call isBoolType t)(107269 call isEnumType t)))
  }
  function finiteIdxTypeLow[107273](arg t[107275]:_any[141](?)) param : _unknown[42] "private"
  {
    if(107284 call _cond_test(107282 call isFiniteIdxType t))
    {
      { scopeless
        (107278 return 0)
      }
    }
    (107290 call compilerError(107291 call +(107293 call + "finiteIdxTypeLow() undefined for type '"(107298 call : t string[244])) "'"))
  }
  function finiteIdxTypeHigh[107305](arg t[107307]:_any[141](?)) param : _unknown[42] "private"
  {
    if(107316 call _cond_test(107314 call isBoolType t))
    {
      { scopeless
        (107310 return 1)
      }
    }
    if(107333 call _cond_test(107331 call isEnumType t))
    {
      { scopeless
        (107321 return(107322 call -(107325 call . t c"size") 1))
      }
    }
    (107339 call compilerError(107340 call +(107342 call + "finiteIdxTypeHigh() undefined for type '"(107347 call : t string[244])) "'"))
  }
  function lowBoundForIter[107354](arg r[107356]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    if(107384 call _cond_test(107383 call(107380 call . r c"hasLowBound")))
    {
      { scopeless
        (107359 return(107361 call . r c"lowBound"))
      }
    }
    {
      { scopeless
        (107365 return(107367 call chpl__intToIdx(107369 call . r c"idxType")(107373 call finiteIdxTypeLow(107375 call . r c"idxType"))))
      }
    }
  }
  function highBoundForIter[107392](arg r[107394]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    if(107422 call _cond_test(107421 call(107418 call . r c"hasHighBound")))
    {
      { scopeless
        (107397 return(107399 call . r c"highBound"))
      }
    }
    {
      { scopeless
        (107403 return(107405 call chpl__intToIdx(107407 call . r c"idxType")(107411 call finiteIdxTypeHigh(107413 call . r c"idxType"))))
      }
    }
  }
  function hasLowBoundForIter[107430](arg r[107432]:_any[141](?)) param : _unknown[42] "private"
  {
    (107435 return(107436 call ||(107442 call(107439 call . r c"hasLowBound"))(107444 call isFiniteIdxType(107446 call . r c"idxType"))))
  }
  function hasHighBoundForIter[107451](arg r[107453]:_any[141](?)) param : _unknown[42] "private"
  {
    (107456 return(107457 call ||(107463 call(107460 call . r c"hasHighBound"))(107465 call isFiniteIdxType(107467 call . r c"idxType"))))
  }
  function _unknown[42].init[107472](arg _mt[107488]:_MT[201], arg this[107475] :
  range, arg idxType[107478]:_any[141](?), arg low[107481] :
  idxType, arg high[107485] :
  idxType) : _unknown[42] "method"
  {
    (107491 call =(107494 call . this c"idxType") idxType)
    (107498 call =(107501 call . this c"bounds")(107505 call . boundKind c"both"))
    (107508 call =(107513 call . this c"_low")(107517 call chpl__idxToInt low))
    (107519 call =(107524 call . this c"_high")(107528 call chpl__idxToInt high))
  }
  function _unknown[42].init[107532](arg _mt[107543]:_MT[201], arg this[107535] :
  range, arg low[107540] :
  unknown t[107538]) : _unknown[42] "method"
  {
    (107546 call =(107549 call . this c"idxType") t)
    (107553 call =(107556 call . this c"bounds")(107560 call . boundKind c"low"))
    (107563 call =(107566 call . this c"_low")(107570 call chpl__idxToInt low))
    (107576 call(107573 call . this c"chpl__initThisType"))
    if(107590 call _cond_test(107588 call isFiniteIdxType idxType))
    {
      (107578 call =(107581 call . this c"_high")(107585 call finiteIdxTypeHigh idxType))
    }
  }
  function _unknown[42].init[107596](arg _mt[107607]:_MT[201], arg this[107599] :
  range, arg high[107604] :
  unknown t[107602]) : _unknown[42] "method"
  {
    (107610 call =(107613 call . this c"idxType") t)
    (107617 call =(107620 call . this c"bounds")(107624 call . boundKind c"high"))
    (107627 call =(107630 call . this c"_high")(107634 call chpl__idxToInt high))
    (107640 call(107637 call . this c"chpl__initThisType"))
    if(107654 call _cond_test(107652 call isFiniteIdxType idxType))
    {
      (107642 call =(107645 call . this c"_low")(107649 call finiteIdxTypeLow idxType))
    }
  }
  function _unknown[42].init[107660](arg _mt[107666]:_MT[201], arg this[107663] :
  range) : _unknown[42] "method"
  {
    (107669 call =(107672 call . this c"idxType") int[10])
    (107676 call =(107679 call . this c"bounds")(107683 call . boundKind c"neither"))
    (107690 call(107687 call . this c"chpl__initThisType"))
    if(107713 call _cond_test(107711 call isFiniteIdxType idxType))
    {
      (107692 call =(107695 call . this c"_low")(107699 call finiteIdxTypeLow idxType))
      (107701 call =(107704 call . this c"_high")(107708 call finiteIdxTypeHigh idxType))
    }
  }
  function _unknown[42].init[107719](arg _mt[107735]:_MT[201], arg this[107722] :
  range, arg idxType[107725]:_any[141](?), param arg bounds[107728] :
  boundKind, param arg strides[107732] :
  strideKind) : _unknown[42] "method"
  {
    if(107763 call _cond_test(107744 call && chpl_warnUnstable(107747 call ||(107749 call == bounds(107753 call . boundKind c"low"))(107756 call == bounds(107760 call . boundKind c"high")))))
    {
      { scopeless
        (107739 call warning "Default initialization of a range with 'boundKind.low' or 'boundKind.high' is unstable")
      }
    }
    (107772 call(107769 call . this c"init") idxType bounds strides(_low =(107777 call chpl__defaultLowBound idxType bounds))(_high =(107782 call chpl__defaultHighBound idxType bounds))(_stride =(107786 call :(107794 call(107791 call . strides c"defaultStride"))(107796 call chpl__rangeStrideType idxType)))(alignmentValue =(107799 call : 0(107803 call chpl__rangeStrideType idxType))))
  }
  function _unknown[42].init[107808](arg _mt[107828]:_MT[201], arg this[107811] :
  range, arg idxType[107814]:_any[141](?), param arg bounds[107817] :
  boundKind, param arg strides[107821] :
  strideKind, param arg internal[107825] :
  bool) : _unknown[42] "method"
  {
    (107835 call(107832 call . this c"init") idxType bounds strides(_low =(107840 call chpl__defaultLowBound idxType bounds))(_high =(107845 call chpl__defaultHighBound idxType bounds))(_stride =(107849 call :(107855 call(107852 call . strides c"defaultStride"))(107857 call chpl__rangeStrideType idxType)))(alignmentValue =(107860 call : 0(107864 call chpl__rangeStrideType idxType))))
  }
  function _unknown[42].init[107869](arg _mt[107899]:_MT[201], arg this[107872] :
  range, arg idxType[107875]:_any[141](?), param arg bounds[107878] :
  boundKind, param arg strides[107882] :
  strideKind, arg _low[107885]:_any[141](?), arg _high[107887]:_any[141](?), arg _stride[107889]:_any[141](?), arg _alignment[107891]:_any[141](?), arg _aligned[107893]:_any[141](?), param arg normalizeAlignment[107896] =
  1) : _unknown[42] "method"
  {
    unknown almtType[107903] "type variable"(107905 call chpl__rangeStrideType idxType)
    { scopeless
      const alignmentValue[107909] "const"(107938 IfExpr (107914 call(107911 call . strides c"isPosNegOne")) then
      { scopeless
        none
      } else
      { scopeless(107935 IfExpr (107916 call ! _aligned) then
        { scopeless
          (107919 call : unalignedMark almtType)
        } else
        { scopeless(107932 IfExpr  normalizeAlignment then
          { scopeless
            (107924 call :(107927 call chpl__mod _alignment _stride) almtType)
          } else
          { scopeless
            _alignment
          } )
        } )
      } )
      (107942 'end of statement')
    }
    (107947 call(107944 call . this c"init") idxType bounds strides _low _high _stride alignmentValue)
  }
  function _unknown[42].init[107957](arg _mt[107981]:_MT[201], arg this[107960] :
  range, arg idxType[107963]:_any[141](?), param arg bounds[107966] :
  boundKind, param arg strides[107970] :
  strideKind, arg _low[107973]:_any[141](?), arg _high[107975]:_any[141](?), arg _stride[107977]:_any[141](?), arg alignmentValue[107979]:_any[141](?)) : _unknown[42] "method"
  {
    (107984 call =(107987 call . this c"idxType") idxType)
    (107991 call =(107994 call . this c"bounds") bounds)
    (107998 call =(108001 call . this c"strides") strides)
    (108005 call =(108008 call . this c"_low")(108011 call : _low(108015 call chpl__idxTypeToIntIdxType idxType)))
    (108017 call =(108020 call . this c"_high")(108023 call : _high(108027 call chpl__idxTypeToIntIdxType idxType)))
    if(108063 call _cond_test(108059 call !(108062 call hasParamStrideAltvalAld)))
    {
      (108030 call =(108035 call . this c"_stride") _stride)
      (108039 call =(108044 call . this c"_alignment") alignmentValue)
      if(108054 call _cond_test boundsChecking)
      {
        { scopeless
          (108049 call verifyAppropriateStride strides _stride)
        }
      }
    }
  }
  function _unknown[42].init=[108069](arg _mt[108086]:_MT[201], arg this[108072] :
  range, arg other[108083] :
  (108076 call range unknown i[108077] unknown b[108079] unknown s[108081])) : _unknown[42] "method"
  {
    unknown idxType[108090] "type variable"(108105 IfExpr (108091 call ==(108095 call .(108094 'typeof' this) c"idxType") ?[227]) then
    { scopeless
      i
    } else
    { scopeless
      (108102 call .(108101 'typeof' this) c"idxType")
    } )
    { scopeless
      unknown bounds[108110] "param"(108125 IfExpr (108111 call ==(108115 call .(108114 'typeof' this) c"bounds") ?[227]) then
      { scopeless
        b
      } else
      { scopeless
        (108122 call .(108121 'typeof' this) c"bounds")
      } )
      (108129 'end of statement')
    }
    { scopeless
      unknown strides[108131] "param"(108146 IfExpr (108132 call ==(108136 call .(108135 'typeof' this) c"strides") ?[227]) then
      { scopeless
        s
      } else
      { scopeless
        (108143 call .(108142 'typeof' this) c"strides")
      } )
      (108150 'end of statement')
    }
    if(108174 call _cond_test(108168 call !(108171 call assignmentIsLegal idxType i)))
    {
      { scopeless
        (108152 call compilerError "initializing a range with idxType "(108156 call : idxType string[244]) " from a range with idxType "(108163 call : i string[244]))
      }
    }
    if(108200 call _cond_test(108196 call != bounds b))
    {
      { scopeless
        (108180 call compilerError "initializing a range with boundKind."(108184 call : bounds string[244]) " from a range with boundKind."(108191 call : b string[244]))
      }
    }
    if(108228 call _cond_test(108222 call !(108225 call chpl_assignStrideIsSafe strides s)))
    {
      { scopeless
        (108206 call compilerError "initializing a range with strideKind."(108210 call : strides string[244]) " from a range with strideKind."(108217 call : s string[244]))
      }
    }
    { scopeless
      unknown isEnumBool[108234] "param"(108236 call isFiniteIdxType idxType)
      (108239 'end of statement')
    }
    unknown bt[108241] "type variable"(108245 call . other c"chpl_integralIdxType")
    { scopeless
      const low[108250] "const"(108271 IfExpr (108251 call && isEnumBool(108254 call !(108260 call(108257 call . other c"hasLowBound")))) then
      { scopeless
        (108261 call :(108264 call finiteIdxTypeLow idxType) bt)
      } else
      { scopeless
        (108268 call . other c"_low")
      } )
      (108275 'end of statement')
    }
    { scopeless
      const high[108277] "const"(108298 IfExpr (108278 call && isEnumBool(108281 call !(108287 call(108284 call . other c"hasHighBound")))) then
      { scopeless
        (108288 call :(108291 call finiteIdxTypeHigh idxType) bt)
      } else
      { scopeless
        (108295 call . other c"_high")
      } )
      (108302 'end of statement')
    }
    { scopeless
      const str[108304] "const"(108305 call :(108308 call . other c"stride")(108312 call chpl__rangeStrideType idxType))
      (108315 'end of statement')
    }
    { scopeless
      unknown alignment[108317](108318 call :(108332 IfExpr (108326 call(108323 call . other c"hasParamAlignmentField")) then
      { scopeless
        0
      } else
      { scopeless
        (108329 call . other c"_alignment")
      } )(108336 'typeof' str))
      (108338 'end of statement')
    }
    if(108375 call _cond_test(108363 call && isEnumBool(108366 call !(108374 call(108371 call . other c"isAligned")))))
    {
      if(108359 call _cond_test(108356 call isPositiveStride strides str))
      {
        (108341 call = alignment(108345 call finiteIdxTypeLow idxType))
        {
        }
      }
      {
        (108349 call = alignment(108353 call finiteIdxTypeHigh idxType))
      }
    }
    (108383 call(108380 call . this c"init") idxType bounds strides low high str alignment)
  }
  function _unknown[42].displayRepresentation[108393](arg _mt[108405]:_MT[201], arg this[108396] :
  range, arg msg[108401] :
  string[244] =
  "") : _unknown[42] "method"
  {
    function :[108409](arg arg[108412] :
    nothing, arg t[108416] :
    string[244]) param : _unknown[42] "operator"
    {
      (108420 return "none")
    }
    (108425 call chpl_debug_writeln msg "range("(108430 call : _low string[244]) ".."(108437 call : _high string[244]) " by "(108442 call : _stride string[244]) " align "(108449 call : _alignment string[244]) " : "(108456 call : idxType string[244]) ","(108461 call : bounds string[244]) ","(108466 call : strides string[244]) ")")
  }
  { scopeless type
    void[4]
  }
  function computeParamRangeIndexType_Old[108474](param arg low[108476]:_any[141](?), param arg high[108478]:_any[141](?)) type : _unknown[42] "private"
  {
    if(108546 call _cond_test(108523 call &&(108525 call &&(108527 call ==(108530 'typeof' low) int[10])(108532 call <=(108535 call min(108537 'typeof' high)) low))(108539 call <= low(108543 call max(108545 'typeof' high)))))
    {
      (108482 return(108484 'typeof' high))
    }
    {
      { scopeless
        if(108519 call _cond_test(108496 call &&(108498 call &&(108500 call ==(108503 'typeof' high) int[10])(108505 call <=(108508 call min(108510 'typeof' low)) high))(108512 call <= high(108516 call max(108518 'typeof' low)))))
        {
          (108486 return(108488 'typeof' low))
        }
        {
          (108490 return(108495 'typeof'(108491 call + low high)))
        }
      }
    }
  }
  function computeParamRangeIndexType[108553](param arg low[108555]:_any[141](?), param arg high[108557]:_any[141](?)) type : _unknown[42] "private"
  {
    if(108568 call _cond_test newRangeLiteralType)
    {
      (108561 return(108566 'typeof'(108562 call + low high)))
    }
    unknown newRule[108573] "type variable"(108578 'typeof'(108574 call + low high))
    unknown oldRule[108581] "type variable"(108583 call computeParamRangeIndexType_Old low high)
    if(108594 call _cond_test(108590 call == newRule oldRule))
    {
      { scopeless
        (108587 return newRule)
      }
    }
    (108600 call compilerWarning "the idxType of this range literal "(108604 call : low string[244]) ".."(108609 call : high string[244]) " with the low bound of the type "(108616 call :(108619 'typeof' low) string[244]) " and the high bound of the type "(108624 call :(108627 'typeof' high) string[244]) " is currently "(108632 call : oldRule string[244]) ". In a future release it will be switched to "(108639 call : newRule string[244]) ". To switch to this new typing and turn off this warning," " compile with -snewRangeLiteralType.")
    (108649 return oldRule)
  }
  function chpl_isValidRangeIdxType[108653](arg t[108655]:_any[141](?)) param : _unknown[42]
  {
    (108658 return(108659 call ||(108661 call ||(108664 call isIntegralType t)(108667 call isEnumType t))(108670 call isBoolType t)))
  }
  function chpl_build_bounded_range[108674](param arg low[108677] :
  integral, param arg high[108681] :
  integral) : _unknown[42]
  {
    unknown idxType[108686] "type variable"(108688 call computeParamRangeIndexType low high)
    (108692 return(108693 'new'(108695 call range idxType(low = low)(high = high))))
  }
  function chpl_build_bounded_range[108703](arg low[108708] :
  (108706 call int[10] 8), arg high[108714] :
  (108712 call int[10] 8)) : _unknown[42]
  {
    (108718 return(108719 'new'(108721 call range(108723 call int[10] 8)(low = low)(high = high))))
  }
  function chpl_build_bounded_range[108731](arg low[108736] :
  (108734 call int[10] 16), arg high[108742] :
  (108740 call int[10] 16)) : _unknown[42]
  {
    (108746 return(108747 'new'(108749 call range(108751 call int[10] 16)(low = low)(high = high))))
  }
  function chpl_build_bounded_range[108759](arg low[108764] :
  (108762 call int[10] 32), arg high[108770] :
  (108768 call int[10] 32)) : _unknown[42]
  {
    (108774 return(108775 'new'(108777 call range(108779 call int[10] 32)(low = low)(high = high))))
  }
  function chpl_build_bounded_range[108787](arg low[108792] :
  (108790 call int[10] 64), arg high[108798] :
  (108796 call int[10] 64)) : _unknown[42]
  {
    (108802 return(108803 'new'(108805 call range(108807 call int[10] 64)(low = low)(high = high))))
  }
  function chpl_build_bounded_range[108815](arg low[108820] :
  (108818 call uint[86] 8), arg high[108826] :
  (108824 call uint[86] 8)) : _unknown[42]
  {
    (108830 return(108831 'new'(108833 call range(108835 call uint[86] 8)(low = low)(high = high))))
  }
  function chpl_build_bounded_range[108843](arg low[108848] :
  (108846 call uint[86] 16), arg high[108854] :
  (108852 call uint[86] 16)) : _unknown[42]
  {
    (108858 return(108859 'new'(108861 call range(108863 call uint[86] 16)(low = low)(high = high))))
  }
  function chpl_build_bounded_range[108871](arg low[108876] :
  (108874 call uint[86] 32), arg high[108882] :
  (108880 call uint[86] 32)) : _unknown[42]
  {
    (108886 return(108887 'new'(108889 call range(108891 call uint[86] 32)(low = low)(high = high))))
  }
  function chpl_build_bounded_range[108899](arg low[108904] :
  (108902 call uint[86] 64), arg high[108910] :
  (108908 call uint[86] 64)) : _unknown[42]
  {
    (108914 return(108915 'new'(108917 call range(108919 call uint[86] 64)(low = low)(high = high))))
  }
  function chpl_build_bounded_range[108927](arg low[108930] :
  enum, arg high[108934] :
  enum) : _unknown[42]
  {
    if(108950 call _cond_test(108944 call !=(108947 'typeof' low)(108949 'typeof' high)))
    {
      { scopeless
        (108939 call compilerError "ranges of enums must use a single enum type")
      }
    }
    (108955 return(108956 'new'(108958 call range(108960 'typeof' low)(low = low)(high = high))))
  }
  function chpl_build_bounded_range[108967](arg low[108970] :
  bool, arg high[108974] :
  bool) : _unknown[42]
  {
    (108978 return(108979 'new'(108981 call range bool(low = low)(high = high))))
  }
  function chpl_build_bounded_range[108989](arg low[108991]:_any[141](?), arg high[108993]:_any[141](?)) : _unknown[42]
  {
    if(109056 call _cond_test(109050 call ==(109053 'typeof' low)(109055 'typeof' high)))
    {
      { scopeless
        (109009 call compilerError(109010 call +(109012 call + "Ranges defined using bounds of type '"(109017 call :(109020 'typeof' low) string[244])) "' are not currently supported"))
      }
    }
    {
      { scopeless
        (109027 call compilerError(109028 call +(109030 call +(109032 call +(109034 call + "Ranges defined using bounds of type '"(109037 call :(109040 'typeof' low) string[244])) "..")(109043 call :(109046 'typeof' high) string[244])) "' are not currently supported"))
      }
    }
  }
  where {
    (108995 call !(108997 call &&(109000 call chpl_isValidRangeIdxType(109002 'typeof' low))(109004 call chpl_isValidRangeIdxType(109006 'typeof' high))))
  }
  function chpl__nudgeLowBound[109065](arg low[109067]:_any[141](?)) : _unknown[42]
  {
    (109070 return(109072 call chpl__intToIdx(109074 'typeof' low)(109075 call +(109078 call chpl__idxToInt low) 1)))
  }
  function chpl__nudgeLowBound[109083](param arg low[109085]:_any[141](?)) param : _unknown[42]
  {
    (109088 return(109090 call chpl__intToIdx(109092 'typeof' low)(109093 call +(109096 call chpl__idxToInt low) 1)))
  }
  function chpl__nudgeHighBound[109101](arg high[109103]:_any[141](?)) : _unknown[42]
  {
    (109106 return(109108 call chpl__intToIdx(109110 'typeof' high)(109111 call -(109114 call chpl__idxToInt high) 1)))
  }
  function chpl__nudgeHighBound[109119](param arg high[109121]:_any[141](?)) param : _unknown[42]
  {
    (109124 return(109126 call chpl__intToIdx(109128 'typeof' high)(109129 call -(109132 call chpl__idxToInt high) 1)))
  }
  function chpl_build_low_bounded_range[109137](arg low[109140] :
  integral) : _unknown[42]
  {
    (109144 return(109145 'new'(109147 call range(low = low))))
  }
  function chpl_build_low_bounded_range[109152](arg low[109155] :
  enum) : _unknown[42]
  {
    (109159 return(109160 'new'(109162 call range(low = low))))
  }
  function chpl_build_low_bounded_range[109167](arg low[109170] :
  bool) : _unknown[42]
  {
    (109174 return(109175 'new'(109177 call range(low = low))))
  }
  function chpl_build_low_bounded_range[109182](arg low[109184]:_any[141](?)) : _unknown[42]
  {
    (109194 call compilerError(109195 call +(109197 call + "Ranges defined using bounds of type '"(109200 call :(109203 'typeof' low) string[244])) "' are not currently supported"))
  }
  where {
    (109186 call !(109189 call chpl_isValidRangeIdxType(109191 'typeof' low)))
  }
  function chpl_build_high_bounded_range[109209](arg high[109212] :
  integral) : _unknown[42]
  {
    (109216 return(109217 'new'(109219 call range(high = high))))
  }
  function chpl_build_high_bounded_range[109224](arg high[109227] :
  enum) : _unknown[42]
  {
    (109231 return(109232 'new'(109234 call range(high = high))))
  }
  function chpl_build_high_bounded_range[109239](arg high[109242] :
  bool) : _unknown[42]
  {
    (109246 return(109247 'new'(109249 call range(high = high))))
  }
  function chpl_build_high_bounded_range[109254](arg high[109256]:_any[141](?)) : _unknown[42]
  {
    (109266 call compilerError(109267 call +(109269 call + "Ranges defined using bounds of type '"(109272 call :(109275 'typeof' high) string[244])) "' are not currently supported"))
  }
  where {
    (109258 call !(109261 call chpl_isValidRangeIdxType(109263 'typeof' high)))
  }
  function chpl_build_unbounded_range[109281]() : _unknown[42]
  {
    (109284 return(109285 'new'(109287 call range)))
  }
  function _unknown[42].createWithSingleElement[109290](arg _mt[109300]:_MT[201], arg this[109293] :
  range, arg elm[109297] :
  idxType) : _unknown[42] "method"
  {
    (109303 return(109304 call chpl_by(109308 call chpl_build_bounded_range elm elm)(109314 call(109311 call . strides c"defaultStride"))))
  }
  function chpl_compute_low_param_loop_bound[109317](param arg low[109320] :
  integral, param arg high[109324] :
  integral) param : _unknown[42]
  {
    unknown t[109329] "type variable"(109331 call computeParamRangeIndexType low high)
    (109335 return(109336 call : low t))
  }
  function chpl_compute_high_param_loop_bound[109342](param arg low[109345] :
  integral, param arg high[109349] :
  integral) param : _unknown[42]
  {
    unknown t[109354] "type variable"(109356 call computeParamRangeIndexType low high)
    (109360 return(109361 call : high t))
  }
  function chpl_compute_low_param_loop_bound[109367](param arg low[109370] :
  enum, param arg high[109375] :
  (109374 'typeof' low)) param : _unknown[42]
  {
    (109379 return low)
  }
  function chpl_compute_high_param_loop_bound[109383](param arg low[109386] :
  enum, param arg high[109391] :
  (109390 'typeof' low)) param : _unknown[42]
  {
    (109395 return high)
  }
  function chpl_compute_low_param_loop_bound[109399](param arg low[109402] :
  bool, param arg high[109406] :
  bool) param : _unknown[42]
  {
    (109410 return low)
  }
  function chpl_compute_high_param_loop_bound[109414](param arg low[109417] :
  bool, param arg high[109421] :
  bool) param : _unknown[42]
  {
    (109425 return high)
  }
  function chpl_compute_low_param_loop_bound[109429](param arg low[109431]:_any[141](?), param arg high[109433]:_any[141](?)) param : _unknown[42]
  {
    if(109494 call _cond_test(109488 call ==(109491 'typeof' low)(109493 'typeof' high)))
    {
      { scopeless
        (109449 call compilerError(109450 call +(109452 call + "param for-loops defined using bounds of type '"(109457 call :(109460 'typeof' low) string[244])) "' are not currently supported"))
      }
    }
    {
      { scopeless
        (109465 call compilerError(109466 call +(109468 call +(109470 call +(109472 call + "param for-loops defined using bounds of type '"(109475 call :(109478 'typeof' low) string[244])) "..")(109481 call :(109484 'typeof' high) string[244])) "' are not currently supported"))
      }
    }
  }
  where {
    (109435 call !(109437 call &&(109440 call chpl_isValidRangeIdxType(109442 'typeof' low))(109444 call chpl_isValidRangeIdxType(109446 'typeof' high))))
  }
  function chpl_compute_low_param_loop_bound[109503](arg low[109505]:_any[141](?), arg high[109507]:_any[141](?)) : _unknown[42]
  {
    (109511 call compilerError "param for-loops must be defined over a bounded param range")
  }
  function chpl_compute_count_param_loop[109517](param arg count[109520] :
  integral) param : _unknown[42]
  {
    (109524 return count)
  }
  function chpl_compute_count_param_loop[109528](arg count[109530]:_any[141](?)) : _unknown[42]
  {
    (109534 call compilerError "in a param for-loop, the count operator requires a param integral value")
  }
  function chpl_low_bound_count_for_param_loop[109540](param arg high[109543] :
  integral, param arg count[109547] :
  integral) param : _unknown[42]
  {
    if(109584 call _cond_test(109580 call > count 0))
    {
      (109553 call compilerError "count operators with positive count require the range to have a low bound")
    }
    {
      { scopeless
        if(109576 call _cond_test(109572 call == count 0))
        {
          (109558 return(109559 call + high 1))
        }
        {
          (109564 return(109565 call +(109567 call + high count) 1))
        }
      }
    }
  }
  function chpl_low_bound_count_for_param_loop[109591](arg high[109593]:_any[141](?), arg count[109595]:_any[141](?)) : _unknown[42] "last resort"
  {
    (109599 call chpl_build_high_bounded_range high)
    (109602 call compilerError "can't apply '#' to a range with idxType "(109606 call :(109609 'typeof' high) string[244]) " using a count of type "(109614 call :(109617 'typeof' count) string[244]))
  }
  function chpl_high_bound_count_for_param_loop[109621](param arg low[109624] :
  integral, param arg count[109628] :
  integral) param : _unknown[42]
  {
    if(109665 call _cond_test(109661 call < count 0))
    {
      (109634 call compilerError "count operators with negative count require the range to have a high bound")
    }
    {
      { scopeless
        if(109657 call _cond_test(109653 call == count 0))
        {
          (109639 return(109640 call - low 1))
        }
        {
          (109645 return(109646 call -(109648 call + low count) 1))
        }
      }
    }
  }
  function chpl_high_bound_count_for_param_loop[109672](arg low[109674]:_any[141](?), arg count[109676]:_any[141](?)) : _unknown[42] "last resort"
  {
    (109680 call chpl_build_low_bounded_range low)
    (109683 call compilerError "can't apply '#' to a range with idxType "(109685 call :(109688 'typeof' low) string[244]) " using a count of type "(109691 call :(109694 'typeof' count) string[244]))
  }
  function chpl_bounded_count_for_param_loop_low[109698](param arg low[109701] :
  integral, param arg high[109705] :
  integral, param arg count[109709] :
  integral) param : _unknown[42]
  {
    { scopeless
      unknown abs_count[109714] "param"(109723 IfExpr (109715 call < count 0) then
      { scopeless
        (109719 call - count)
      } else
      { scopeless
        count
      } )
      (109727 'end of statement')
    }
    { scopeless
      unknown size[109729] "param"(109730 call +(109732 call - high low) 1)
      (109738 'end of statement')
    }
    if(109795 call _cond_test(109791 call < size abs_count))
    {
      (109741 call compilerError "Count of "(109745 call : abs_count string[244]) " is too small for range of size "(109752 call : size string[244]))
    }
    {
      { scopeless
        if(109786 call _cond_test(109782 call == count 0))
        {
          (109757 return(109758 call + high 1))
        }
        {
          { scopeless
            if(109778 call _cond_test(109774 call < count 0))
            {
              (109763 return(109764 call +(109766 call + high count) 1))
            }
            {
              (109772 return low)
            }
          }
        }
      }
    }
  }
  function chpl_bounded_count_for_param_loop_low[109802](arg low[109804]:_any[141](?), arg high[109806]:_any[141](?), arg count[109808]:_any[141](?)) : _unknown[42] "last resort"
  {
    { scopeless
      const r[109812] "const"(109814 call chpl_build_bounded_range low high)
      (109818 'end of statement')
    }
    (109820 call compilerError "can't apply '#' to a range with idxType "(109822 call :(109825 call . r c"idxType") string[244]) " using a count of type "(109830 call :(109833 'typeof' count) string[244]))
  }
  function chpl_bounded_count_for_param_loop_high[109837](param arg low[109840] :
  integral, param arg high[109844] :
  integral, param arg count[109848] :
  integral) param : _unknown[42]
  {
    if(109882 call _cond_test(109878 call == count 0))
    {
      (109853 return(109854 call - low 1))
    }
    {
      { scopeless
        if(109874 call _cond_test(109870 call < count 0))
        {
          (109859 return high)
        }
        {
          (109862 return(109863 call -(109865 call + low count) 1))
        }
      }
    }
  }
  function chpl_bounded_count_for_param_loop_high[109889](arg low[109891]:_any[141](?), arg high[109893]:_any[141](?), arg count[109895]:_any[141](?)) : _unknown[42] "last resort"
  {
    { scopeless
      const r[109899] "const"(109901 call chpl_build_bounded_range low high)
      (109905 'end of statement')
    }
    (109907 call compilerError "can't apply '#' to a range with idxType "(109909 call :(109912 call . r c"idxType") string[244]) " using a count of type "(109917 call :(109920 'typeof' count) string[244]))
  }
  function _unknown[42].stride[109924](arg _mt[109930]:_MT[201], arg this[109927] :
  range) : _unknown[42] "inline" "method" "no where doc" "no parens"
  {
    (109937 return _stride)
  }
  where {
    (109932 call !(109935 call hasParamStride))
  }
  function _unknown[42].stride[109942](arg _mt[109948]:_MT[201], arg this[109945] :
  range) param : _unknown[42] "method" "no parens"
  {
    (109953 return(109954 call :(109967 IfExpr (109956 call == strides(109960 call . strideKind c"one")) then
    { scopeless
      1
    } else
    { scopeless
      (109964 call - 1)
    } ) strType))
  }
  where {
    (109951 call hasParamStride)
  }
  function _unknown[42].alignment[109974](arg _mt[109980]:_MT[201], arg this[109977] :
  range) : _unknown[42] "inline" "method" "no where doc" "no parens"
  {
    (109987 return(109989 call chpl_intToIdx(109994 IfExpr (109991 call hasParamAlignmentField) then
    { scopeless
      0
    } else
    { scopeless
      _alignment
    } )))
  }
  where {
    (109982 call !(109985 call hasParamAlignment))
  }
  function _unknown[42].alignment[110000](arg _mt[110006]:_MT[201], arg this[110003] :
  range) param : _unknown[42] "method" "no parens"
  {
    (110011 return(110023 IfExpr (110013 call isEnum idxType) then
    { scopeless
      (110016 call chpl__orderToEnum 0 idxType)
    } else
    { scopeless
      (110019 call : 0 idxType)
    } ))
  }
  where {
    (110009 call hasParamAlignment)
  }
  function _unknown[42].isAligned[110029](arg _mt[110035]:_MT[201], arg this[110032] :
  range) : _unknown[42] "inline" "method" "no where doc"
  {
    (110042 return(110043 call != _alignment unalignedMark))
  }
  where {
    (110037 call !(110040 call hasParamAligned))
  }
  function _unknown[42].isAligned[110050](arg _mt[110056]:_MT[201], arg this[110053] :
  range) param : _unknown[42] "method"
  {
    (110061 return 1)
  }
  where {
    (110059 call hasParamAligned)
  }
  function _unknown[42].hasParamStride[110066](arg _mt[110072]:_MT[201], arg this[110069] :
  range) param : _unknown[42] "method"
  {
    (110075 return(110077 call hasPosNegUnitStride))
  }
  function _unknown[42].hasParamAlignmentField[110080](arg _mt[110086]:_MT[201], arg this[110083] :
  range) param : _unknown[42] "method"
  {
    (110089 return(110091 call hasPosNegUnitStride))
  }
  function _unknown[42].hasParamAlignment[110094](arg _mt[110100]:_MT[201], arg this[110097] :
  range) param : _unknown[42] "method"
  {
    (110103 return(110104 call &&(110107 call hasParamAlignmentField)(110108 call ||(110110 call ||(110113 call isIntegral idxType)(110116 call isEnum idxType))(110119 call isBool idxType))))
  }
  function _unknown[42].hasParamAligned[110123](arg _mt[110129]:_MT[201], arg this[110126] :
  range) param : _unknown[42] "method"
  {
    (110132 return(110134 call hasPosNegUnitStride))
  }
  function _unknown[42].hasParamStrideAltvalAld[110137](arg _mt[110143]:_MT[201], arg this[110140] :
  range) param : _unknown[42] "method"
  {
    (110146 return(110148 call hasPosNegUnitStride))
  }
  function _unknown[42].hasParamStrideAltvalAld[110151](arg _mt[110157]:_MT[201], arg this[110154] :
  range) param : _unknown[42] "method"
  {
    { scopeless
      unknown r[110161] this
      (110164 'end of statement')
    }
    (110165 return(110172 call(110169 call . r c"hasParamStrideAltvalAld")))
  }
  function _unknown[42].hasLowBound[110175](arg _mt[110181]:_MT[201], arg this[110178] :
  range) param : _unknown[42] "method"
  {
    (110184 return(110185 call ||(110187 call == bounds(110191 call . boundKind c"both"))(110194 call == bounds(110198 call . boundKind c"low"))))
  }
  function _unknown[42].lowBound[110203](arg _mt[110209]:_MT[201], arg this[110206] :
  range) : _unknown[42] "inline" "method" "no parens"
  {
    if(110223 call _cond_test(110219 call !(110222 call hasLowBound)))
    {
      (110215 call compilerError "can't query the low bound of a range without one")
    }
    (110227 return(110229 call chpl_intToIdx _low))
  }
  { scopeless type
    idxType
  }
  function _unknown[42].hasUnitStride[110234](arg _mt[110240]:_MT[201], arg this[110237] :
  range) param : _unknown[42] "method"
  {
    (110243 return(110250 call(110247 call . strides c"isOne")))
  }
  function _unknown[42].hasPosNegUnitStride[110253](arg _mt[110259]:_MT[201], arg this[110256] :
  range) param : _unknown[42] "method"
  {
    (110262 return(110267 call(110264 call . strides c"isPosNegOne")))
  }
  function _unknown[42].hasPositiveStride[110270](arg _mt[110276]:_MT[201], arg this[110273] :
  range) param : _unknown[42] "method"
  {
    (110286 return(110291 call(110288 call . strides c"isPositive")))
  }
  where {
    (110284 call(110281 call . strides c"hasSign"))
  }
  function _unknown[42].hasPositiveStride[110295](arg _mt[110301]:_MT[201], arg this[110298] :
  range) : _unknown[42] "method"
  {
    (110311 return(110312 call > _stride 0))
  }
  where {
    (110309 call(110306 call . strides c"isAny"))
  }
  function _unknown[42].hasNegativeStride[110319](arg _mt[110325]:_MT[201], arg this[110322] :
  range) param : _unknown[42] "method"
  {
    (110333 return(110340 call(110337 call . strides c"isNegative")))
  }
  where {
    (110331 call(110328 call . strides c"hasSign"))
  }
  function _unknown[42].hasNegativeStride[110344](arg _mt[110350]:_MT[201], arg this[110347] :
  range) : _unknown[42] "method"
  {
    (110358 return(110359 call < _stride 0))
  }
  where {
    (110356 call(110353 call . strides c"isAny"))
  }
  function _unknown[42].isOne[110366](arg _mt[110372]:_MT[201], param arg this[110369] :
  strideKind) param : _unknown[42] "method"
  {
    (110375 return(110376 call == this(110380 call . strideKind c"one")))
  }
  function _unknown[42].isNegOne[110385](arg _mt[110391]:_MT[201], param arg this[110388] :
  strideKind) param : _unknown[42] "method"
  {
    (110394 return(110395 call == this(110401 call . strideKind c"negOne")))
  }
  function _unknown[42].isPosNegOne[110406](arg _mt[110412]:_MT[201], param arg this[110409] :
  strideKind) param : _unknown[42] "method"
  {
    (110415 return(110416 call ||(110418 call == this(110422 call . strideKind c"one"))(110425 call == this(110429 call . strideKind c"negOne"))))
  }
  function _unknown[42].isPositive[110434](arg _mt[110440]:_MT[201], param arg this[110437] :
  strideKind) param : _unknown[42] "method"
  {
    (110443 return(110444 call ||(110446 call == this(110450 call . strideKind c"one"))(110453 call == this(110459 call . strideKind c"positive"))))
  }
  function _unknown[42].isNegative[110464](arg _mt[110470]:_MT[201], param arg this[110467] :
  strideKind) param : _unknown[42] "method"
  {
    (110473 return(110474 call ||(110476 call == this(110480 call . strideKind c"negOne"))(110483 call == this(110489 call . strideKind c"negative"))))
  }
  function _unknown[42].hasSign[110494](arg _mt[110500]:_MT[201], param arg this[110497] :
  strideKind) param : _unknown[42] "method"
  {
    (110503 return(110504 call != this(110510 call . strideKind c"any")))
  }
  function _unknown[42].isAny[110515](arg _mt[110521]:_MT[201], param arg this[110518] :
  strideKind) param : _unknown[42] "method"
  {
    (110524 return(110525 call == this(110529 call . strideKind c"any")))
  }
  function _unknown[42].defaultStride[110534](arg _mt[110540]:_MT[201], param arg this[110537] :
  strideKind) param : _unknown[42] "method"
  {
    (110543 return(110550 IfExpr (110545 call isNegative) then
    { scopeless
      (110546 call - 1)
    } else
    { scopeless
      1
    } ))
  }
  function isPositiveStride[110555](param arg strides[110558] :
  strideKind, arg stride[110561]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    (110569 return(110570 call > stride 0))
  }
  where {
    (110567 call(110564 call . strides c"isAny"))
  }
  function isPositiveStride[110577](param arg strides[110580] :
  strideKind, param arg stride[110583]:_any[141](?)) param : _unknown[42] "private"
  {
    (110591 return(110592 call > stride 0))
  }
  where {
    (110589 call(110586 call . strides c"isAny"))
  }
  function isPositiveStride[110599](param arg strides[110602] :
  strideKind, arg stride[110605]:_any[141](?)) param : _unknown[42] "private"
  {
    (110613 return(110618 call(110615 call . strides c"isPositive")))
  }
  where {
    (110611 call(110608 call . strides c"hasSign"))
  }
  function isNegativeStride[110622](param arg strides[110625] :
  strideKind, arg stride[110628]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    (110636 return(110637 call < stride 0))
  }
  where {
    (110634 call(110631 call . strides c"isAny"))
  }
  function isNegativeStride[110644](param arg strides[110647] :
  strideKind, param arg stride[110650]:_any[141](?)) param : _unknown[42] "private"
  {
    (110658 return(110659 call < stride 0))
  }
  where {
    (110656 call(110653 call . strides c"isAny"))
  }
  function isNegativeStride[110666](param arg strides[110669] :
  strideKind, arg stride[110672]:_any[141](?)) param : _unknown[42] "private"
  {
    (110680 return(110685 call(110682 call . strides c"isNegative")))
  }
  where {
    (110678 call(110675 call . strides c"hasSign"))
  }
  function chpl_strideProduct[110689](param arg s1[110692] :
  strideKind, param arg s2[110696] :
  strideKind) param : _unknown[42]
  {
    (110701 'use' strideKind)
    {
      unknown tmp[110977] "expr temp" "maybe param" "maybe type" "temp"
      (110979 'move' tmp[110977] s1)
      if(110984 call _cond_test(110981 call == tmp[110977] one))
      {
        { scopeless
          (110708 return s2)
        }
      }
      {
        if(110990 call _cond_test(110987 call == tmp[110977] positive))
        {
          unknown tmp[110759] "expr temp" "maybe param" "maybe type" "temp"
          (110761 'move' tmp[110759] s2)
          if(110766 call _cond_test(110763 call == tmp[110759] one))
          {
            { scopeless
              (110721 return positive)
            }
          }
          {
            if(110772 call _cond_test(110769 call == tmp[110759] positive))
            {
              { scopeless
                (110729 return positive)
              }
            }
            {
              if(110779 call _cond_test(110776 call == tmp[110759] negOne))
              {
                { scopeless
                  (110737 return negative)
                }
              }
              {
                if(110786 call _cond_test(110783 call == tmp[110759] negative))
                {
                  { scopeless
                    (110745 return negative)
                  }
                }
                {
                  if(110793 call _cond_test(110790 call == tmp[110759] any))
                  {
                    { scopeless
                      (110753 return any)
                    }
                  }
                }
              }
            }
          }
        }
        {
          if(110997 call _cond_test(110994 call == tmp[110977] negOne))
          {
            unknown tmp[110844] "expr temp" "maybe param" "maybe type" "temp"
            (110846 'move' tmp[110844] s2)
            if(110851 call _cond_test(110848 call == tmp[110844] one))
            {
              { scopeless
                (110806 return negOne)
              }
            }
            {
              if(110857 call _cond_test(110854 call == tmp[110844] positive))
              {
                { scopeless
                  (110814 return negative)
                }
              }
              {
                if(110864 call _cond_test(110861 call == tmp[110844] negOne))
                {
                  { scopeless
                    (110822 return one)
                  }
                }
                {
                  if(110871 call _cond_test(110868 call == tmp[110844] negative))
                  {
                    { scopeless
                      (110830 return positive)
                    }
                  }
                  {
                    if(110878 call _cond_test(110875 call == tmp[110844] any))
                    {
                      { scopeless
                        (110838 return any)
                      }
                    }
                  }
                }
              }
            }
          }
          {
            if(111004 call _cond_test(111001 call == tmp[110977] negative))
            {
              unknown tmp[110929] "expr temp" "maybe param" "maybe type" "temp"
              (110931 'move' tmp[110929] s2)
              if(110936 call _cond_test(110933 call == tmp[110929] one))
              {
                { scopeless
                  (110891 return negative)
                }
              }
              {
                if(110942 call _cond_test(110939 call == tmp[110929] positive))
                {
                  { scopeless
                    (110899 return negative)
                  }
                }
                {
                  if(110949 call _cond_test(110946 call == tmp[110929] negOne))
                  {
                    { scopeless
                      (110907 return positive)
                    }
                  }
                  {
                    if(110956 call _cond_test(110953 call == tmp[110929] negative))
                    {
                      { scopeless
                        (110915 return positive)
                      }
                    }
                    {
                      if(110963 call _cond_test(110960 call == tmp[110929] any))
                      {
                        { scopeless
                          (110923 return any)
                        }
                      }
                    }
                  }
                }
              }
            }
            {
              if(111011 call _cond_test(111008 call == tmp[110977] any))
              {
                { scopeless
                  (110971 return any)
                }
              }
            }
          }
        }
      }
    }
  }
  function chpl_strideProduct[111017](arg r1[111022] :
  (111020 call range ?[227]), arg r2[111028] :
  (111026 call range ?[227])) param : _unknown[42]
  {
    (111032 return(111034 call chpl_strideProduct(111036 call . r1 c"strides")(111040 call . r2 c"strides")))
  }
  function chpl_strideProduct[111045](arg r1[111050] :
  (111048 call range ?[227]), param arg stride2[111054] :
  integral) param : _unknown[42]
  {
    (111059 'use' strideKind)
    { scopeless
      unknown s2[111062] "param"(111087 IfExpr (111063 call == stride2 1) then
      { scopeless
        one
      } else
      { scopeless(111084 IfExpr (111068 call == stride2(111071 call - 1)) then
        { scopeless
          negOne
        } else
        { scopeless(111081 IfExpr (111075 call > stride2 0) then
          { scopeless
            positive
          } else
          { scopeless
            negative
          } )
        } )
      } )
      (111091 'end of statement')
    }
    (111092 return(111094 call chpl_strideProduct(111096 call . r1 c"strides") s2))
  }
  function chpl_strideUnion[111102](param arg s1[111105] :
  strideKind, param arg s2[111109] :
  strideKind) param : _unknown[42]
  {
    (111114 'use' strideKind)
    {
      unknown tmp[111467] "expr temp" "maybe param" "maybe type" "temp"
      (111469 'move' tmp[111467] s1)
      if(111474 call _cond_test(111471 call == tmp[111467] one))
      {
        unknown tmp[111164] "expr temp" "maybe param" "maybe type" "temp"
        (111166 'move' tmp[111164] s2)
        if(111171 call _cond_test(111168 call == tmp[111164] one))
        {
          { scopeless
            (111126 return one)
          }
        }
        {
          if(111177 call _cond_test(111174 call == tmp[111164] positive))
          {
            { scopeless
              (111134 return positive)
            }
          }
          {
            if(111184 call _cond_test(111181 call == tmp[111164] negOne))
            {
              { scopeless
                (111142 return any)
              }
            }
            {
              if(111191 call _cond_test(111188 call == tmp[111164] negative))
              {
                { scopeless
                  (111150 return any)
                }
              }
              {
                if(111198 call _cond_test(111195 call == tmp[111164] any))
                {
                  { scopeless
                    (111158 return any)
                  }
                }
              }
            }
          }
        }
      }
      {
        if(111480 call _cond_test(111477 call == tmp[111467] negOne))
        {
          unknown tmp[111249] "expr temp" "maybe param" "maybe type" "temp"
          (111251 'move' tmp[111249] s2)
          if(111256 call _cond_test(111253 call == tmp[111249] one))
          {
            { scopeless
              (111211 return any)
            }
          }
          {
            if(111262 call _cond_test(111259 call == tmp[111249] positive))
            {
              { scopeless
                (111219 return any)
              }
            }
            {
              if(111269 call _cond_test(111266 call == tmp[111249] negOne))
              {
                { scopeless
                  (111227 return negOne)
                }
              }
              {
                if(111276 call _cond_test(111273 call == tmp[111249] negative))
                {
                  { scopeless
                    (111235 return negative)
                  }
                }
                {
                  if(111283 call _cond_test(111280 call == tmp[111249] any))
                  {
                    { scopeless
                      (111243 return any)
                    }
                  }
                }
              }
            }
          }
        }
        {
          if(111487 call _cond_test(111484 call == tmp[111467] positive))
          {
            unknown tmp[111334] "expr temp" "maybe param" "maybe type" "temp"
            (111336 'move' tmp[111334] s2)
            if(111341 call _cond_test(111338 call == tmp[111334] one))
            {
              { scopeless
                (111296 return positive)
              }
            }
            {
              if(111347 call _cond_test(111344 call == tmp[111334] positive))
              {
                { scopeless
                  (111304 return positive)
                }
              }
              {
                if(111354 call _cond_test(111351 call == tmp[111334] negOne))
                {
                  { scopeless
                    (111312 return any)
                  }
                }
                {
                  if(111361 call _cond_test(111358 call == tmp[111334] negative))
                  {
                    { scopeless
                      (111320 return any)
                    }
                  }
                  {
                    if(111368 call _cond_test(111365 call == tmp[111334] any))
                    {
                      { scopeless
                        (111328 return any)
                      }
                    }
                  }
                }
              }
            }
          }
          {
            if(111494 call _cond_test(111491 call == tmp[111467] negative))
            {
              unknown tmp[111419] "expr temp" "maybe param" "maybe type" "temp"
              (111421 'move' tmp[111419] s2)
              if(111426 call _cond_test(111423 call == tmp[111419] one))
              {
                { scopeless
                  (111381 return any)
                }
              }
              {
                if(111432 call _cond_test(111429 call == tmp[111419] positive))
                {
                  { scopeless
                    (111389 return any)
                  }
                }
                {
                  if(111439 call _cond_test(111436 call == tmp[111419] negOne))
                  {
                    { scopeless
                      (111397 return negative)
                    }
                  }
                  {
                    if(111446 call _cond_test(111443 call == tmp[111419] negative))
                    {
                      { scopeless
                        (111405 return negative)
                      }
                    }
                    {
                      if(111453 call _cond_test(111450 call == tmp[111419] any))
                      {
                        { scopeless
                          (111413 return any)
                        }
                      }
                    }
                  }
                }
              }
            }
            {
              if(111501 call _cond_test(111498 call == tmp[111467] any))
              {
                { scopeless
                  (111461 return any)
                }
              }
            }
          }
        }
      }
    }
  }
  function chpl_strideUnion[111507](arg args[111510] :
  _tuple) param : _unknown[42]
  {
    (111514 return(111516 call chpl_strideUnion(111518 'expand_tuple' args)))
  }
  function chpl_strideUnion[111521](arg arg[111523]:_any[141](?), arg args[111526]:_any[141](?) ...) param : _unknown[42]
  {
    (111530 return(111532 call chpl_strideUnion(111534 call chpl_strideUnion arg)(111537 call chpl_strideUnion(111539 'expand_tuple' args))))
  }
  function chpl_strideUnion[111542](arg arg[111544]:_any[141](?)) param : _unknown[42]
  {
    (111548 return(111550 call . arg c"strides"))
  }
  { scopeless type
    strideKind
  }
  function chpl_strideUnionRC[111556](arg args[111559] :
  _tuple) param : _unknown[42]
  {
    (111563 return(111565 call chpl_strideUnionRC(111567 'expand_tuple' args)))
  }
  function chpl_strideUnionRC[111570](arg arg[111572]:_any[141](?), arg args[111575]:_any[141](?) ...) param : _unknown[42]
  {
    (111579 return(111581 call chpl_strideUnion(111583 call chpl_strideUnionRC arg)(111586 call chpl_strideUnionRC(111588 'expand_tuple' args))))
  }
  function chpl_strideUnionRC[111591](arg arg[111593]:_any[141](?)) param : _unknown[42]
  {
    (111596 return(111608 IfExpr (111598 call isRange arg) then
    { scopeless
      (111601 call . arg c"strides")
    } else
    { scopeless
      (111605 call . strideKind c"one")
    } ))
  }
  function chpl_assignStrideIsSafe[111613](param arg lhs[111616] :
  strideKind, param arg rhs[111620] :
  strideKind) param : _unknown[42]
  {
    {
      unknown tmp[111700] "expr temp" "maybe param" "maybe type" "temp"
      (111702 'move' tmp[111700] lhs)
      if(111707 call _cond_test(111704 call == tmp[111700](111628 call . strideKind c"one")))
      {
        { scopeless
          (111632 return(111637 call(111634 call . rhs c"isOne")))
        }
      }
      {
        if(111713 call _cond_test(111710 call == tmp[111700](111643 call . strideKind c"positive")))
        {
          { scopeless
            (111647 return(111652 call(111649 call . rhs c"isPositive")))
          }
        }
        {
          if(111720 call _cond_test(111717 call == tmp[111700](111658 call . strideKind c"negOne")))
          {
            { scopeless
              (111662 return(111669 call(111666 call . rhs c"isNegOne")))
            }
          }
          {
            if(111727 call _cond_test(111724 call == tmp[111700](111675 call . strideKind c"negative")))
            {
              { scopeless
                (111679 return(111684 call(111681 call . rhs c"isNegative")))
              }
            }
            {
              if(111734 call _cond_test(111731 call == tmp[111700](111690 call . strideKind c"any")))
              {
                { scopeless
                  (111694 return 1)
                }
              }
            }
          }
        }
      }
    }
  }
  function chpl_assignStrideIsSafe[111740](arg lhs[111745] :
  (111743 call range ?[227]), arg rhs[111751] :
  (111749 call range ?[227])) param : _unknown[42]
  {
    (111755 return(111757 call chpl_assignStrideIsSafe(111759 call . lhs c"strides")(111763 call . rhs c"strides")))
  }
  function chpl_assignStrideIsSafe[111768](param arg lhs[111771] :
  strideKind, param arg rhs[111775] :
  strideKind, arg rhsStride[111778]:_any[141](?)) param : _unknown[42]
  {
    (111799 return 1)
  }
  where {
    (111780 call ||(111783 call chpl_assignStrideIsSafe lhs rhs)(111786 call &&(111788 call == lhs(111792 call . strideKind c"positive"))(111796 call isUint rhsStride)))
  }
  function chpl_assignStrideIsSafe[111804](param arg lhs[111807] :
  strideKind, param arg rhs[111811] :
  strideKind, arg rhsStride[111814]:_any[141](?)) : _unknown[42]
  {
    {
      unknown tmp[111892] "expr temp" "maybe param" "maybe type" "temp"
      (111894 'move' tmp[111892] lhs)
      if(111899 call _cond_test(111896 call == tmp[111892](111821 call . strideKind c"one")))
      {
        { scopeless
          (111825 return(111826 call == rhsStride 1))
        }
      }
      {
        if(111905 call _cond_test(111902 call == tmp[111892](111835 call . strideKind c"positive")))
        {
          { scopeless
            (111839 return(111840 call > rhsStride 0))
          }
        }
        {
          if(111912 call _cond_test(111909 call == tmp[111892](111849 call . strideKind c"negOne")))
          {
            { scopeless
              (111853 return(111854 call == rhsStride(111857 call - 1)))
            }
          }
          {
            if(111919 call _cond_test(111916 call == tmp[111892](111865 call . strideKind c"negative")))
            {
              { scopeless
                (111869 return(111870 call < rhsStride 0))
              }
            }
            {
              if(111926 call _cond_test(111923 call == tmp[111892](111879 call . strideKind c"any")))
              {
                { scopeless
                  (111884 call compilerError "internal error")
                }
              }
            }
          }
        }
      }
    }
  }
  function chpl_assignStrideIsUnsafe[111932](param arg lhs[111935] :
  strideKind, param arg rhs[111939] :
  strideKind) param : _unknown[42]
  {
    (111943 return(111944 call ||(111946 call &&(111952 call(111949 call . lhs c"isPositive"))(111957 call(111954 call . rhs c"isNegative")))(111958 call &&(111964 call(111961 call . lhs c"isNegative"))(111969 call(111966 call . rhs c"isPositive")))))
  }
  function assignmentIsLegal[111972](arg to[111974]:_any[141](?), arg from[111976]:_any[141](?)) param : _unknown[42] "private"
  {
    if(111986 call _cond_test(111982 call == to from))
    {
      { scopeless
        (111979 return 1)
      }
    }
    { scopeless
      { scopeless
        unknown toVar[111997] to
      }
      { scopeless
        unknown fromVar[111993] from
      }
      (112000 'end of statement')
    }
    (112001 return(112003 call canResolve "=" toVar fromVar))
  }
  function verifyAppropriateStride[112011](param arg strides[112013]:_any[141](?), arg stride[112015]:_any[141](?)) : _unknown[42] "private"
  {
    if(112030 call _cond_test(112029 call(112026 call . strides c"isPositive")))
    {
      { scopeless
        (112019 call assert(112020 call > stride 0))
      }
    }
    if(112047 call _cond_test(112046 call(112043 call . strides c"isNegative")))
    {
      { scopeless
        (112036 call assert(112037 call < stride 0))
      }
    }
  }
  function _unknown[42].chpl_setFields[112054](arg _mt[112066]:_MT[201], ref arg this[112057] :
  range, arg low[112060]:_any[141](?), arg high[112062]:_any[141](?), arg stride[112064]:_any[141](?)) : _unknown[42] "inline" "method"
  {
    (112069 call =(112072 call . this c"_low")(112075 call :(112078 call chpl__idxToInt low)(112081 call . this c"chpl_integralIdxType")))
    (112084 call =(112087 call . this c"_high")(112090 call :(112093 call chpl__idxToInt high)(112096 call . this c"chpl_integralIdxType")))
    if(112183 call _cond_test(112182 call(112179 call . this c"hasParamStrideAltvalAld")))
    {
      if(112109 call _cond_test boundsChecking)
      {
        { scopeless
          (112101 call verifyAppropriateStride(112103 call . this c"strides") stride)
        }
      }
    }
    {
      (112115 call =(112118 call . this c"_stride")(112121 call : stride(112127 call . this c"strType")))
      { scopeless
        const first[112131] "const"(112141 IfExpr (112138 call(112135 call . this c"hasPositiveStride")) then
        { scopeless
          low
        } else
        { scopeless
          high
        } )
        (112145 'end of statement')
      }
      (112146 call =(112149 call . this c"_alignment")(112152 call :(112155 call chpl__mod(112157 call chpl__idxToInt first) stride)(112161 call . this c"strType")))
      if(112173 call _cond_test boundsChecking)
      {
        { scopeless
          (112165 call assert(112170 call(112167 call . this c"isAligned")))
        }
      }
    }
  }
  function _unknown[42].chpl_setFields[112189](arg _mt[112199]:_MT[201], ref arg this[112192] :
  range, arg low[112195]:_any[141](?), arg high[112197]:_any[141](?)) : _unknown[42] "inline" "method"
  {
    (112203 call compilerAssert(112210 call(112207 call . this c"hasParamStride")))
    (112211 call =(112214 call . this c"_low")(112217 call :(112220 call chpl__idxToInt low)(112223 call . this c"chpl_integralIdxType")))
    (112226 call =(112229 call . this c"_high")(112232 call :(112235 call chpl__idxToInt high)(112238 call . this c"chpl_integralIdxType")))
  }
  function _unknown[42].low[112243](arg _mt[112249]:_MT[201], arg this[112246] :
  range) : _unknown[42] "inline" "method" "no parens"
  {
    if(112261 call _cond_test(112257 call !(112260 call hasLowBound)))
    {
      (112255 call compilerError "can't query the low bound of a range without one")
    }
    (112265 return(112267 call chpl_intToIdx(112271 call . this c"alignedLowAsInt")))
  }
  { scopeless type
    idxType
  }
  function _unknown[42].alignedLowAsInt[112277](arg _mt[112283]:_MT[201], arg this[112280] :
  range) : _unknown[42] "inline" "method" "no parens"
  {
    if(112296 call _cond_test(112292 call !(112295 call isAligned)))
    {
      { scopeless
        (112287 call halt "Can't query the aligned bounds of an ambiguously aligned range")
      }
    }
    if(112318 call _cond_test(112317 call(112314 call . this c"hasPosNegUnitStride")))
    {
      { scopeless
        (112301 return _low)
      }
    }
    {
      { scopeless
        (112304 return(112306 call helpAlignLow _low _alignment stride))
      }
    }
  }
  function _unknown[42].chpl_alignedLowAsIntForIter[112326](arg _mt[112332]:_MT[201], arg this[112329] :
  range) : _unknown[42] "inline" "method" "no parens"
  {
    if(112364 call _cond_test(112349 call &&(112351 call &&(112353 call !(112356 call hasUnitStride))(112357 call !(112360 call hasLowBound)))(112362 call isFiniteIdxType idxType)))
    {
      (112336 return(112338 call helpAlignLow(112340 call chpl__idxToInt(112342 call lowBoundForIter this)) _alignment stride))
    }
    {
      (112347 return alignedLowAsInt)
    }
  }
  function helpAlignLow[112370](arg l[112372]:_any[141](?), arg a[112374]:_any[141](?), arg s[112376]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    (112379 return(112380 call + l(112384 call chpl__diffMod(112385 call : a(112389 'typeof' l)) l s)))
  }
  function _unknown[42].hasHighBound[112394](arg _mt[112400]:_MT[201], arg this[112397] :
  range) param : _unknown[42] "method"
  {
    (112403 return(112404 call ||(112406 call == bounds(112410 call . boundKind c"both"))(112413 call == bounds(112417 call . boundKind c"high"))))
  }
  function _unknown[42].highBound[112422](arg _mt[112428]:_MT[201], arg this[112425] :
  range) : _unknown[42] "inline" "method" "no parens"
  {
    if(112442 call _cond_test(112438 call !(112441 call hasHighBound)))
    {
      (112434 call compilerError "can't query the high bound of a range without one")
    }
    if(112468 call _cond_test(112466 call chpl__singleValIdxType idxType))
    {
      if(112461 call _cond_test(112457 call > _low _high))
      {
        (112449 call warning "This range is empty and has a single-value idxType, so its high bound isn't trustworthy")
        (112453 return(112455 call chpl_intToIdx _low))
      }
    }
    (112472 return(112474 call chpl_intToIdx _high))
  }
  { scopeless type
    idxType
  }
  function _unknown[42].high[112479](arg _mt[112485]:_MT[201], arg this[112482] :
  range) : _unknown[42] "inline" "method" "no parens"
  {
    if(112497 call _cond_test(112493 call !(112496 call hasHighBound)))
    {
      (112491 call compilerError "can't query the high bound of a range without one")
    }
    if(112522 call _cond_test(112520 call chpl__singleValIdxType idxType))
    {
      if(112515 call _cond_test(112511 call > _low _high))
      {
        (112504 call warning "This range is empty and has a single-value idxType, so its high bound isn't trustworthy")
        (112506 return(112508 call . this c"low"))
      }
    }
    if(112546 call _cond_test(112544 call chpl__singleValIdxType idxType))
    {
      if(112539 call _cond_test(112535 call == size 0))
      {
        (112529 call warning "This range is empty and has a single-value idxType, so its high bound isn't trustworthy")
        (112531 return(112533 call chpl_intToIdx _low))
      }
    }
    (112550 return(112552 call chpl_intToIdx(112556 call . this c"alignedHighAsInt")))
  }
  { scopeless type
    idxType
  }
  function _unknown[42].alignedHighAsInt[112562](arg _mt[112568]:_MT[201], arg this[112565] :
  range) : _unknown[42] "inline" "method" "no parens"
  {
    if(112579 call _cond_test(112575 call !(112578 call isAligned)))
    {
      { scopeless
        (112572 call halt "Can't query the aligned bounds of an ambiguously aligned range")
      }
    }
    if(112599 call _cond_test(112598 call(112595 call . this c"hasPosNegUnitStride")))
    {
      { scopeless
        (112584 return _high)
      }
    }
    {
      { scopeless
        (112587 return(112589 call helpAlignHigh _high _alignment stride))
      }
    }
  }
  function _unknown[42].chpl_alignedHighAsIntForIter[112607](arg _mt[112613]:_MT[201], arg this[112610] :
  range) : _unknown[42] "inline" "method" "no parens"
  {
    if(112645 call _cond_test(112630 call &&(112632 call &&(112634 call !(112637 call hasUnitStride))(112638 call !(112641 call hasHighBound)))(112643 call isFiniteIdxType idxType)))
    {
      (112617 return(112619 call helpAlignHigh(112621 call chpl__idxToInt(112623 call highBoundForIter this)) _alignment stride))
    }
    {
      (112628 return alignedHighAsInt)
    }
  }
  function helpAlignHigh[112651](arg h[112653]:_any[141](?), arg a[112655]:_any[141](?), arg s[112657]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    (112660 return(112661 call - h(112665 call chpl__diffMod h(112667 call : a(112671 'typeof' h)) s)))
  }
  function _unknown[42].chpl_isNaturallyAligned[112675](arg _mt[112681]:_MT[201], arg this[112678] :
  range) : _unknown[42] "method" "no where doc"
  {
    if(112788 call _cond_test(112781 call == bounds(112785 call . boundKind c"both")))
    {
      if(112709 call _cond_test(112708 call hasPositiveStride))
      {
        { scopeless
          (112698 return(112699 call ==(112702 call . this c"alignedLowAsInt") _low))
        }
      }
      if(112725 call _cond_test(112724 call hasNegativeStride))
      {
        { scopeless
          (112714 return(112715 call ==(112718 call . this c"alignedHighAsInt") _high))
        }
      }
      (112730 return 0)
    }
    {
      { scopeless
        if(112776 call _cond_test(112769 call == bounds(112773 call . boundKind c"low")))
        {
          (112733 return(112734 call &&(112737 call hasPositiveStride)(112738 call ==(112741 call . this c"alignedLowAsInt") _low)))
        }
        {
          { scopeless
            if(112765 call _cond_test(112758 call == bounds(112762 call . boundKind c"high")))
            {
              (112746 return(112747 call &&(112750 call hasNegativeStride)(112751 call ==(112754 call . this c"alignedHighAsInt") _high)))
            }
          }
        }
      }
    }
  }
  where {
    (112683 call &&(112685 call !(112688 call hasPosNegUnitStride))(112689 call != bounds(112693 call . boundKind c"neither")))
  }
  function _unknown[42].chpl_isNaturallyAligned[112796](arg _mt[112802]:_MT[201], arg this[112799] :
  range) param : _unknown[42] "method"
  {
    (112816 return(112818 call hasPosNegUnitStride))
  }
  where {
    (112804 call ||(112807 call hasPosNegUnitStride)(112808 call == bounds(112812 call . boundKind c"neither")))
  }
  function hasAmbiguousAlignmentForIter[112822](arg r[112824]:_any[141](?)) param : _unknown[42] "inline" "private"
  {
    (112840 return 0)
  }
  where {
    (112826 call ||(112832 call(112829 call . r c"hasPosNegUnitStride"))(112834 call isFiniteIdxType(112836 call . r c"idxType")))
  }
  function hasAmbiguousAlignmentForIter[112845](arg r[112847]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    (112850 return(112851 call !(112857 call(112854 call . r c"isAligned"))))
  }
  function _unknown[42].isEmpty[112860](arg _mt[112866]:_MT[201], arg this[112863] :
  range) : _unknown[42] "inline" "method"
  {
    (112869 return(112871 call isEmptyHelp this))
  }
  function _unknown[42].isEmpty[112875](arg _mt[112881]:_MT[201], arg this[112878] :
  range) : _unknown[42] "inline" "method" "@unstable"
  {
    (112899 return(112901 call isEmptyHelp this))
  }
  where {
    (112883 call &&(112886 call isFiniteIdxType idxType)(112888 call !=(112891 call . this c"bounds")(112895 call . boundKind c"both")))
  }
  function isEmptyHelp[112906](arg r[112908]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    if(112936 call _cond_test(112931 call chpl__singleValIdxType(112933 call . r c"idxType")))
    {
      if(112925 call _cond_test(112915 call >(112918 call . r c"_low")(112922 call . r c"_high")))
      {
        { scopeless
          (112912 return 1)
        }
      }
    }
    if(112991 call _cond_test(112981 call && boundsChecking(112984 call !(112990 call(112987 call . r c"isAligned")))))
    {
      { scopeless
        (112944 call(112941 call . HaltWrappers c"boundsCheckHalt") "isEmpty() is invoked on an ambiguously-aligned range")
      }
    }
    {
      { scopeless
        (112949 return(112950 call &&(112952 call ||(112954 call ==(112957 call . r c"bounds")(112961 call . boundKind c"both"))(112965 call isFiniteIdxType(112967 call . r c"idxType")))(112970 call >(112973 call . r c"alignedLowAsInt")(112977 call . r c"alignedHighAsInt"))))
      }
    }
  }
  function _unknown[42].size[112999](arg _mt[113005]:_MT[201], arg this[113002] :
  range) : _unknown[42] "method" "no parens"
  {
    (113009 return(113014 call(113011 call . this c"sizeAs") int[10]))
  }
  { scopeless type
    int[10]
  }
  function _unknown[42].sizeAs[113019](arg _mt[113029]:_MT[201], arg this[113022] :
  range, arg t[113026] :
  integral) : _unknown[42] "method"
  {
    if(113049 call _cond_test(113039 call !=(113042 call . this c"bounds")(113046 call . boundKind c"both")))
    {
      { scopeless
        (113034 call compilerError "'size' is not defined on unbounded ranges")
      }
    }
    if(113070 call _cond_test(113068 call chpl__singleValIdxType idxType))
    {
      if(113062 call _cond_test(113058 call > _low _high))
      {
        { scopeless
          (113055 return 0)
        }
      }
    }
    (113074 return(113076 call sizeAsHelp t))
  }
  { scopeless type
    t
  }
  function _unknown[42].sizeAsHelp[113081](arg _mt[113105]:_MT[201], arg this[113084] :
  range, arg t[113088] :
  integral, arg al[113095] =
  (113092 call . this c"alignedLowAsInt"), arg ah[113102] =
  (113099 call . this c"alignedHighAsInt")) : _unknown[42] "method"
  {
    { scopeless
      { scopeless
        const ah[113118] "const"(113120 call . this c"alignedHighAsInt")
      }
      { scopeless
        const al[113111] "const"(113113 call . this c"alignedLowAsInt")
      }
      (113124 'end of statement')
    }
    if(113132 call _cond_test(113128 call > al ah))
    {
      { scopeless
        (113125 return 0)
      }
    }
    { scopeless
      const s[113138] "const"(113139 call :(113142 call abs(113144 call . this c"stride")) uint[86])
      (113149 'end of statement')
    }
    { scopeless
      unknown width[113151] "param"(113153 call numBits(113155 'typeof' al))
      (113157 'end of statement')
    }
    { scopeless
      const lenAsUint[113159] "const"(113160 call +(113162 call /(113164 call :(113166 call -(113168 call : ah(113172 call uint[86] width))(113174 call : al(113178 call uint[86] width))) uint[86]) s) 1)
      (113184 'end of statement')
    }
    if(113229 call _cond_test(113214 call && boundsChecking(113217 call ||(113219 call == lenAsUint 0)(113223 call > lenAsUint(113227 call max t)))))
    {
      (113190 call(113187 call . HaltWrappers c"boundsCheckHalt")(113191 call +(113193 call +(113195 call +(113197 call + "range.size exceeds max("(113202 call : t string[244])) ") for: '")(113209 call : this string[244])) "'"))
    }
    (113233 return(113234 call : lenAsUint t))
  }
  { scopeless type
    t
  }
  function _unknown[42].chpl_sizeAsForIter[113241](arg _mt[113251]:_MT[201], arg this[113244] :
  range, arg t[113248] :
  integral) : _unknown[42] "method"
  {
    if(113271 call _cond_test(113269 call chpl__singleValIdxType idxType))
    {
      if(113263 call _cond_test(113259 call > _low _high))
      {
        { scopeless
          (113256 return 0)
        }
      }
    }
    if(113312 call _cond_test(113297 call &&(113299 call !=(113302 call . this c"bounds")(113306 call . boundKind c"both"))(113310 call isFiniteIdxType idxType)))
    {
      (113276 return(113278 call sizeAsHelp t(113283 call . this c"chpl_alignedLowAsIntForIter")(113289 call . this c"chpl_alignedHighAsIntForIter")))
    }
    {
      (113293 return(113295 call sizeAs t))
    }
  }
  { scopeless type
    t
  }
  function hasFirstLastAreParam[113319](arg r[113321]:_any[141](?)) param : _unknown[42] "private"
  {
    {
      unknown tmp[113396] "expr temp" "maybe param" "maybe type" "temp"
      (113398 'move' tmp[113396](113325 call . r c"bounds"))
      if(113403 call _cond_test(113400 call == tmp[113396](113331 call . boundKind c"both")))
      {
        { scopeless
          (113335 return 0)
        }
      }
      {
        if(113409 call _cond_test(113406 call == tmp[113396](113342 call . boundKind c"low")))
        {
          { scopeless
            (113346 return(113351 call(113348 call . r c"hasPosNegUnitStride")))
          }
        }
        {
          if(113416 call _cond_test(113413 call == tmp[113396](113357 call . boundKind c"high")))
          {
            { scopeless
              (113361 return(113366 call(113363 call . r c"hasPosNegUnitStride")))
            }
          }
          {
            if(113423 call _cond_test(113420 call == tmp[113396](113372 call . boundKind c"neither")))
            {
              { scopeless
                (113376 return(113389 IfExpr (113378 call isFiniteIdxType(113380 call . r c"idxType")) then
                { scopeless
                  (113387 call(113384 call . r c"hasPosNegUnitStride"))
                } else
                { scopeless
                  1
                } ))
              }
            }
          }
        }
      }
    }
  }
  function _unknown[42].hasFirst[113429](arg _mt[113435]:_MT[201], arg this[113432] :
  range) : _unknown[42] "inline" "method"
  {
    (113439 call warnUnstableFirst this(fromHasFirst = 1))
    (113443 return(113445 call hasFirstForIter))
  }
  function _unknown[42].hasFirstForIter[113448](arg _mt[113454]:_MT[201], arg this[113451] :
  range) : _unknown[42] "inline" "method"
  {
    (113457 return(113483 IfExpr (113458 call ||(113460 call !(113463 call isAligned))(113465 call isEmpty)) then
    { scopeless
      0
    } else
    { scopeless(113480 IfExpr (113468 call isFiniteIdxType idxType) then
      { scopeless
        1
      } else
      { scopeless(113477 IfExpr (113472 call hasPositiveStride) then
        { scopeless
          (113474 call hasLowBound)
        } else
        { scopeless
          (113476 call hasHighBound)
        } )
      } )
    } ))
  }
  function _unknown[42].hasFirst[113488](arg _mt[113494]:_MT[201], arg this[113491] :
  range) param : _unknown[42] "method"
  {
    (113501 call warnUnstableFirst this(fromHasFirst = 1))
    (113505 return(113507 call hasFirstForIter))
  }
  where {
    (113497 call hasFirstLastAreParam this)
  }
  function _unknown[42].hasFirstForIter[113511](arg _mt[113517]:_MT[201], arg this[113514] :
  range) param : _unknown[42] "method"
  {
    if(113529 call _cond_test(113527 call isFiniteIdxType idxType))
    {
      { scopeless
        (113523 return 1)
      }
    }
    {
      unknown tmp[113578] "expr temp" "maybe param" "maybe type" "temp"
      (113580 'move' tmp[113578] bounds)
      if(113585 call _cond_test(113582 call == tmp[113578](113538 call . boundKind c"low")))
      {
        { scopeless
          (113542 return(113547 call(113544 call . strides c"isPositive")))
        }
      }
      {
        if(113591 call _cond_test(113588 call == tmp[113578](113553 call . boundKind c"high")))
        {
          { scopeless
            (113557 return(113562 call(113559 call . strides c"isNegative")))
          }
        }
        {
          if(113598 call _cond_test(113595 call == tmp[113578](113568 call . boundKind c"neither")))
          {
            { scopeless
              (113572 return 0)
            }
          }
        }
      }
    }
  }
  where {
    (113520 call hasFirstLastAreParam this)
  }
  function _unknown[42].first[113605](arg _mt[113611]:_MT[201], arg this[113608] :
  range) : _unknown[42] "inline" "method" "no parens"
  {
    (113615 call warnUnstableFirst this(fromHasFirst = 0))
    (113619 return(113621 call chpl_intToIdx(113625 call . this c"firstAsInt")))
  }
  function warnUnstableFirst[113630](arg r[113632]:_any[141](?), param arg fromHasFirst[113634]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    if(113652 call _cond_test(113639 call ||(113641 call ! chpl_warnUnstable)(113644 call !(113647 call isFiniteIdxType(113649 call . r c"idxType")))))
    {
      { scopeless
        (113637 return)
      }
    }
    if(113723 call _cond_test(113716 call !(113722 call(113719 call . r c"hasLowBound"))))
    {
      if(113711 call _cond_test(113710 call(113707 call .(113704 call . r c"strides") c"isPositive")))
      {
        if(113672 call _cond_test fromHasFirst)
        {
          { scopeless
            (113660 call compilerWarning "range.hasFirst() is unstable for a range over an enum or bool if it has a positive stride and no low bound")
          }
        }
        {
          { scopeless
            (113666 call compilerWarning "range.first is unstable for a range over an enum or bool if it has a positive stride and no low bound")
          }
        }
      }
      {
        { scopeless
          if(113699 call _cond_test(113698 call(113695 call . r c"hasPositiveStride")))
          {
            if(113688 call _cond_test fromHasFirst)
            {
              { scopeless
                (113680 call warning "range.hasFirst() is unstable for a range over an enum or bool if it has a positive stride and no low bound")
              }
            }
            {
              { scopeless
                (113684 call warning "range.first is unstable for a range over an enum or bool if it has a positive stride and no low bound")
              }
            }
          }
        }
      }
    }
    if(113793 call _cond_test(113786 call !(113792 call(113789 call . r c"hasHighBound"))))
    {
      if(113781 call _cond_test(113780 call(113777 call .(113774 call . r c"strides") c"isNegative")))
      {
        if(113742 call _cond_test fromHasFirst)
        {
          { scopeless
            (113730 call compilerWarning "range.hasFirst() is unstable for a range over an enum or bool if it has a negative stride and no high bound")
          }
        }
        {
          { scopeless
            (113736 call compilerWarning "range.first is unstable for a range over an enum or bool if it has a negative stride and no high bound")
          }
        }
      }
      {
        { scopeless
          if(113769 call _cond_test(113768 call(113765 call . r c"hasNegativeStride")))
          {
            if(113758 call _cond_test fromHasFirst)
            {
              { scopeless
                (113750 call warning "range.hasFirst() is unstable for a range over an enum or bool if it has a negative stride and no high bound")
              }
            }
            {
              { scopeless
                (113754 call warning "range.first is unstable for a range over an enum or bool if it has a negative stride and no high bound")
              }
            }
          }
        }
      }
    }
  }
  function _unknown[42].firstAsInt[113799](arg _mt[113805]:_MT[201], arg this[113802] :
  range) : _unknown[42] "inline" "method" "no parens"
  {
    (113808 return(113819 IfExpr (113810 call hasPositiveStride) then
    { scopeless
      (113812 call . this c"alignedLowAsInt")
    } else
    { scopeless
      (113816 call . this c"alignedHighAsInt")
    } ))
  }
  function _unknown[42].chpl_firstAsIntForIter[113824](arg _mt[113830]:_MT[201], arg this[113827] :
  range) : _unknown[42] "inline" "method" "no parens"
  {
    if(113940 call _cond_test(113930 call ==(113933 call . this c"bounds")(113937 call . boundKind c"both")))
    {
      (113834 return(113836 call . this c"firstAsInt"))
    }
    {
      if(113925 call _cond_test(113924 call(113921 call . strides c"isOne")))
      {
        (113841 return(113843 call chpl__idxToInt(113845 call lowBoundForIter this)))
      }
      {
        { scopeless
          if(113916 call _cond_test(113915 call(113912 call . strides c"isNegOne")))
          {
            (113848 return(113850 call chpl__idxToInt(113852 call highBoundForIter this)))
          }
          {
            if(113907 call _cond_test(113906 call hasPositiveStride))
            {
              if(113876 call _cond_test(113875 call hasLowBound))
              {
                (113857 return(113859 call helpAlignLow(113861 call chpl__idxToInt(113863 call lowBoundForIter this)) _alignment _stride))
              }
              {
                (113868 return(113870 call chpl__idxToInt(113872 call lowBoundForIter this)))
              }
            }
            {
              if(113901 call _cond_test(113900 call hasHighBound))
              {
                (113882 return(113884 call helpAlignHigh(113886 call chpl__idxToInt(113888 call highBoundForIter this)) _alignment _stride))
              }
              {
                (113893 return(113895 call chpl__idxToInt(113897 call highBoundForIter this)))
              }
            }
          }
        }
      }
    }
  }
  function _unknown[42].hasLast[113946](arg _mt[113952]:_MT[201], arg this[113949] :
  range) : _unknown[42] "inline" "method"
  {
    (113956 call warnUnstableLast this(fromHasLast = 1))
    (113960 return(113962 call hasLastForIter))
  }
  function _unknown[42].hasLastForIter[113965](arg _mt[113971]:_MT[201], arg this[113968] :
  range) : _unknown[42] "inline" "method"
  {
    (113974 return(114000 IfExpr (113975 call ||(113977 call !(113980 call isAligned))(113982 call isEmpty)) then
    { scopeless
      0
    } else
    { scopeless(113997 IfExpr (113985 call isFiniteIdxType idxType) then
      { scopeless
        1
      } else
      { scopeless(113994 IfExpr (113989 call hasPositiveStride) then
        { scopeless
          (113991 call hasHighBound)
        } else
        { scopeless
          (113993 call hasLowBound)
        } )
      } )
    } ))
  }
  function _unknown[42].hasLast[114005](arg _mt[114011]:_MT[201], arg this[114008] :
  range) param : _unknown[42] "method"
  {
    (114018 call warnUnstableLast this(fromHasLast = 1))
    (114022 return(114024 call hasLastForIter))
  }
  where {
    (114014 call hasFirstLastAreParam this)
  }
  function _unknown[42].hasLastForIter[114028](arg _mt[114034]:_MT[201], arg this[114031] :
  range) param : _unknown[42] "method"
  {
    if(114046 call _cond_test(114044 call isFiniteIdxType idxType))
    {
      { scopeless
        (114040 return 1)
      }
    }
    {
      unknown tmp[114095] "expr temp" "maybe param" "maybe type" "temp"
      (114097 'move' tmp[114095] bounds)
      if(114102 call _cond_test(114099 call == tmp[114095](114055 call . boundKind c"low")))
      {
        { scopeless
          (114059 return(114064 call(114061 call . strides c"isNegative")))
        }
      }
      {
        if(114108 call _cond_test(114105 call == tmp[114095](114070 call . boundKind c"high")))
        {
          { scopeless
            (114074 return(114079 call(114076 call . strides c"isPositive")))
          }
        }
        {
          if(114115 call _cond_test(114112 call == tmp[114095](114085 call . boundKind c"neither")))
          {
            { scopeless
              (114089 return 0)
            }
          }
        }
      }
    }
  }
  where {
    (114037 call hasFirstLastAreParam this)
  }
  function _unknown[42].last[114122](arg _mt[114128]:_MT[201], arg this[114125] :
  range) : _unknown[42] "inline" "method" "no parens"
  {
    (114132 call warnUnstableLast this(fromHasLast = 0))
    (114136 return(114138 call chpl_intToIdx(114142 call . this c"lastAsInt")))
  }
  function warnUnstableLast[114147](arg r[114149]:_any[141](?), param arg fromHasLast[114151]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    if(114169 call _cond_test(114156 call ||(114158 call ! chpl_warnUnstable)(114161 call !(114164 call isFiniteIdxType(114166 call . r c"idxType")))))
    {
      { scopeless
        (114154 return)
      }
    }
    if(114240 call _cond_test(114233 call !(114239 call(114236 call . r c"hasLowBound"))))
    {
      if(114227 call _cond_test(114226 call(114223 call .(114220 call . r c"strides") c"isNegative")))
      {
        { scopeless
          if(114188 call _cond_test fromHasLast)
          {
            { scopeless
              (114176 call compilerWarning "range.hasLast() is unstable for a range over an enum or bool if it has a negative stride and no low bound")
            }
          }
          {
            { scopeless
              (114182 call compilerWarning "range.last is unstable for a range over an enum or bool if it has a negative stride and no low bound")
            }
          }
        }
      }
      {
        { scopeless
          if(114214 call _cond_test(114213 call(114210 call . r c"hasNegativeStride")))
          {
            { scopeless
              if(114203 call _cond_test fromHasLast)
              {
                { scopeless
                  (114195 call warning "range.hasLast() is unstable for a range over an enum or bool if it has a negative stride and no low bound")
                }
              }
              {
                { scopeless
                  (114199 call warning "range.last is unstable for a range over an enum or bool if it has a negative stride and no low bound")
                }
              }
            }
          }
        }
      }
    }
    if(114310 call _cond_test(114303 call !(114309 call(114306 call . r c"hasHighBound"))))
    {
      if(114297 call _cond_test(114296 call(114293 call .(114290 call . r c"strides") c"isPositive")))
      {
        { scopeless
          if(114258 call _cond_test fromHasLast)
          {
            { scopeless
              (114246 call compilerWarning "range.hasLast() is unstable for a range over an enum or bool if it has a positive stride and no high bound")
            }
          }
          {
            { scopeless
              (114252 call compilerWarning "range.last is unstable for a range over an enum or bool if it has a positive stride and no high bound")
            }
          }
        }
      }
      {
        { scopeless
          if(114284 call _cond_test(114283 call(114280 call . r c"hasPositiveStride")))
          {
            { scopeless
              if(114273 call _cond_test fromHasLast)
              {
                { scopeless
                  (114265 call warning "range.hasLast() is unstable for a range over an enum or bool if it has a positive stride and no high bound")
                }
              }
              {
                { scopeless
                  (114269 call warning "range.last is unstable for a range over an enum or bool if it has a positive stride and no high bound")
                }
              }
            }
          }
        }
      }
    }
  }
  function _unknown[42].lastAsInt[114316](arg _mt[114322]:_MT[201], arg this[114319] :
  range) : _unknown[42] "inline" "method" "no parens"
  {
    (114325 return(114336 IfExpr (114327 call hasPositiveStride) then
    { scopeless
      (114329 call . this c"alignedHighAsInt")
    } else
    { scopeless
      (114333 call . this c"alignedLowAsInt")
    } ))
  }
  function _unknown[42].chpl_lastAsIntForIter[114341](arg _mt[114347]:_MT[201], arg this[114344] :
  range) : _unknown[42] "inline" "method" "no parens"
  {
    if(114426 call _cond_test(114419 call == bounds(114423 call . boundKind c"both")))
    {
      (114351 return(114353 call . this c"lastAsInt"))
    }
    {
      if(114414 call _cond_test(114413 call(114410 call . strides c"isOne")))
      {
        (114358 return(114360 call chpl__idxToInt(114362 call highBoundForIter this)))
      }
      {
        { scopeless
          if(114404 call _cond_test(114403 call(114400 call . strides c"isNegOne")))
          {
            (114365 return(114367 call chpl__idxToInt(114369 call lowBoundForIter this)))
          }
          {
            { scopeless
              if(114395 call _cond_test(114394 call hasPositiveStride))
              {
                (114372 return(114374 call helpAlignHigh(114376 call chpl__idxToInt(114378 call highBoundForIter this)) _alignment _stride))
              }
              {
                (114383 return(114385 call helpAlignLow(114387 call chpl__idxToInt(114389 call lowBoundForIter this)) _alignment _stride))
              }
            }
          }
        }
      }
    }
  }
  function chpl_idxTypeSizeChange[114432](arg t[114434]:_any[141](?)) param : _unknown[42]
  {
    (114437 return(114438 call &&(114441 call isIntegralType t)(114443 call != t int[10])))
  }
  function _unknown[42].contains[114449](arg _mt[114459]:_MT[201], arg this[114452] :
  range, arg ind[114456] :
  idxType) : _unknown[42] "inline" "method"
  {
    if(114478 call _cond_test(114476 call chpl__singleValIdxType idxType))
    {
      if(114470 call _cond_test(114466 call > _low _high))
      {
        { scopeless
          (114463 return 0)
        }
      }
    }
    if(114492 call _cond_test(114485 call !(114491 call(114488 call . this c"isAligned"))))
    {
      { scopeless
        (114482 return 0)
      }
    }
    { scopeless
      const i[114498] "const"(114500 call chpl__idxToInt ind)
      (114503 'end of statement')
    }
    if(114519 call _cond_test(114518 call hasHighBound))
    {
      if(114512 call _cond_test(114508 call > i _high))
      {
        { scopeless
          (114505 return 0)
        }
      }
    }
    if(114538 call _cond_test(114537 call hasLowBound))
    {
      if(114531 call _cond_test(114527 call < i _low))
      {
        { scopeless
          (114524 return 0)
        }
      }
    }
    if(114562 call _cond_test(114558 call !(114561 call hasPosNegUnitStride)))
    {
      if(114553 call _cond_test(114546 call !=(114549 call chpl__mod i _stride) _alignment))
      {
        { scopeless
          (114543 return 0)
        }
      }
    }
    (114566 return 1)
  }
  function _unknown[42].contains[114570](arg _mt[114582]:_MT[201], arg this[114573] :
  range, arg other[114579] :
  (114577 call range ?[227])) : _unknown[42] "inline" "method"
  {
    if(114607 call _cond_test(114605 call chpl__singleValIdxType idxType))
    {
      if(114599 call _cond_test(114595 call > _low _high))
      {
        { scopeless
          (114586 return(114587 call ==(114590 call . other c"size") 0))
        }
      }
    }
    if(114630 call _cond_test(114614 call ||(114616 call !(114622 call(114619 call . this c"isAligned")))(114623 call !(114629 call(114626 call . other c"isAligned")))))
    {
      { scopeless
        (114611 return 0)
      }
    }
    if(114679 call _cond_test(114658 call &&(114660 call ==(114663 call . this c"bounds")(114667 call . boundKind c"both"))(114670 call ==(114676 call(114673 call . this c"sizeAs") uint[86]) 0)))
    {
      { scopeless
        (114635 return(114636 call &&(114638 call ==(114641 call . other c"bounds")(114645 call . boundKind c"both"))(114648 call ==(114654 call(114651 call . other c"sizeAs") uint[86]) 0)))
      }
    }
    { scopeless
      unknown slice[114685](114687 call this other)
      (114690 'end of statement')
    }
    function adjustedSlice[114691]() : _unknown[42] "no parens"
    {
      (114694 return(114707 IfExpr (114699 call(114696 call . this c"hasPositiveStride")) then
      { scopeless
        slice
      } else
      { scopeless
        (114701 call chpl_by slice(114704 call - 1))
      } ))
    }
    (114712 return(114713 call == other adjustedSlice))
  }
  function ==[114719](arg r1[114724] :
  (114722 call range ?[227]), arg r2[114730] :
  (114728 call range ?[227])) param : _unknown[42] "operator"
  {
    (114764 return 0)
  }
  where {
    (114733 call &&(114735 call !=(114738 call . r1 c"bounds")(114742 call . r2 c"bounds"))(114745 call ||(114747 call !(114750 call isFiniteIdxType(114752 call . r1 c"idxType")))(114755 call !(114758 call isFiniteIdxType(114760 call . r2 c"idxType")))))
  }
  function ==[114769](arg r1[114774] :
  (114772 call range ?[227]), arg r2[114780] :
  (114778 call range ?[227])) : _unknown[42] "operator" "@unstable"
  {
    { scopeless
      const boundedr1[114812] "const"(114855 IfExpr (114813 call ==(114816 call . r1 c"bounds")(114820 call . boundKind c"both")) then
      { scopeless
        r1
      } else
      { scopeless
        (114824 'new'(114826 call range(114828 call . r1 c"idxType")(114832 call . boundKind c"both")(114836 call . r1 c"strides")(114840 call . r1 c"_low")(114844 call . r1 c"_high")(114848 call . r1 c"_stride")(114852 call . r1 c"_alignment")))
      } )
      (114859 'end of statement')
    }
    { scopeless
      const boundedr2[114861] "const"(114904 IfExpr (114862 call ==(114865 call . r2 c"bounds")(114869 call . boundKind c"both")) then
      { scopeless
        r2
      } else
      { scopeless
        (114873 'new'(114875 call range(114877 call . r2 c"idxType")(114881 call . boundKind c"both")(114885 call . r2 c"strides")(114889 call . r2 c"_low")(114893 call . r2 c"_high")(114897 call . r2 c"_stride")(114901 call . r2 c"_alignment")))
      } )
      (114908 'end of statement')
    }
    (114909 return(114910 call == boundedr1 boundedr2))
  }
  where {
    (114784 call &&(114786 call &&(114788 call !=(114791 call . r1 c"bounds")(114795 call . r2 c"bounds"))(114799 call isFiniteIdxType(114801 call . r1 c"idxType")))(114805 call isFiniteIdxType(114807 call . r2 c"idxType")))
  }
  { scopeless type
    bool
  }
  function ==[114918](arg r1[114923] :
  (114921 call range ?[227]), arg r2[114929] :
  (114927 call range ?[227])) : _unknown[42] "operator"
  {
    if(114959 call _cond_test(114947 call !=(114953 call(114950 call . r1 c"isAligned"))(114958 call(114955 call . r2 c"isAligned"))))
    {
      { scopeless
        (114944 return 0)
      }
    }
    if(114977 call _cond_test(114970 call !(114976 call(114973 call . r1 c"isAligned"))))
    {
      { scopeless
        (114964 return(114966 call chpl_ident r1 r2))
      }
    }
    if(115164 call _cond_test(115154 call ==(115157 call . r1 c"bounds")(115161 call . boundKind c"both")))
    {
      { scopeless
        { scopeless
          const len[114994] "const"(114999 call(114996 call . r1 c"sizeAs") uint[86])
        }
        { scopeless
          const l2[114985] "const"(114990 call(114987 call . r2 c"sizeAs") uint[86])
        }
        (115002 'end of statement')
      }
      if(115010 call _cond_test(115006 call != len l2))
      {
        { scopeless
          (115003 return 0)
        }
      }
      if(115022 call _cond_test(115018 call == len 0))
      {
        { scopeless
          (115015 return 1)
        }
      }
      if(115040 call _cond_test(115030 call !=(115033 call . r1 c"first")(115037 call . r2 c"first")))
      {
        { scopeless
          (115027 return 0)
        }
      }
      if(115052 call _cond_test(115048 call == len 1))
      {
        { scopeless
          (115045 return 1)
        }
      }
      if(115070 call _cond_test(115060 call !=(115063 call . r1 c"stride")(115067 call . r2 c"stride")))
      {
        { scopeless
          (115057 return 0)
        }
      }
      (115075 return 1)
    }
    {
      if(115091 call _cond_test(115081 call !=(115084 call . r1 c"stride")(115088 call . r2 c"stride")))
      {
        { scopeless
          (115078 return 0)
        }
      }
      if(115119 call _cond_test(115118 call(115115 call . r1 c"hasLowBound")))
      {
        { scopeless
          if(115109 call _cond_test(115099 call !=(115102 call . r1 c"low")(115106 call . r2 c"low")))
          {
            { scopeless
              (115096 return 0)
            }
          }
        }
      }
      if(115147 call _cond_test(115146 call(115143 call . r1 c"hasHighBound")))
      {
        { scopeless
          if(115137 call _cond_test(115127 call !=(115130 call . r1 c"high")(115134 call . r2 c"high")))
          {
            { scopeless
              (115124 return 0)
            }
          }
        }
      }
      (115152 return 1)
    }
  }
  where {
    (114933 call ==(114936 call . r1 c"bounds")(114940 call . r2 c"bounds"))
  }
  { scopeless type
    bool
  }
  function !=[115172](arg r1[115177] :
  (115175 call range ?[227]), arg r2[115183] :
  (115181 call range ?[227])) : _unknown[42] "operator"
  {
    (115187 return(115188 call !(115190 call == r1 r2)))
  }
  function !=[115196](arg r1[115201] :
  (115199 call range ?[227]), arg r2[115207] :
  (115205 call range ?[227])) : _unknown[42] "operator" "@unstable"
  {
    (115238 return(115239 call !(115241 call == r1 r2)))
  }
  where {
    (115211 call &&(115213 call &&(115215 call !=(115218 call . r1 c"bounds")(115222 call . r2 c"bounds"))(115226 call isFiniteIdxType(115228 call . r1 c"idxType")))(115232 call isFiniteIdxType(115234 call . r2 c"idxType")))
  }
  { scopeless type
    bool
  }
  function !=[115249](arg r1[115254] :
  (115252 call range ?[227]), arg r2[115260] :
  (115258 call range ?[227])) param : _unknown[42] "operator"
  {
    (115294 return 1)
  }
  where {
    (115263 call &&(115265 call !=(115268 call . r1 c"bounds")(115272 call . r2 c"bounds"))(115275 call ||(115277 call !(115280 call isFiniteIdxType(115282 call . r1 c"idxType")))(115285 call !(115288 call isFiniteIdxType(115290 call . r2 c"idxType")))))
  }
  function <[115299](arg r1[115304] :
  (115302 call range ?[227]), arg r2[115310] :
  (115308 call range ?[227])) : _unknown[42] "operator"
  {
    (115337 call compilerError "Unbounded ranges don't support comparisons other than '==' and '!='")
  }
  where {
    (115313 call ||(115315 call !=(115318 call . r1 c"bounds")(115322 call . boundKind c"both"))(115325 call !=(115328 call . r2 c"bounds")(115332 call . boundKind c"both")))
  }
  function >[115344](arg r1[115349] :
  (115347 call range ?[227]), arg r2[115355] :
  (115353 call range ?[227])) : _unknown[42] "operator"
  {
    (115382 call compilerError "Unbounded ranges don't support comparisons other than '==' and '!='")
  }
  where {
    (115358 call ||(115360 call !=(115363 call . r1 c"bounds")(115367 call . boundKind c"both"))(115370 call !=(115373 call . r2 c"bounds")(115377 call . boundKind c"both")))
  }
  function <=[115387](arg r1[115392] :
  (115390 call range ?[227]), arg r2[115398] :
  (115396 call range ?[227])) : _unknown[42] "operator"
  {
    (115425 call compilerError "Unbounded ranges don't support comparisons other than '==' and '!='")
  }
  where {
    (115401 call ||(115403 call !=(115406 call . r1 c"bounds")(115410 call . boundKind c"both"))(115413 call !=(115416 call . r2 c"bounds")(115420 call . boundKind c"both")))
  }
  function >=[115430](arg r1[115435] :
  (115433 call range ?[227]), arg r2[115441] :
  (115439 call range ?[227])) : _unknown[42] "operator"
  {
    (115468 call compilerError "Unbounded ranges don't support comparisons other than '==' and '!='")
  }
  where {
    (115444 call ||(115446 call !=(115449 call . r1 c"bounds")(115453 call . boundKind c"both"))(115456 call !=(115459 call . r2 c"bounds")(115463 call . boundKind c"both")))
  }
  function chpl_ident[115473](arg r1[115478] :
  (115476 call range ?[227]), arg r2[115484] :
  (115482 call range ?[227])) : _unknown[42]
  {
    if(115535 call _cond_test(115525 call !=(115528 call . r1 c"_low")(115532 call . r2 c"_low")))
    {
      { scopeless
        (115522 return 0)
      }
    }
    if(115553 call _cond_test(115543 call !=(115546 call . r1 c"_high")(115550 call . r2 c"_high")))
    {
      { scopeless
        (115540 return 0)
      }
    }
    if(115571 call _cond_test(115561 call !=(115564 call . r1 c"_stride")(115568 call . r2 c"_stride")))
    {
      { scopeless
        (115558 return 0)
      }
    }
    if(115589 call _cond_test(115579 call !=(115582 call . r1 c"_alignment")(115586 call . r2 c"_alignment")))
    {
      { scopeless
        (115576 return 0)
      }
    }
    (115594 return 1)
  }
  where {
    (115487 call &&(115489 call &&(115491 call ==(115494 call . r1 c"idxType")(115498 call . r2 c"idxType"))(115501 call ==(115504 call . r1 c"bounds")(115508 call . r2 c"bounds")))(115511 call ==(115514 call . r1 c"strides")(115518 call . r2 c"strides")))
  }
  function chpl_ident[115599](arg r1[115604] :
  (115602 call range ?[227]), arg r2[115610] :
  (115608 call range ?[227])) param : _unknown[42]
  {
    (115614 return 0)
  }
  function _unknown[42].boundingBox[115618](arg _mt[115624]:_MT[201], arg this[115621] :
  range) : _unknown[42] "method"
  {
    (115628 call compilerAssert(115629 call ==(115632 call . this c"bounds")(115636 call . boundKind c"both")))
    if(115650 call _cond_test(115649 call(115646 call .(115643 call . this c"strides") c"isOne")))
    {
      { scopeless
        (115639 return this)
      }
    }
    (115655 return(115656 'new'(115658 call range(115660 call . this c"idxType")(115664 call . this c"bounds")(115668 call . strideKind c"one")(115672 call . this c"alignedLowAsInt")(115676 call . this c"alignedHighAsInt") none none)))
  }
  function _unknown[42].tryCast[115683](arg _mt[115695]:_MT[201], arg this[115686] :
  range, arg t[115692] :
  (115690 call range ?[227])) : _unknown[42] "method" "no where doc"
  {
    { scopeless
      const r[115703] "const" this
      (115706 'end of statement')
    }
    (115708 call checkBounds t r)
    (115712 call checkEnumBoolIdx t r)
    { scopeless
      unknown useR[115716] "param"(115717 call !(115719 call &&(115721 call ==(115724 call . t c"idxType") int[10])(115729 call isBCPindex(115731 call . r c"idxType"))))
      (115735 'end of statement')
    }
    { scopeless
      unknown result[115737](115769 IfExpr  useR then
      { scopeless
        r
      } else
      { scopeless
        (115741 'new'(115743 call range int[10](115746 call . r c"bounds")(115750 call . r c"strides")(115754 call . r c"_low")(115758 call . r c"_high")(115762 call . r c"_stride")(115766 call . r c"_alignment")))
      } ) t
      (115773 'end of statement')
    }
    (115774 return result)
  }
  where {
    (115698 call chpl_tryCastIsSafe this t)
  }
  function _unknown[42].tryCast[115779](arg _mt[115791]:_MT[201], arg this[115782] :
  range, arg t[115788] :
  (115786 call range ?[227])) : _unknown[42] throws "method"
  {
    { scopeless
      const r[115801] "const" this
      (115804 'end of statement')
    }
    (115806 call checkBounds t r)
    (115810 call checkEnumBoolIdx t r)
    { scopeless
      unknown tmp[115814] t
      (115817 'end of statement')
    }
    { scopeless
      { scopeless
        unknown srcType[115834] "type variable"(115836 call . r c"idxType")
      }
      { scopeless
        unknown dstType[115827] "type variable"(115829 call . t c"idxType")
      }
      { scopeless
        unknown dstIntType[115820] "type variable"(115822 call . tmp c"chpl_integralIdxType")
      }
      (115840 'end of statement')
    }
    (115841 call =(115844 call . tmp c"_low")(115870 IfExpr (115847 call !(115853 call(115850 call . r c"hasLowBound"))) then
    { scopeless
      (115854 call :(115857 call . r c"_low") dstIntType)
    } else
    { scopeless
      (115862 call chpl__idxToInt(115864 call chpl_throwingCast dstType(115867 call . r c"lowBound")))
    } ))
    (115873 call =(115876 call . tmp c"_high")(115902 IfExpr (115879 call !(115885 call(115882 call . r c"hasHighBound"))) then
    { scopeless
      (115886 call :(115889 call . r c"_high") dstIntType)
    } else
    { scopeless
      (115894 call chpl__idxToInt(115896 call chpl_throwingCast dstType(115899 call . r c"highBound")))
    } ))
    { scopeless
      unknown error[115906](115913 call(115910 call . r c"chpl_checkStrides") t)
      (115916 'end of statement')
    }
    if(115924 call _cond_test(115920 call != error nil[32]))
    {
      { scopeless
        (115917 'throw' error)
      }
    }
    if(115979 call _cond_test(115972 call !(115978 call(115975 call . tmp c"hasParamStrideAltvalAld"))))
    {
      (115930 call =(115933 call . tmp c"_stride")(115937 call chpl_throwingCast(115939 call . tmp c"strType")(115943 call . r c"stride")))
      (115946 call =(115949 call . tmp c"_alignment")(115969 IfExpr (115953 call isNothingValue(115955 call . r c"_alignment")) then
      { scopeless
        0
      } else
      { scopeless
        (115959 call :(115962 call . r c"_alignment")(115966 call . tmp c"strType"))
      } ))
    }
    (115983 return tmp)
  }
  where {
    (115793 call !(115796 call chpl_tryCastIsSafe this t))
  }
  function :[115988](arg r[115993] :
  (115991 call range ?[227]), arg t[115999] :
  (115997 call range ?[227])) : _unknown[42] "operator"
  {
    (116008 call checkBounds t r)
    (116012 call checkEnumIdx t r)
    { scopeless
      unknown tmp[116016](116017 'new'(116019 call range(116021 call . t c"idxType")(116025 call . t c"bounds")(116029 call . t c"strides") 1))
      (116034 'end of statement')
    }
    { scopeless
      { scopeless
        unknown srcType[116051] "type variable"(116053 call . r c"idxType")
      }
      { scopeless
        unknown dstType[116044] "type variable"(116046 call . t c"idxType")
      }
      { scopeless
        unknown dstIntType[116037] "type variable"(116039 call . tmp c"chpl_integralIdxType")
      }
      (116057 'end of statement')
    }
    (116058 call =(116061 call . tmp c"_low")(116064 call :(116084 IfExpr (116070 call(116067 call . r c"hasLowBound")) then
    { scopeless
      (116072 call chpl__idxToInt(116073 call :(116076 call . r c"lowBound") dstType))
    } else
    { scopeless
      (116081 call . r c"_low")
    } )(116088 call . tmp c"chpl_integralIdxType")))
    (116091 call =(116094 call . tmp c"_high")(116097 call :(116117 IfExpr (116103 call(116100 call . r c"hasHighBound")) then
    { scopeless
      (116105 call chpl__idxToInt(116106 call :(116109 call . r c"highBound") dstType))
    } else
    { scopeless
      (116114 call . r c"_high")
    } )(116121 call . tmp c"chpl_integralIdxType")))
    if(116150 call _cond_test boundsChecking)
    {
      { scopeless
        if(116144 call _cond_test(116143 'if var' const error[116141] "const"(116139 call(116136 call . r c"chpl_checkStrides") t)))
        {
          { scopeless
            (116128 call(116125 call . HaltWrappers c"boundsCheckHalt")(116133 call(116130 call . error c"message")))
          }
        }
      }
    }
    if(116207 call _cond_test(116200 call !(116206 call(116203 call . tmp c"hasParamStrideAltvalAld"))))
    {
      (116156 call =(116159 call . tmp c"_stride")(116169 call(116166 call .(116163 call . r c"stride") c"safeCast")(116171 call . tmp c"strType")))
      (116174 call =(116177 call . tmp c"_alignment")(116197 IfExpr (116181 call isNothingValue(116183 call . r c"_alignment")) then
      { scopeless
        0
      } else
      { scopeless
        (116187 call :(116190 call . r c"_alignment")(116194 call . tmp c"strType"))
      } ))
    }
    (116211 return tmp)
  }
  where {
    (116003 call chpl_castIsSafe r t)
  }
  function :[116216](arg r[116221] :
  (116219 call range ?[227]), arg t[116227] :
  (116225 call range ?[227])) : _unknown[42] throws "operator"
  {
    (116238 call checkBounds t r)
    (116242 call checkEnumIdx t r)
    { scopeless
      unknown tmp[116246](116247 'new'(116249 call range(116251 call . t c"idxType")(116255 call . t c"bounds")(116259 call . t c"strides") 1))
      (116264 'end of statement')
    }
    { scopeless
      { scopeless
        unknown srcType[116281] "type variable"(116283 call . r c"idxType")
      }
      { scopeless
        unknown dstType[116274] "type variable"(116276 call . t c"idxType")
      }
      { scopeless
        unknown dstIntType[116267] "type variable"(116269 call . tmp c"chpl_integralIdxType")
      }
      (116287 'end of statement')
    }
    (116288 call =(116291 call . tmp c"_low")(116294 call :(116314 IfExpr (116300 call(116297 call . r c"hasLowBound")) then
    { scopeless
      (116302 call chpl__idxToInt(116303 call :(116306 call . r c"lowBound") dstType))
    } else
    { scopeless
      (116311 call . r c"_low")
    } )(116318 call . tmp c"chpl_integralIdxType")))
    (116321 call =(116324 call . tmp c"_high")(116327 call :(116347 IfExpr (116333 call(116330 call . r c"hasHighBound")) then
    { scopeless
      (116335 call chpl__idxToInt(116336 call :(116339 call . r c"highBound") dstType))
    } else
    { scopeless
      (116344 call . r c"_high")
    } )(116351 call . tmp c"chpl_integralIdxType")))
    if(116380 call _cond_test boundsChecking)
    {
      { scopeless
        if(116374 call _cond_test(116373 'if var' const error[116371] "const"(116369 call(116366 call . r c"chpl_checkStrides") t)))
        {
          { scopeless
            (116358 call(116355 call . HaltWrappers c"boundsCheckHalt")(116363 call(116360 call . error c"message")))
          }
        }
      }
    }
    if(116437 call _cond_test(116430 call !(116436 call(116433 call . tmp c"hasParamStrideAltvalAld"))))
    {
      (116386 call =(116389 call . tmp c"_stride")(116399 call(116396 call .(116393 call . r c"stride") c"safeCast")(116401 call . tmp c"strType")))
      (116404 call =(116407 call . tmp c"_alignment")(116427 IfExpr (116411 call isNothingValue(116413 call . r c"_alignment")) then
      { scopeless
        0
      } else
      { scopeless
        (116417 call :(116420 call . r c"_alignment")(116424 call . tmp c"strType"))
      } ))
    }
    (116441 return tmp)
  }
  where {
    (116230 call !(116233 call chpl_castIsSafe r t))
  }
  function chpl_throwingCast[116446](arg toType[116448]:_any[141](?), arg from[116450]:_any[141](?)) : _unknown[42] throws "inline"
  {
    unknown fromType[116454] "type variable"(116456 'typeof' from)
    if(116491 call _cond_test(116483 call &&(116486 call isIntegral fromType)(116489 call isIntegral toType)))
    {
      { scopeless
        unknown error[116460](116467 call(116464 call . from c"chpl_checkValue") toType)
        (116470 'end of statement')
      }
      if(116478 call _cond_test(116474 call != error nil[32]))
      {
        { scopeless
          (116471 'throw' error)
        }
      }
    }
    if(116523 call _cond_test(116509 call &&(116511 call &&(116514 call isEnum fromType)(116517 call isIntegral toType))(116519 call != toType int[10])))
    {
      { scopeless
        const e2i[116497] "const"(116498 call : from int[10])
        (116503 'end of statement')
      }
      (116504 return(116506 call chpl_throwingCast toType e2i))
    }
    (116527 return(116528 call : from toType))
  }
  function chpl_throwingCast[116534](arg toType[116536]:_any[141](?), arg from[116538]:_any[141](?)) : _unknown[42] "inline"
  {
    (116546 return(116547 call : from toType))
  }
  where {
    (116541 call chpl_idxCastIsSafe toType(116544 'typeof' from))
  }
  function checkBounds[116554](arg toType[116556]:_any[141](?), arg from[116558]:_any[141](?)) : _unknown[42] "private"
  {
    if(116594 call _cond_test(116584 call !=(116587 call . toType c"bounds")(116591 call . from c"bounds")))
    {
      { scopeless
        (116562 call compilerError "cannot cast range from boundKind."(116566 call :(116569 call . from c"bounds") string[244]) " to boundKind."(116576 call :(116579 call . toType c"bounds") string[244]))
      }
    }
  }
  function checkEnumBoolIdx[116601](arg toType[116603]:_any[141](?), arg from[116605]:_any[141](?)) : _unknown[42] "private"
  {
    (116609 call checkEnumIdx toType from)
    if(116634 call _cond_test(116618 call &&(116620 call ==(116623 call . toType c"idxType") bool)(116627 call !=(116630 call . from c"idxType") bool)))
    {
      { scopeless
        (116613 call compilerError "'tryCast' to a range type with idxType=bool is not currently supported")
      }
    }
  }
  function checkEnumIdx[116641](arg toType[116643]:_any[141](?), arg from[116645]:_any[141](?)) : _unknown[42] "private"
  {
    { scopeless
      { scopeless
        unknown srcType[116657] "type variable"(116659 call . from c"idxType")
      }
      { scopeless
        unknown dstType[116650] "type variable"(116652 call . toType c"idxType")
      }
      (116663 'end of statement')
    }
    if(116687 call _cond_test(116670 call && chpl_warnUnstable(116673 call &&(116675 call ||(116678 call isEnumType srcType)(116681 call isEnumType dstType))(116683 call != srcType dstType))))
    {
      { scopeless
        (116665 call compilerWarning "Casts between ranges involving 'enum' indices are currently unstable (see issue #22406); consider performing the conversion ma)
      }
    }
  }
  function _unknown[42].chpl_checkStrides[116694](arg _mt[116702]:_MT[201], arg this[116697] :
  range, arg toType[116700]:_any[141](?)) : _unknown[42] "method"
  {
    if(116742 call _cond_test(116733 call chpl_assignStrideIsUnsafe(116735 call . toType c"strides")(116739 call . this c"strides")))
    {
      { scopeless
        (116710 call compilerError "cannot cast range from strideKind."(116714 call :(116717 call . this c"strides") string[244]) " to strideKind."(116724 call :(116727 call . toType c"strides") string[244]))
      }
    }
    { scopeless
      unknown needThrow[116748] 0
      (116751 'end of statement')
    }
    {
      unknown tmp[116844] "expr temp" "maybe param" "maybe type" "temp"
      (116846 'move' tmp[116844](116753 call . toType c"strides"))
      if(116851 call _cond_test(116848 call == tmp[116844](116759 call . strideKind c"one")))
      {
        { scopeless
          (116763 call = needThrow(116766 call !=(116769 call . this c"stride") 1))
        }
      }
      {
        if(116857 call _cond_test(116854 call == tmp[116844](116778 call . strideKind c"negOne")))
        {
          { scopeless
            (116782 call = needThrow(116785 call !=(116788 call . this c"stride")(116791 call - 1)))
          }
        }
        {
          if(116864 call _cond_test(116861 call == tmp[116844](116799 call . strideKind c"positive")))
          {
            { scopeless
              (116803 call = needThrow(116806 call <(116809 call . this c"stride") 0))
            }
          }
          {
            if(116871 call _cond_test(116868 call == tmp[116844](116818 call . strideKind c"negative")))
            {
              { scopeless
                (116822 call = needThrow(116825 call >(116828 call . this c"stride") 0))
              }
            }
            {
              if(116878 call _cond_test(116875 call == tmp[116844](116837 call . strideKind c"any")))
              {
              }
            }
          }
        }
      }
    }
    if(116915 call _cond_test needThrow)
    {
      { scopeless
        (116882 return(116883 'new'(116885 call IllegalArgumentError(116886 call +(116888 call +(116890 call + "bad cast from stride "(116895 call :(116898 call . this c"stride") string[244])) " to strideKind.")(116903 call :(116906 call . toType c"strides") string[244])))))
      }
    }
    {
      { scopeless
        (116911 return nil[32])
      }
    }
  }
  { scopeless type
    (116705 call _owned(116707 'to nilable class from type' IllegalArgumentError))
  }
  function chpl_tryCastIsSafe[116924](arg r[116929] :
  (116927 call range ?[227]), arg t[116935] :
  (116933 call range ?[227])) param : _unknown[42]
  {
    (116939 return(116940 call &&(116943 call chpl_assignStrideIsSafe(116945 call . t c"strides")(116949 call . r c"strides"))(116953 call chpl_idxCastIsSafe(to =(116955 call . t c"idxType"))(from =(116960 call . r c"idxType")))))
  }
  function chpl_castIsSafe[116966](arg r[116971] :
  (116969 call range ?[227]), arg t[116977] :
  (116975 call range ?[227])) param : _unknown[42]
  {
    (116981 return(116982 call !(116985 call chpl_idxCastThrows(to =(116987 call . t c"idxType"))(from =(116992 call . r c"idxType")))))
  }
  function chpl_idxCastIsSafe[116998](arg to[117000]:_any[141](?), arg from[117002]:_any[141](?)) param : _unknown[42]
  {
    (117005 return(117006 call ||(117008 call &&(117010 call !(117012 call &&(117015 call isUint to)(117018 call isInt from)))(117021 call assignmentIsLegal to from))(117024 call &&(117026 call == to int[10])(117031 call isBCPindex from))))
  }
  function chpl_idxCastThrows[117035](arg to[117037]:_any[141](?), arg from[117039]:_any[141](?)) param : _unknown[42]
  {
    (117042 return(117043 call &&(117045 call != to from)(117049 call ||(117052 call isEnumType to)(117055 call isEnumType from))))
  }
  function isBCPindex[117059](arg t[117061]:_any[141](?)) param : _unknown[42] "private"
  {
    (117064 return(117065 call ||(117067 call == t byteIndex)(117071 call == t codepointIndex)))
  }
  function _unknown[42].chpl_boundsCheck[117077](arg _mt[117094]:_MT[201], arg this[117080] :
  range, arg other[117091] :
  (117084 call range unknown e[117085] unknown b[117087] unknown s[117089])) : _unknown[42] "inline" "method"
  {
    if(117120 call _cond_test(117118 call chpl__singleValIdxType idxType))
    {
      if(117112 call _cond_test(117108 call > _low _high))
      {
        { scopeless
          (117105 return 0)
        }
      }
    }
    if(117134 call _cond_test(117127 call !(117133 call(117130 call . this c"isAligned"))))
    {
      { scopeless
        (117124 return 0)
      }
    }
    (117139 return 1)
  }
  where {
    (117096 call == b(117100 call . boundKind c"neither"))
  }
  function _unknown[42].chpl_boundsCheck[117144](arg _mt[117161]:_MT[201], arg this[117147] :
  range, arg other[117158] :
  (117151 call range unknown e[117152] unknown b[117154] unknown s[117156])) : _unknown[42] "inline" "method"
  {
    if(117174 call _cond_test(117167 call !(117173 call(117170 call . this c"isAligned"))))
    {
      { scopeless
        (117164 return 0)
      }
    }
    { scopeless
      unknown boundedOther[117180](117335 IfExpr (117185 call(117182 call . other c"isAligned")) then
      { scopeless
        (117186 'new'(117188 call range idxType(117191 call . boundKind c"both")(117195 call . other c"strides")(117208 IfExpr (117202 call(117199 call . other c"hasLowBound")) then
        { scopeless
          (117204 call . other c"_low")
        } else
        { scopeless
          _low
        } )(117221 IfExpr (117215 call(117212 call . other c"hasHighBound")) then
        { scopeless
          (117217 call . other c"_high")
        } else
        { scopeless
          _high
        } )(117225 call . other c"_stride")(117229 call . other c"_alignment")))
      } else
      { scopeless(117332 IfExpr (117236 call(117233 call . this c"hasPosNegUnitStride")) then
        { scopeless
          (117237 'new'(117239 call range idxType(117242 call . boundKind c"both")(117246 call . other c"strides")(117259 IfExpr (117253 call(117250 call . other c"hasLowBound")) then
          { scopeless
            (117255 call . other c"_low")
          } else
          { scopeless
            _low
          } )(117272 IfExpr (117266 call(117263 call . other c"hasHighBound")) then
          { scopeless
            (117268 call . other c"_high")
          } else
          { scopeless
            _high
          } )(117276 call . other c"_stride")(117279 call : 0(117283 call chpl__rangeStrideType idxType))))
        } else
        { scopeless
          (117285 'new'(117287 call range idxType(117290 call . boundKind c"both")(117294 call . other c"strides")(117307 IfExpr (117301 call(117298 call . other c"hasLowBound")) then
          { scopeless
            (117303 call . other c"_low")
          } else
          { scopeless
            _low
          } )(117320 IfExpr (117314 call(117311 call . other c"hasHighBound")) then
          { scopeless
            (117316 call . other c"_high")
          } else
          { scopeless
            _high
          } )(117324 call . other c"_stride")(117328 call . this c"_alignment") 1))
        } )
      } )
      (117339 'end of statement')
    }
    (117340 return(117341 call ||(117343 call ==(117349 call(117346 call . boundedOther c"sizeAs") uint[86]) 0)(117353 call contains boundedOther)))
  }
  function _unknown[42].chpl_boundsCheck[117357](arg _mt[117367]:_MT[201], arg this[117360] :
  range, arg other[117364] :
  idxType) : _unknown[42] "inline" "method"
  {
    (117370 return(117372 call contains other))
  }
  function _unknown[42].alignLow[117376](arg _mt[117382]:_MT[201], ref arg this[117379] :
  range) : _unknown[42] "method"
  {
    if(117404 call _cond_test(117394 call && boundsChecking(117397 call !(117403 call(117400 call . this c"isAligned")))))
    {
      { scopeless
        (117389 call(117386 call . HaltWrappers c"boundsCheckHalt") "alignLow -- Cannot be applied to a range with ambiguous alignment.")
      }
    }
    if(117421 call _cond_test(117417 call !(117420 call hasPosNegUnitStride)))
    {
      { scopeless
        (117409 call = _low(117413 call . this c"alignedLowAsInt"))
      }
    }
    (117426 return this)
  }
  function _unknown[42].alignHigh[117430](arg _mt[117436]:_MT[201], ref arg this[117433] :
  range) : _unknown[42] "method"
  {
    if(117458 call _cond_test(117448 call && boundsChecking(117451 call !(117457 call(117454 call . this c"isAligned")))))
    {
      { scopeless
        (117443 call(117440 call . HaltWrappers c"boundsCheckHalt") "alignHigh -- Cannot be applied to a range with ambiguous alignment.")
      }
    }
    if(117475 call _cond_test(117471 call !(117474 call hasPosNegUnitStride)))
    {
      { scopeless
        (117463 call = _high(117467 call . this c"alignedHighAsInt"))
      }
    }
    (117480 return this)
  }
  function _unknown[42].indexOrder[117484](arg _mt[117494]:_MT[201], arg this[117487] :
  range, arg ind[117491] :
  idxType) : _unknown[42] "method" "@unstable"
  {
    if(117516 call _cond_test(117506 call && boundsChecking(117509 call !(117515 call(117512 call . this c"isAligned")))))
    {
      { scopeless
        (117501 call(117498 call . HaltWrappers c"boundsCheckHalt") "indexOrder -- Undefined on a range with ambiguous alignment.")
      }
    }
    if(117534 call _cond_test(117529 call !(117532 call contains ind)))
    {
      { scopeless
        (117521 return(117522 call :(117524 call - 1) chpl_integralIdxType))
      }
    }
    if(117627 call _cond_test(117626 call(117623 call . strides c"isOne")))
    {
      if(117553 call _cond_test(117552 call(117549 call . this c"hasLowBound")))
      {
        { scopeless
          (117540 return(117541 call -(117544 call chpl__idxToInt ind) _low))
        }
      }
    }
    {
      { scopeless
        if(117618 call _cond_test(117617 call(117614 call . strides c"isNegOne")))
        {
          if(117572 call _cond_test(117571 call(117568 call . this c"hasHighBound")))
          {
            { scopeless
              (117559 return(117560 call - _high(117564 call chpl__idxToInt ind)))
            }
          }
        }
        {
          if(117608 call _cond_test(117607 call(117604 call . this c"hasFirst")))
          {
            { scopeless
              (117578 return(117579 call :(117581 call /(117583 call -(117585 call :(117588 call chpl__idxToInt ind) strType)(117591 call :(117594 call chpl__idxToInt(117596 call . this c"first")) strType)) _stride) chpl_integralIdxType))
            }
          }
        }
      }
    }
    (117632 return(117633 call :(117635 call - 1) chpl_integralIdxType))
  }
  function _unknown[42].orderToIndex[117641](arg _mt[117651]:_MT[201], arg this[117644] :
  range, arg ord[117648] :
  integral) : _unknown[42] "method" "@unstable"
  {
    if(117774 call _cond_test boundsChecking)
    {
      if(117669 call _cond_test(117665 call !(117668 call hasFirst)))
      {
        { scopeless
          (117660 call(117657 call . HaltWrappers c"boundsCheckHalt") "invoking orderToIndex on a range that has no first index")
        }
      }
      if(117687 call _cond_test(117683 call !(117686 call isAligned)))
      {
        { scopeless
          (117678 call(117675 call . HaltWrappers c"boundsCheckHalt") "invoking orderToIndex on a range that is ambiguously aligned")
        }
      }
      if(117711 call _cond_test(117707 call < ord 0))
      {
        { scopeless
          (117696 call(117693 call . HaltWrappers c"boundsCheckHalt")(117697 call + "invoking orderToIndex on a negative integer: "(117702 call : ord string[244])))
        }
      }
      if(117768 call _cond_test(117747 call &&(117749 call ==(117752 call . this c"bounds")(117756 call . boundKind c"both"))(117759 call >= ord(117766 call(117763 call . this c"sizeAs") uint[86]))))
      {
        { scopeless
          (117720 call(117717 call . HaltWrappers c"boundsCheckHalt")(117721 call +(117723 call +(117725 call + "invoking orderToIndex on an integer "(117730 call : ord string[244])) " that is larger than the range's number of indices ")(117737 call :(117743 call(117740 call . this c"sizeAs") uint[86]) string[244])))
        }
      }
    }
    (117778 return(117780 call chpl_intToIdx(117782 call chpl__addRangeStrides(117784 call . this c"firstAsInt")(117788 call . this c"stride") ord)))
  }
  { scopeless type
    idxType
  }
  function _unknown[42].translate[117795](arg _mt[117805]:_MT[201], arg this[117798] :
  range, arg offset[117802] :
  integral) : _unknown[42] "inline" "method" "@unstable"
  {
    (117808 return(117809 call + this offset))
  }
  function _unknown[42].translate[117815](arg _mt[117823]:_MT[201], arg this[117818] :
  range, arg i[117821]:_any[141](?)) : _unknown[42] "inline" "last resort" "method"
  {
    (117827 call compilerError "offsets must be of integral type")
  }
  function _unknown[42].translate[117833](arg _mt[117843]:_MT[201], arg this[117836] :
  range, arg offset[117840] :
  integral) : _unknown[42] "inline" "method"
  {
    (117850 call compilerError "can't apply '.translate()' to a range whose 'idxType' only has one value")
  }
  where {
    (117846 call chpl__singleValIdxType idxType)
  }
  function _unknown[42].expand[117857](arg _mt[117867]:_MT[201], arg this[117860] :
  range, arg offset[117864] :
  integral) : _unknown[42] "method"
  {
    (117878 call compilerError "expand() is not supported on unbounded ranges")
  }
  where {
    (117869 call != bounds(117873 call . boundKind c"both"))
  }
  function _unknown[42].expand[117885](arg _mt[117895]:_MT[201], arg this[117888] :
  range, arg offset[117892] :
  integral) : _unknown[42] "method" "@unstable"
  {
    { scopeless
      const i[117899] "const"(117904 call(117901 call . offset c"safeCast")(117906 call chpl__signedType chpl_integralIdxType))
      (117909 'end of statement')
    }
    (117910 return(117911 'new'(117913 call range idxType bounds strides(117917 call - _low i)(117921 call + _high i) _stride _alignment)))
  }
  function _unknown[42].expand[117929](arg _mt[117939]:_MT[201], arg this[117932] :
  range, arg offset[117936] :
  integral) : _unknown[42] "method"
  {
    (117946 call compilerError "can't apply '.expand()' to a range whose 'idxType' only has one value")
  }
  where {
    (117942 call chpl__singleValIdxType idxType)
  }
  function _unknown[42].interior[117953](arg _mt[117963]:_MT[201], arg this[117956] :
  range, arg offset[117960] :
  integral) : _unknown[42] "last resort" "method"
  {
    (117974 call compilerError "interior is not supported on unbounded ranges")
  }
  where {
    (117965 call != bounds(117969 call . boundKind c"both"))
  }
  function _unknown[42].interior[117981](arg _mt[117991]:_MT[201], arg this[117984] :
  range, arg offset[117988] :
  integral) : _unknown[42] "method" "@unstable"
  {
    if(118045 call _cond_test boundsChecking)
    {
      { scopeless
        if(118039 call _cond_test(118025 call >(118027 call :(118030 call abs offset) uint[86])(118037 call(118034 call . this c"sizeAs") uint[86])))
        {
          { scopeless
            (117998 call(117995 call . HaltWrappers c"boundsCheckHalt")(117999 call +(118001 call +(118003 call + "can't compute the interior "(118008 call : offset string[244])) " elements of a range with size ")(118015 call :(118021 call(118018 call . this c"sizeAs") uint[86]) string[244])))
          }
        }
      }
    }
    { scopeless
      const i[118051] "const"(118058 call(118055 call .(118053 call abs offset) c"safeCast") chpl_integralIdxType)
      (118061 'end of statement')
    }
    if(118084 call _cond_test(118080 call < offset 0))
    {
      { scopeless
        (118062 return(118063 'new'(118065 call range idxType bounds strides _low(118070 call +(118072 call - _low 1) i) _stride _alignment)))
      }
    }
    if(118111 call _cond_test(118107 call > offset 0))
    {
      { scopeless
        (118089 return(118090 'new'(118092 call range idxType bounds strides(118096 call -(118098 call + _high 1) i) _high _stride _alignment)))
      }
    }
    (118116 return(118117 'new'(118119 call range idxType bounds strides _low _high _stride _alignment)))
  }
  function _unknown[42].exterior[118129](arg _mt[118139]:_MT[201], arg this[118132] :
  range, arg offset[118136] :
  integral) : _unknown[42] "last resort" "method"
  {
    (118150 call compilerError "exterior is not supported on unbounded ranges")
  }
  where {
    (118141 call != bounds(118145 call . boundKind c"both"))
  }
  function _unknown[42].exterior[118157](arg _mt[118167]:_MT[201], arg this[118160] :
  range, arg offset[118164] :
  integral) : _unknown[42] "method" "@unstable"
  {
    { scopeless
      const i[118171] "const"(118178 call(118175 call .(118173 call abs offset) c"safeCast") chpl_integralIdxType)
      (118181 'end of statement')
    }
    if(118204 call _cond_test(118200 call < offset 0))
    {
      { scopeless
        (118182 return(118183 'new'(118185 call range idxType bounds strides(118189 call - _low i)(118193 call - _low 1) _stride _alignment)))
      }
    }
    if(118231 call _cond_test(118227 call > offset 0))
    {
      { scopeless
        (118209 return(118210 'new'(118212 call range idxType bounds strides(118216 call + _high 1)(118220 call + _high i) _stride _alignment)))
      }
    }
    (118236 return(118237 'new'(118239 call range idxType bounds strides _low _high _stride _alignment)))
  }
  function _unknown[42].exterior[118249](arg _mt[118259]:_MT[201], arg this[118252] :
  range, arg offset[118256] :
  integral) : _unknown[42] "method"
  {
    (118266 call compilerError "can't apply '.exterior()' to a range whose 'idxType' only has one value")
  }
  where {
    (118262 call chpl__singleValIdxType idxType)
  }
  function =[118273](ref arg r1[118278] :
  (118276 call range ?[227]), arg r2[118284] :
  (118282 call range ?[227])) : _unknown[42] "assignop" "inline" "operator"
  {
    if(118324 call _cond_test(118312 call !(118315 call assignmentIsLegal(118317 call . r1 c"idxType")(118321 call . r2 c"idxType"))))
    {
      { scopeless
        (118289 call compilerError "assigning to a range with idxType "(118293 call :(118296 call . r1 c"idxType") string[244]) " from a range with idxType "(118301 call :(118304 call . r2 c"idxType") string[244]) " without an explicit cast")
      }
    }
    if(118361 call _cond_test(118351 call !=(118354 call . r1 c"bounds")(118358 call . r2 c"bounds")))
    {
      { scopeless
        (118330 call compilerError "assigning to a range with boundKind."(118334 call :(118337 call . r1 c"bounds") string[244]) " from a range with boundKind."(118342 call :(118345 call . r2 c"bounds") string[244]) " without an explicit cast")
      }
    }
    if(118394 call _cond_test(118388 call !(118391 call chpl_assignStrideIsSafe r1 r2)))
    {
      { scopeless
        (118367 call compilerError "assigning to a range with strideKind."(118371 call :(118374 call . r1 c"strides") string[244]) " from a range with strideKind."(118379 call :(118382 call . r2 c"strides") string[244]) " without an explicit cast")
      }
    }
    (118399 call =(118402 call . r1 c"_low")(118405 call :(118408 call . r2 c"_low")(118412 call . r1 c"chpl_integralIdxType")))
    (118415 call =(118418 call . r1 c"_high")(118421 call :(118424 call . r2 c"_high")(118428 call . r1 c"chpl_integralIdxType")))
    if(118469 call _cond_test(118462 call !(118468 call(118465 call . r1 c"hasParamStrideAltvalAld"))))
    {
      (118432 call =(118435 call . r1 c"_stride")(118439 call . r2 c"stride"))
      (118442 call =(118445 call . r1 c"_alignment")(118459 IfExpr (118449 call isNothingValue(118451 call . r2 c"_alignment")) then
      { scopeless
        0
      } else
      { scopeless
        (118456 call . r2 c"_alignment")
      } ))
    }
  }
  function +[118475](arg r1[118480] :
  (118478 call range ?[227]), arg r2[118486] :
  (118484 call range ?[227])) : _unknown[42] "operator"
  {
    (118491 call compilerError "range addition is currently not supported")
  }
  function -[118497](arg r1[118502] :
  (118500 call range ?[227]), arg r2[118508] :
  (118506 call range ?[227])) : _unknown[42] "operator"
  {
    (118513 call compilerError "range subtraction is currently not supported")
  }
  function +[118519](arg r[118529] :
  (118522 call range unknown e[118523] unknown b[118525] unknown s[118527]), arg i[118533] :
  integral) : _unknown[42] "inline" "operator" "@unstable"
  {
    (118537 return(118538 'new'(118540 call range e b s(118544 call +(118547 call . r c"_low") i)(118551 call +(118554 call . r c"_high") i)(118559 call . r c"_stride")(118562 call +(118565 call chpl__idxToInt(118569 call . r c"alignment")) i)(118577 call(118574 call . r c"isAligned")))))
  }
  function +=[118580](ref arg r[118590] :
  (118583 call range unknown e[118584] unknown b[118586] unknown s[118588]), arg offset[118594] :
  integral) : _unknown[42] "assignop" "inline" "operator" "@unstable"
  {
    (118598 call = r(118601 call + r offset))
  }
  function +[118607](arg i[118610] :
  integral, arg r[118621] :
  (118614 call range unknown e[118615] unknown b[118617] unknown s[118619])) : _unknown[42] "inline" "operator" "@unstable"
  {
    (118625 return(118626 call + r i))
  }
  function -[118632](arg r[118642] :
  (118635 call range unknown e[118636] unknown b[118638] unknown s[118640]), arg i[118646] :
  integral) : _unknown[42] "inline" "operator" "@unstable"
  {
    (118650 return(118651 'new'(118653 call range e b s(118657 call -(118660 call . r c"_low") i)(118664 call -(118667 call . r c"_high") i)(118672 call . r c"_stride")(118675 call -(118678 call chpl__idxToInt(118680 call . r c"alignment")) i)(118688 call(118685 call . r c"isAligned")))))
  }
  function -=[118691](ref arg r[118701] :
  (118694 call range unknown e[118695] unknown b[118697] unknown s[118699]), arg offset[118705] :
  integral) : _unknown[42] "assignop" "inline" "operator" "@unstable"
  {
    (118709 call = r(118712 call - r offset))
  }
  function chpl_check_step_integral[118718](arg step[118720]:_any[141](?)) : _unknown[42] "inline"
  {
    if(118740 call _cond_test(118734 call !(118737 call isIntegral(118739 'typeof' step))))
    {
      { scopeless
        (118724 call compilerError "can't apply 'by' using step of a non-integral type "(118728 call :(118731 'typeof' step) string[244]))
      }
    }
  }
  function chpl_need_to_check_step[118747](arg step[118749]:_any[141](?), arg strType[118751]:_any[141](?)) param : _unknown[42]
  {
    (118755 call compilerAssert(118757 call isInt strType))
    (118759 return(118760 call &&(118762 call !=(118765 'typeof' step) strType)(118767 call >=(118770 call numBits(118772 'typeof' step))(118774 call numBits strType))))
  }
  function chpl_range_check_stride[118778](arg step[118780]:_any[141](?), arg idxType[118782]:_any[141](?)) : _unknown[42] "inline"
  {
    (118786 call chpl_check_step_integral step)
    unknown strType[118789] "type variable"(118791 call chpl__rangeStrideType idxType)
    if(118850 call _cond_test boundsChecking)
    {
      if(118808 call _cond_test(118804 call == step 0))
      {
        { scopeless
          (118799 call(118796 call . HaltWrappers c"boundsCheckHalt") "the step argument of the 'by' operator is zero")
        }
      }
      if(118844 call _cond_test(118828 call &&(118831 call chpl_need_to_check_step step strType)(118834 call > step(118837 call :(118840 call max strType)(118843 'typeof' step)))))
      {
        { scopeless
          (118817 call(118814 call . HaltWrappers c"boundsCheckHalt")(118818 call + "the step argument of the 'by' operator is too large and cannot be represented within the range's stride type "(118823 call : strType string[244])))
        }
      }
    }
  }
  function chpl_range_check_stride[118856](param arg step[118858]:_any[141](?), arg idxType[118860]:_any[141](?)) : _unknown[42] "inline"
  {
    (118864 call chpl_check_step_integral step)
    unknown strType[118867] "type variable"(118869 call chpl__rangeStrideType idxType)
    if(118880 call _cond_test(118876 call == step 0))
    {
      { scopeless
        (118873 call compilerError "the step argument of the 'by' operator is zero")
      }
    }
    if(118911 call _cond_test(118895 call &&(118898 call chpl_need_to_check_step step strType)(118901 call > step(118904 call :(118907 call max strType)(118910 'typeof' step)))))
    {
      { scopeless
        (118886 call compilerError(118887 call + "the step argument of the 'by' operator is too large and cannot be represented within the range's stride type "(118890 call : strType string[244])))
      }
    }
  }
  function chpl_by_help[118918](arg r[118928] :
  (118921 call range unknown i[118922] unknown b[118924] unknown s[118926]), arg step[118931]:_any[141](?), param arg newStrides[118933]:_any[141](?)) : _unknown[42]
  {
    { scopeless
      { scopeless
        const lw[118961] "const"(118963 call . r c"_low")
      }
      { scopeless
        const hh[118954] "const"(118956 call . r c"_high")
      }
      { scopeless
        const st[118938] "const"(118939 call *(118942 call . r c"stride")(118945 call : step(118949 call . r c"strType")))
      }
      (118967 'end of statement')
    }
    (118969 call compilerAssert(118970 call !(118976 call(118973 call . newStrides c"isPosNegOne"))))
    if(119005 call _cond_test(118998 call !(119004 call(119001 call . r c"isAligned"))))
    {
      { scopeless
        (118977 return(118994 IfExpr (118978 call ||(118980 call == st 1)(118984 call == st(118987 call - 1))) then
        { scopeless
          (118991 call newZeroAlmtRange)
        } else
        { scopeless
          (118993 call newUnalignedRange)
        } ))
      }
    }
    if(119084 call _cond_test(119081 call isPositiveStride newStrides st))
    {
      { scopeless
        (119010 return(119040 IfExpr (119012 call hasLowBoundForIter r) then
        { scopeless
          (119014 'new'(119016 call range i b newStrides lw hh st(119024 call . r c"chpl_alignedLowAsIntForIter") 1 1))
        } else
        { scopeless(119037 IfExpr (119029 call == st 1) then
          { scopeless
            (119034 call newZeroAlmtRange)
          } else
          { scopeless
            (119036 call newUnalignedRange)
          } )
        } ))
      }
    }
    {
      { scopeless
        (119044 return(119076 IfExpr (119046 call hasHighBoundForIter r) then
        { scopeless
          (119048 'new'(119050 call range i b newStrides lw hh st(119058 call . r c"chpl_alignedHighAsIntForIter") 1 1))
        } else
        { scopeless(119073 IfExpr (119063 call == st(119066 call - 1)) then
          { scopeless
            (119070 call newZeroAlmtRange)
          } else
          { scopeless
            (119072 call newUnalignedRange)
          } )
        } ))
      }
    }
    function newAlignedRange[119090](arg alignment[119092]:_any[141](?)) : _unknown[42]
    {
      (119095 return(119096 'new'(119098 call range i b newStrides lw hh st alignment 1 1)))
    }
    function newZeroAlmtRange[119110]() : _unknown[42]
    {
      (119113 return(119114 'new'(119116 call range i b newStrides lw hh st(119123 call : 0(119127 call . r c"strType")))))
    }
    function newUnalignedRange[119132]() : _unknown[42] "inline"
    {
      (119135 return(119136 'new'(119138 call range i b newStrides lw hh st(119145 call : unalignedMark(119149 call . r c"strType")))))
    }
  }
  function chpl_by[119156](arg r[119161] :
  (119159 call range ?[227]), arg step[119164]:_any[141](?)) : _unknown[42] "inline" "operator"
  {
    (119168 call chpl_range_check_stride step(119171 call . r c"idxType"))
    { scopeless
      unknown newStrides[119175] "param"(119195 IfExpr (119176 call !(119179 call isUint step)) then
      { scopeless
        (119182 call . strideKind c"any")
      } else
      { scopeless
        (119186 call chpl_strideProduct(119188 call . r c"strides")(119192 call . strideKind c"positive"))
      } )
      (119199 'end of statement')
    }
    (119200 return(119202 call chpl_by_help r step newStrides))
  }
  function chpl_by[119208](arg r[119213] :
  (119211 call range ?[227]), param arg step[119216]:_any[141](?)) : _unknown[42] "inline" "operator"
  {
    (119220 call chpl_range_check_stride step(119223 call . r c"idxType"))
    if(119233 call _cond_test(119229 call == step 1))
    {
      { scopeless
        (119226 return r)
      }
    }
    if(119312 call _cond_test(119306 call == step(119309 call - 1)))
    {
      { scopeless
        (119238 return(119302 IfExpr (119243 call(119240 call . r c"hasParamStrideAltvalAld")) then
        { scopeless
          (119244 'new'(119246 call range(119248 call . r c"idxType")(119252 call . r c"bounds")(119256 call chpl_strideProduct r step)(119260 call . r c"_low")(119264 call . r c"_high") none none))
        } else
        { scopeless
          (119269 'new'(119271 call range(119273 call . r c"idxType")(119277 call . r c"bounds")(119281 call chpl_strideProduct r step)(119285 call . r c"_low")(119289 call . r c"_high")(119292 call -(119295 call . r c"_stride"))(119299 call . r c"_alignment")))
        } ))
      }
    }
    (119317 return(119319 call chpl_by_help r step(119323 call chpl_strideProduct r step)))
  }
  function chpl_by[119328](arg r[119330]:_any[141](?), arg step[119332]:_any[141](?)) : _unknown[42] "inline" "last resort" "operator"
  {
    (119336 call compilerError "cannot apply 'by' to '"(119340 call :(119343 'typeof' r) string[244]) "'")
  }
  function chpl_align[119348](arg r[119358] :
  (119351 call range unknown i[119352] unknown b[119354] unknown s[119356]), arg algn[119362] :
  i) : _unknown[42] "inline" "operator"
  {
    (119366 return(119367 'new'(119369 call range(119371 call . r c"idxType")(119375 call . r c"bounds")(119379 call . r c"strides")(119383 call . r c"_low")(119387 call . r c"_high")(119391 call . r c"_stride")(119395 call chpl__idxToInt algn) 1)))
  }
  function chpl_align[119400](arg r[119410] :
  (119403 call range unknown i[119404] unknown b[119406] unknown s[119408]), arg algn[119413]:_any[141](?)) : _unknown[42] "inline" "last resort" "operator"
  {
    (119417 call compilerError "can't align a range with idxType "(119421 call : i string[244]) " using a value of type "(119428 call :(119431 'typeof' algn) string[244]))
  }
  function chpl_align[119435](arg r[119437]:_any[141](?), arg algn[119439]:_any[141](?)) : _unknown[42] "inline" "last resort" "operator"
  {
    (119443 call compilerError "cannot apply 'align' to '"(119447 call :(119450 'typeof' r) string[244]) "'")
  }
  function _unknown[42].offset[119455](arg _mt[119465]:_MT[201], arg this[119458] :
  range, in arg offset[119462] :
  integral) : _unknown[42] "method" "@unstable"
  {
    if(119477 call _cond_test(119475 call chpl__singleValIdxType idxType))
    {
      (119470 call compilerError "can't apply '.offset()' to a range whose 'idxType' only has one value")
    }
    { scopeless
      unknown offs[119482](119487 call(119484 call . offset c"safeCast") chpl_integralIdxType)
      (119490 'end of statement')
    }
    if(119523 call _cond_test(119522 call hasUnitStride))
    {
      if(119511 call _cond_test(119504 call !(119510 call(119507 call . this c"hasLowBound"))))
      {
        { scopeless
          (119493 call compilerError "can't invoke 'offset' on an unstrided range with no low bound")
        }
      }
      {
        { scopeless
          (119499 call compilerWarning "invoking 'offset' on an unstrided range has no effect.")
        }
      }
      (119517 call = offs 0)
    }
    if(119543 call _cond_test(119536 call && boundsChecking(119539 call !(119542 call hasFirst))))
    {
      { scopeless
        (119531 call(119528 call . HaltWrappers c"boundsCheckHalt") "invoking 'offset' on a range without a first index")
      }
    }
    (119548 return(119549 'new'(119551 call range idxType bounds strides _low _high stride(119558 call +(119561 call . this c"firstAsInt") offs) 1)))
  }
  function _unknown[42].this[119568](arg _mt[119580]:_MT[201], const arg this[119571] :
  range, arg other[119577] :
  (119575 call range ?[227])) : _unknown[42] "method"
  {
    if(119601 call _cond_test(119594 call !(119600 call(119597 call . this c"isAligned"))))
    {
      { scopeless
        (119589 call(119586 call . HaltWrappers c"unimplementedFeatureHalt") "slicing of an unaligned range")
      }
    }
    { scopeless
      unknown newBoundKind[119607] "param"(119609 call computeBoundedType this other)
      (119613 'end of statement')
    }
    function computeBoundedType[119614](arg r1[119616]:_any[141](?), arg r2[119618]:_any[141](?)) param : _unknown[42]
    {
      { scopeless
        unknown low[119622] "param"(119623 call ||(119629 call(119626 call . r1 c"hasLowBound"))(119634 call(119631 call . r2 c"hasLowBound")))
        (119636 'end of statement')
      }
      { scopeless
        unknown high[119638] "param"(119639 call ||(119645 call(119642 call . r1 c"hasHighBound"))(119650 call(119647 call . r2 c"hasHighBound")))
        (119652 'end of statement')
      }
      if(119695 call _cond_test(119691 call && low high))
      {
        { scopeless
          (119653 return(119655 call . boundKind c"both"))
        }
      }
      {
        { scopeless
          if(119685 call _cond_test low)
          {
            { scopeless
              (119659 return(119661 call . boundKind c"low"))
            }
          }
          {
            { scopeless
              if(119678 call _cond_test high)
              {
                { scopeless
                  (119665 return(119667 call . boundKind c"high"))
                }
              }
              {
                { scopeless
                  (119671 return(119673 call . boundKind c"neither"))
                }
              }
            }
          }
        }
      }
    }
    if(119756 call _cond_test(119725 call &&(119727 call &&(119729 call != newBoundKind(119733 call . boundKind c"both"))(119736 call !(119745 call(119742 call .(119739 call . this c"strides") c"isPosNegOne"))))(119746 call !(119755 call(119752 call .(119749 call . other c"strides") c"isPosNegOne")))))
    {
      { scopeless
        (119704 call compilerWarning "slicing a "(119708 call :(119711 'typeof' this) string[244]) " with a "(119716 call :(119719 'typeof' other) string[244]) " might produce an empty range and result in a halt")
      }
    }
    { scopeless
      unknown lo1[119762](119773 IfExpr (119764 call hasLowBound) then
      { scopeless
        (119766 call . this c"_low")
      } else
      { scopeless
        (119770 call . other c"_low")
      } )
      (119777 'end of statement')
    }
    { scopeless
      unknown hi1[119779](119790 IfExpr (119781 call hasHighBound) then
      { scopeless
        (119783 call . this c"_high")
      } else
      { scopeless
        (119787 call . other c"_high")
      } )
      (119794 'end of statement')
    }
    { scopeless
      unknown st1[119796](119798 call abs(119800 call . this c"stride"))
      (119804 'end of statement')
    }
    { scopeless
      unknown lo2[119806](119820 IfExpr (119811 call(119808 call . other c"hasLowBound")) then
      { scopeless
        (119813 call . other c"_low")
      } else
      { scopeless
        (119817 call . this c"_low")
      } )
      (119824 'end of statement')
    }
    { scopeless
      unknown hi2[119826](119840 IfExpr (119831 call(119828 call . other c"hasHighBound")) then
      { scopeless
        (119833 call . other c"_high")
      } else
      { scopeless
        (119837 call . this c"_high")
      } )
      (119844 'end of statement')
    }
    { scopeless
      unknown st2[119846](119848 call abs(119850 call . other c"stride"))
      (119854 'end of statement')
    }
    if(119873 call _cond_test(119871 call isUintType chpl_integralIdxType))
    {
      if(119865 call _cond_test(119861 call < lo1 0))
      {
        { scopeless
          (119856 call = lo1 0)
        }
      }
    }
    { scopeless
      unknown emptyIntersection[119878] bool
      (119881 'end of statement')
    }
    function myMin[119882](arg x[119885] :
    int[10], arg y[119889] :
    uint[86]) : _unknown[42]
    {
      if(119902 call _cond_test(119896 call > y(119900 call max int[10])))
      {
        (119894 return x)
      }
      (119906 return(119908 call min x(119910 call : y int[10])))
    }
    function myMin[119916](arg x[119919] :
    uint[86], arg y[119923] :
    int[10]) : _unknown[42]
    {
      if(119938 call _cond_test(119934 call < y 0))
      {
        (119928 call = emptyIntersection 1)
        (119932 return x)
      }
      (119942 return(119944 call min x(119946 call : y uint[86])))
    }
    function myMin[119952](arg x[119955] :
    int[10], arg y[119959] :
    int[10]) : _unknown[42]
    {
      (119963 return(119965 call min x y))
    }
    function myMin[119970](arg x[119973] :
    uint[86], arg y[119977] :
    uint[86]) : _unknown[42]
    {
      (119981 return(119983 call min x y))
    }
    function myMax[119988](arg x[119991] :
    int[10], arg y[119995] :
    uint[86]) : _unknown[42]
    {
      if(120012 call _cond_test(120006 call > y(120010 call max int[10])))
      {
        (120000 call = emptyIntersection 1)
        (120004 return x)
      }
      (120016 return(120018 call max x(120020 call : y int[10])))
    }
    function myMax[120026](arg x[120029] :
    uint[86], arg y[120033] :
    int[10]) : _unknown[42]
    {
      if(120044 call _cond_test(120040 call < y 0))
      {
        (120038 return x)
      }
      (120048 return(120050 call max x(120052 call : y uint[86])))
    }
    function myMax[120058](arg x[120061] :
    int[10], arg y[120065] :
    int[10]) : _unknown[42]
    {
      (120069 return(120071 call max x y))
    }
    function myMax[120076](arg x[120079] :
    uint[86], arg y[120083] :
    uint[86]) : _unknown[42]
    {
      (120087 return(120089 call max x y))
    }
    (120094 call = emptyIntersection 0)
    { scopeless
      unknown newlo[120099](120100 call :(120103 call myMax lo1 lo2) chpl_integralIdxType)
      (120108 'end of statement')
    }
    { scopeless
      unknown newhi[120110](120111 call :(120114 call myMin hi1 hi2) chpl_integralIdxType)
      (120119 'end of statement')
    }
    if(120136 call _cond_test emptyIntersection)
    {
      (120121 call = newlo(120125 call chpl__defaultLowBound idxType newBoundKind))
      (120128 call = newhi(120132 call chpl__defaultHighBound idxType newBoundKind))
    }
    { scopeless
      unknown newStrideKind[120141] "param"(120143 call chpl_strideProduct this other)
      (120147 'end of statement')
    }
    { scopeless
      { scopeless
        unknown newStride[120154] st1
      }
      { scopeless
        unknown newAbsStride[120150] st1
      }
      (120157 'end of statement')
    }
    { scopeless
      { scopeless
        unknown type_tmp[120165] "temp" "type variable" strType
        unknown gcd[120164] type_tmp[120165]
      }
      { scopeless
        unknown x[120160] type_tmp[120165]
      }
      (120170 'end of statement')
    }
    if(120281 call _cond_test(120274 call !(120280 call(120277 call . newStrideKind c"isPosNegOne"))))
    {
      if(120207 call _cond_test(120203 call == st1 st2))
      {
        (120173 call = gcd st1)
      }
      {
        (120187 call =(120181 call _build_tuple gcd x)(120184 call chpl__extendedEuclid st1 st2))
        (120189 call = newStride(120192 call *(120194 call / st1 gcd) st2))
        (120199 call = newAbsStride newStride)
      }
      if(120244 call _cond_test(120218 call ||(120220 call &&(120226 call(120223 call . this c"hasPositiveStride"))(120231 call(120228 call . other c"hasNegativeStride")))(120232 call &&(120238 call(120235 call . this c"hasNegativeStride"))(120243 call(120240 call . other c"hasPositiveStride")))))
      {
        { scopeless
          (120211 call = newStride(120214 call - newStride))
        }
      }
    }
    {
      (120251 call compilerAssert(120256 call(120253 call . this c"hasPosNegUnitStride")))
      if(120269 call _cond_test(120268 call(120265 call . newStrideKind c"isNegOne")))
      {
        { scopeless
          (120257 call = newStride(120260 call - 1))
        }
      }
    }
    { scopeless
      unknown result[120286](120287 'new'(120289 call range idxType newBoundKind newStrideKind newlo newhi newStride(120296 call : 0 strType)))
      (120301 'end of statement')
    }
    if(120732 call _cond_test(120719 call &&(120721 call !(120727 call(120724 call . newStrideKind c"isPosNegOne")))(120728 call > newAbsStride 1)))
    {
      { scopeless
        unknown al1[120304](120305 call :(120308 call chpl__idxToInt(120310 call . this c"alignment")) int[10])
        (120315 'end of statement')
      }
      { scopeless
        unknown al2[120317](120318 call :(120321 call chpl__idxToInt(120323 call . other c"alignment")) int[10])
        (120328 'end of statement')
      }
      { scopeless
        unknown newAlignmentIsInAl2[120330] 0
        (120333 'end of statement')
      }
      if(120487 call _cond_test(120480 call !(120486 call(120483 call . other c"isAligned"))))
      {
        (120335 call = al2 al1)
        if(120348 call _cond_test(120344 call < al2 0))
        {
          { scopeless
            (120339 call += al2 st1)
          }
        }
        if(120476 call _cond_test(120472 call > st2 gcd))
        {
          if(120442 call _cond_test(120430 call &&(120436 call(120433 call . result c"hasLowBound"))(120441 call(120438 call . result c"hasPositiveStride"))))
          {
            if(120380 call _cond_test(120370 call ==(120372 call %(120374 call - newlo al1) st1) 0))
            {
              (120356 call = al2(120359 call :(120361 call % newlo newAbsStride) int[10]))
              (120366 call = newAlignmentIsInAl2 1)
            }
          }
          {
            { scopeless
              if(120426 call _cond_test(120414 call &&(120420 call(120417 call . result c"hasHighBound"))(120425 call(120422 call . result c"hasNegativeStride"))))
              {
                if(120410 call _cond_test(120400 call ==(120402 call %(120404 call - newhi al1) st1) 0))
                {
                  (120386 call = al2(120389 call :(120391 call % newhi newAbsStride) int[10]))
                  (120396 call = newAlignmentIsInAl2 1)
                }
              }
            }
          }
          if(120467 call _cond_test(120461 call && chpl_warnUnstable(120464 call ! newAlignmentIsInAl2)))
          {
            { scopeless
              (120448 call warning "slicing '" this "' with the unaligned range '" other "' is unstable w.r.t. the choice of alignment")
            }
          }
        }
      }
      { scopeless
        const g[120492] "const" gcd
        (120495 'end of statement')
      }
      if(120714 call _cond_test newAlignmentIsInAl2)
      {
        if(120506 call _cond_test(120502 call < al2 0))
        {
          { scopeless
            (120497 call += al2 newAbsStride)
          }
        }
        (120511 call =(120514 call . result c"_alignment")(120517 call : al2 strType))
      }
      {
        { scopeless
          if(120709 call _cond_test(120699 call !=(120701 call %(120703 call - al2 al1) g) 0))
          {
            if(120544 call _cond_test(120531 call && boundsChecking(120534 call !=(120537 call . result c"bounds")(120541 call . boundKind c"both"))))
            {
              { scopeless
                (120526 call(120523 call . HaltWrappers c"boundsCheckHalt") "could not represent range slice - it needs to be empty, but the slice type is not bounded")
              }
            }
            (120549 call =(120552 call . result c"_low")(120556 call chpl__defaultLowBound idxType newBoundKind))
            (120559 call =(120562 call . result c"_high")(120566 call chpl__defaultHighBound idxType newBoundKind))
            (120569 call =(120572 call . result c"_alignment")(120575 call :(120590 IfExpr (120581 call(120578 call . this c"hasPositiveStride")) then
            { scopeless
              (120583 call . result c"_low")
            } else
            { scopeless
              (120587 call . result c"_high")
            } ) strType))
          }
          {
            { scopeless
              unknown offset[120596](120597 call *(120599 call - al2 al1) x)
              (120605 'end of statement')
            }
            (120606 call =(120609 call . result c"_alignment")(120612 call +(120614 call : al1 strType)(120618 call /(120620 call *(120622 call : offset strType) st1) g)))
            if(120694 call _cond_test(120687 call <(120690 call . result c"_alignment") 0))
            {
              (120629 call +=(120632 call . result c"_alignment") newAbsStride)
              if(120647 call _cond_test boundsChecking)
              {
                { scopeless
                  (120637 call assert(120638 call >=(120641 call . result c"_alignment") 0))
                }
              }
            }
            {
              { scopeless
                if(120683 call _cond_test(120676 call >=(120679 call . result c"_alignment") newAbsStride))
                {
                  (120653 call -=(120656 call . result c"_alignment") newAbsStride)
                  if(120671 call _cond_test boundsChecking)
                  {
                    { scopeless
                      (120661 call assert(120662 call <(120665 call . result c"_alignment") newAbsStride))
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    (120736 return result)
  }
  function chpl_count_help[120740](arg r[120745] :
  (120743 call range ?[227]), arg i[120748]:_any[141](?)) : _unknown[42] "last resort"
  {
    (120762 call compilerError "count operator is not defined for unbounded ranges")
  }
  where {
    (120750 call ==(120753 call . r c"bounds")(120757 call . boundKind c"neither"))
  }
  function chpl_count_help[120769](arg r[120771]:_any[141](?), arg count[120774] :
  integral) : _unknown[42]
  {
    if(120794 call _cond_test(120784 call && boundsChecking(120787 call !(120793 call(120790 call . r c"isAligned")))))
    {
      { scopeless
        (120779 call boundsCheckHalt "count -- Cannot count off elements from a range which is ambiguously aligned.")
      }
    }
    unknown resultType[120800] "type variable"(120802 call . r c"chpl_integralIdxType")
    unknown strType[120807] "type variable"(120809 call chpl__rangeStrideType resultType)
    function absSameType[120812](arg r[120814]:_any[141](?), arg resultType[120816]:_any[141](?)) : _unknown[42]
    {
      if(120844 call _cond_test(120843 call(120840 call . r c"hasNegativeStride")))
      {
        (120820 return(120821 call :(120823 call -(120826 call . r c"stride")) resultType))
      }
      {
        (120831 return(120832 call :(120835 call . r c"stride") resultType))
      }
    }
    if(121018 call _cond_test(121014 call == count 0))
    {
      if(121009 call _cond_test(121008 call(121005 call . r c"hasLowBound")))
      {
        (120852 return(120853 'new'(120855 call range(idxType =(120857 call . r c"idxType"))(bounds =(120862 call . boundKind c"both"))(strides =(120867 call . r c"strides"))(_low =(120872 call . r c"_low"))(_high =(120876 call -(120879 call . r c"_low")(120883 call absSameType r resultType)))(_stride =(120888 call . r c"stride"))(alignmentValue =(120893 call . r c"_alignment")))))
      }
      {
        { scopeless
          if(121000 call _cond_test(120999 call(120996 call . r c"hasHighBound")))
          {
            (120898 return(120899 'new'(120901 call range(idxType =(120903 call . r c"idxType"))(bounds =(120908 call . boundKind c"both"))(strides =(120913 call . r c"strides"))(_low =(120917 call +(120920 call . r c"_high")(120924 call absSameType r resultType)))(_high =(120929 call . r c"_high"))(_stride =(120934 call . r c"stride"))(alignmentValue =(120939 call . r c"_alignment")))))
          }
          {
            (120944 return(120945 'new'(120947 call range(idxType =(120949 call . r c"idxType"))(bounds =(120954 call . boundKind c"both"))(strides =(120959 call . r c"strides"))(_low =(120964 call chpl__defaultLowBound(120966 call . r c"idxType")(120970 call . boundKind c"both")))(_high =(120975 call chpl__defaultHighBound(120977 call . r c"idxType")(120981 call . boundKind c"both")))(_stride =(120986 call . r c"stride"))(alignmentValue =(120991 call . r c"_alignment")))))
          }
        }
      }
    }
    if(121144 call _cond_test boundsChecking)
    {
      if(121044 call _cond_test(121029 call &&(121031 call > count 0)(121035 call !(121043 call(121040 call . r c"hasFirstForIter")))))
      {
        { scopeless
          (121024 call boundsCheckHalt "With a positive count, the range must have a first index.")
        }
      }
      if(121070 call _cond_test(121055 call &&(121057 call < count 0)(121061 call !(121069 call(121066 call . r c"hasLastForIter")))))
      {
        { scopeless
          (121050 call boundsCheckHalt "With a negative count, the range must have a last index.")
        }
      }
      if(121138 call _cond_test(121106 call &&(121108 call ==(121111 call . r c"bounds")(121115 call . boundKind c"both"))(121118 call >(121120 call :(121123 call abs(121124 call : count(121128 call chpl__maxIntTypeSameSign(121130 'typeof' count)))) uint[86])(121136 call(121133 call . r c"sizeAs") uint[86]))))
      {
        { scopeless
          (121076 call boundsCheckHalt(121077 call +(121079 call +(121081 call +(121083 call + "range of size "(121088 call :(121091 call . r c"size") string[244])) " is too small for counting ")(121098 call :(121101 call abs count) string[244])) " elements"))
        }
      }
    }
    function chpl__computeTypeForCountMath[121148](arg t1[121150]:_any[141](?), arg t2[121152]:_any[141](?)) type : _unknown[42]
    {
      unknown t1i[121156] "type variable"(121158 call chpl__idxTypeToIntIdxType t1)
      unknown t2i[121162] "type variable"(121164 call chpl__idxTypeToIntIdxType t2)
      if(121285 call _cond_test(121281 call == t1i t2i))
      {
        (121168 return t1i)
      }
      {
        { scopeless
          if(121276 call _cond_test(121268 call &&(121271 call isInt t1i)(121274 call isInt t2i)))
          {
            (121171 return(121173 call int[10](121175 call max(121177 call numBits t1i)(121180 call numBits t2i))))
          }
          {
            { scopeless
              if(121263 call _cond_test(121255 call &&(121258 call isUint t1i)(121261 call isUint t2i)))
              {
                (121183 return(121185 call uint[86](121187 call max(121189 call numBits t1i)(121192 call numBits t2i))))
              }
              {
                { scopeless
                  if(121250 call _cond_test(121236 call ||(121238 call ==(121241 call numBits t1i) 64)(121244 call ==(121247 call numBits t2i) 64)))
                  {
                    (121195 return(121197 call int[10] 64))
                  }
                  {
                    { scopeless
                      if(121232 call _cond_test(121230 call isInt t1i))
                      {
                        (121200 return(121202 call int[10](121204 call max(121206 call numBits t1i)(121208 call * 2(121212 call numBits t2i)))))
                      }
                      {
                        (121215 return(121217 call int[10](121219 call max(121220 call * 2(121224 call numBits t1i))(121227 call numBits t2i))))
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    unknown computeType[121293] "type variable"(121295 call chpl__computeTypeForCountMath resultType(121298 'typeof' count))
    unknown signedComputeType[121301] "type variable"(121303 call chpl__signedType computeType)
    { scopeless
      unknown diff[121307](121308 call *(121310 call : count signedComputeType)(121314 call :(121317 call . r c"stride") signedComputeType))
      (121322 'end of statement')
    }
    { scopeless
      unknown lo[121324](121351 IfExpr (121326 call > diff 0) then
      { scopeless
        (121331 call . r c"_low")
      } else
      { scopeless
        (121335 call chpl__add(121336 call :(121339 call . r c"_high") computeType)(121343 call :(121345 call + diff 1) computeType) resultType)
      } ) resultType
      (121355 'end of statement')
    }
    { scopeless
      unknown hi[121357](121384 IfExpr (121359 call < diff 0) then
      { scopeless
        (121364 call . r c"_high")
      } else
      { scopeless
        (121368 call chpl__add(121369 call :(121372 call . r c"_low") computeType)(121376 call -(121378 call : diff computeType) 1) resultType)
      } ) resultType
      (121388 'end of statement')
    }
    if(121451 call _cond_test(121444 call !(121450 call(121447 call . r c"hasPosNegUnitStride"))))
    {
      if(121412 call _cond_test(121398 call &&(121404 call(121401 call . r c"hasLowBound"))(121405 call < lo(121409 call . r c"_low"))))
      {
        { scopeless
          (121390 call = lo(121394 call . r c"_low"))
        }
      }
      if(121439 call _cond_test(121425 call &&(121431 call(121428 call . r c"hasHighBound"))(121432 call > hi(121436 call . r c"_high"))))
      {
        { scopeless
          (121417 call = hi(121421 call . r c"_high"))
        }
      }
    }
    (121455 return(121456 'new'(121458 call range(idxType =(121460 call . r c"idxType"))(bounds =(121465 call . boundKind c"both"))(strides =(121470 call . r c"strides"))(_low = lo)(_high = hi)(121479 call . r c"_stride")(121483 call . r c"_alignment"))))
  }
  function #[121488](arg r[121493] :
  (121491 call range ?[227]), arg count[121497] :
  bool) : _unknown[42] "operator"
  {
    (121501 return(121503 call chpl_count_help r(121505 call : count int[10])))
  }
  function #[121511](arg r[121516] :
  (121514 call range ?[227]), arg count[121520] :
  integral) : _unknown[42] "operator"
  {
    (121524 return(121526 call chpl_count_help r count))
  }
  function #[121531](arg r[121537] :
  (121534 call range unknown i[121535]), arg count[121540]:_any[141](?)) : _unknown[42] "last resort" "operator"
  {
    (121544 call compilerError "can't apply '#' to a range with idxType "(121546 call : i string[244]) " using a count of type "(121551 call :(121554 'typeof' count) string[244]))
  }
  function #[121558](arg r[121560]:_any[141](?), arg count[121562]:_any[141](?)) : _unknown[42] "last resort" "operator"
  {
    (121566 call compilerError "cannot apply '#' to '"(121570 call :(121573 'typeof' r) string[244]) "'")
  }
  function chpl_checkIfRangeIterWillOverflow[121578](arg idxType[121580]:_any[141](?), arg low[121582]:_any[141](?), arg high[121584]:_any[141](?), arg stride[121586]:_any[141](?), arg first[121589] =
  low, arg last[121593] =
  high, arg shouldHalt[121597] =
  1) : _unknown[42]
  {
    if(121608 call _cond_test(121604 call > low high))
    {
      (121602 return 0)
    }
    { scopeless
      unknown willOverFlow[121613] 0
      (121616 'end of statement')
    }
    if(121762 call _cond_test(121760 call isIntType idxType))
    {
      if(121680 call _cond_test(121670 call &&(121672 call > last 0)(121676 call > stride 0)))
      {
        if(121633 call _cond_test(121624 call > stride(121627 call -(121630 call max idxType) last)))
        {
          (121620 call = willOverFlow 1)
        }
      }
      {
        { scopeless
          if(121666 call _cond_test(121656 call &&(121658 call < last 0)(121662 call < stride 0)))
          {
            if(121652 call _cond_test(121643 call < stride(121646 call -(121649 call min idxType) last)))
            {
              (121639 call = willOverFlow 1)
            }
          }
        }
      }
    }
    {
      { scopeless
        if(121755 call _cond_test(121753 call isUintType idxType))
        {
          if(121738 call _cond_test(121734 call > stride 0))
          {
            if(121702 call _cond_test(121692 call <(121694 call + last(121697 call : stride idxType)) last))
            {
              (121688 call = willOverFlow 1)
            }
          }
          {
            { scopeless
              if(121730 call _cond_test(121726 call < stride 0))
              {
                if(121722 call _cond_test(121712 call >(121714 call + last(121717 call : stride idxType)) last))
                {
                  (121708 call = willOverFlow 1)
                }
              }
            }
          }
        }
        {
          (121745 call compilerError "Iterator overflow checking is only supported " "for integral types")
        }
      }
    }
    if(121780 call _cond_test(121776 call && willOverFlow shouldHalt))
    {
      (121772 call(121769 call . HaltWrappers c"boundsCheckHalt") "Iteration over a bounded range may be incorrect due to overflow.")
    }
    (121784 return willOverFlow)
  }
  function _unknown[42].checkIfIterWillOverflow[121788](arg _mt[121798]:_MT[201], arg this[121791] :
  range, arg shouldHalt[121795] =
  1) : _unknown[42] "method"
  {
    if(121807 call _cond_test(121805 call isFiniteIdxType idxType))
    {
      { scopeless
        (121801 return 0)
      }
    }
    (121812 return(121814 call chpl_checkIfRangeIterWillOverflow(121816 call . this c"chpl_integralIdxType")(121820 call . this c"_low")(121824 call . this c"_high")(121828 call . this c"stride")(121834 call . this c"chpl_firstAsIntForIter")(121840 call . this c"chpl_lastAsIntForIter") shouldHalt))
  }
  function chpl_direct_range_iter[121846](param arg low[121849] :
  integral, param arg high[121853] :
  integral) : _unknown[42] "iterator fn"
  {
    unknown idxType[121858] "type variable"(121860 call computeParamRangeIndexType low high)
    {
      unknown _indexOfInterest[121883] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[121884] "expr temp" "temp"
      (121893 'move' _iterator[121884](121891 call _getIterator(121867 call chpl_direct_param_stride_range_iter(121868 call : low idxType)(121872 call : high idxType)(121876 call : 1 idxType))))
      Defer
      {
        {
          (121908 call _freeIterator _iterator[121884])
        }
      }
      { scopeless type
        (121898 'move' _indexOfInterest[121883](121895 call iteratorIndex _iterator[121884]))
      }
      ForLoop[121885]
      {
        unknown i[121864] "index var" "insert auto destroy"
        (121903 'move' i[121864] _indexOfInterest[121883])
        { scopeless
          (121880 yield i)
        }
        label _continueLabel[121888]
        _indexOfInterest[121883]
        _iterator[121884]
      }
      label _breakLabel[121889]
    }
  }
  function chpl_direct_range_iter[121917](arg low[121922] :
  (121920 call int[10] 8), arg high[121928] :
  (121926 call int[10] 8)) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[121947] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[121948] "expr temp" "temp"
      (121957 'move' _iterator[121948](121955 call _getIterator(121935 call chpl_direct_param_stride_range_iter low high(121938 call : 1(121942 call int[10] 8)))))
      Defer
      {
        {
          (121972 call _freeIterator _iterator[121948])
        }
      }
      { scopeless type
        (121962 'move' _indexOfInterest[121947](121959 call iteratorIndex _iterator[121948]))
      }
      ForLoop[121949]
      {
        unknown i[121932] "index var" "insert auto destroy"
        (121967 'move' i[121932] _indexOfInterest[121947])
        { scopeless
          (121944 yield i)
        }
        label _continueLabel[121952]
        _indexOfInterest[121947]
        _iterator[121948]
      }
      label _breakLabel[121953]
    }
  }
  function chpl_direct_range_iter[121981](arg low[121986] :
  (121984 call int[10] 16), arg high[121992] :
  (121990 call int[10] 16)) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[122011] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122012] "expr temp" "temp"
      (122021 'move' _iterator[122012](122019 call _getIterator(121999 call chpl_direct_param_stride_range_iter low high(122002 call : 1(122006 call int[10] 16)))))
      Defer
      {
        {
          (122036 call _freeIterator _iterator[122012])
        }
      }
      { scopeless type
        (122026 'move' _indexOfInterest[122011](122023 call iteratorIndex _iterator[122012]))
      }
      ForLoop[122013]
      {
        unknown i[121996] "index var" "insert auto destroy"
        (122031 'move' i[121996] _indexOfInterest[122011])
        { scopeless
          (122008 yield i)
        }
        label _continueLabel[122016]
        _indexOfInterest[122011]
        _iterator[122012]
      }
      label _breakLabel[122017]
    }
  }
  function chpl_direct_range_iter[122045](arg low[122050] :
  (122048 call int[10] 32), arg high[122056] :
  (122054 call int[10] 32)) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[122075] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122076] "expr temp" "temp"
      (122085 'move' _iterator[122076](122083 call _getIterator(122063 call chpl_direct_param_stride_range_iter low high(122066 call : 1(122070 call int[10] 32)))))
      Defer
      {
        {
          (122100 call _freeIterator _iterator[122076])
        }
      }
      { scopeless type
        (122090 'move' _indexOfInterest[122075](122087 call iteratorIndex _iterator[122076]))
      }
      ForLoop[122077]
      {
        unknown i[122060] "index var" "insert auto destroy"
        (122095 'move' i[122060] _indexOfInterest[122075])
        { scopeless
          (122072 yield i)
        }
        label _continueLabel[122080]
        _indexOfInterest[122075]
        _iterator[122076]
      }
      label _breakLabel[122081]
    }
  }
  function chpl_direct_range_iter[122109](arg low[122114] :
  (122112 call int[10] 64), arg high[122120] :
  (122118 call int[10] 64)) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[122139] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122140] "expr temp" "temp"
      (122149 'move' _iterator[122140](122147 call _getIterator(122127 call chpl_direct_param_stride_range_iter low high(122130 call : 1(122134 call int[10] 64)))))
      Defer
      {
        {
          (122164 call _freeIterator _iterator[122140])
        }
      }
      { scopeless type
        (122154 'move' _indexOfInterest[122139](122151 call iteratorIndex _iterator[122140]))
      }
      ForLoop[122141]
      {
        unknown i[122124] "index var" "insert auto destroy"
        (122159 'move' i[122124] _indexOfInterest[122139])
        { scopeless
          (122136 yield i)
        }
        label _continueLabel[122144]
        _indexOfInterest[122139]
        _iterator[122140]
      }
      label _breakLabel[122145]
    }
  }
  function chpl_direct_range_iter[122173](arg low[122178] :
  (122176 call uint[86] 8), arg high[122184] :
  (122182 call uint[86] 8)) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[122203] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122204] "expr temp" "temp"
      (122213 'move' _iterator[122204](122211 call _getIterator(122191 call chpl_direct_param_stride_range_iter low high(122194 call : 1(122198 call uint[86] 8)))))
      Defer
      {
        {
          (122228 call _freeIterator _iterator[122204])
        }
      }
      { scopeless type
        (122218 'move' _indexOfInterest[122203](122215 call iteratorIndex _iterator[122204]))
      }
      ForLoop[122205]
      {
        unknown i[122188] "index var" "insert auto destroy"
        (122223 'move' i[122188] _indexOfInterest[122203])
        { scopeless
          (122200 yield i)
        }
        label _continueLabel[122208]
        _indexOfInterest[122203]
        _iterator[122204]
      }
      label _breakLabel[122209]
    }
  }
  function chpl_direct_range_iter[122237](arg low[122242] :
  (122240 call uint[86] 16), arg high[122248] :
  (122246 call uint[86] 16)) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[122267] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122268] "expr temp" "temp"
      (122277 'move' _iterator[122268](122275 call _getIterator(122255 call chpl_direct_param_stride_range_iter low high(122258 call : 1(122262 call uint[86] 16)))))
      Defer
      {
        {
          (122292 call _freeIterator _iterator[122268])
        }
      }
      { scopeless type
        (122282 'move' _indexOfInterest[122267](122279 call iteratorIndex _iterator[122268]))
      }
      ForLoop[122269]
      {
        unknown i[122252] "index var" "insert auto destroy"
        (122287 'move' i[122252] _indexOfInterest[122267])
        { scopeless
          (122264 yield i)
        }
        label _continueLabel[122272]
        _indexOfInterest[122267]
        _iterator[122268]
      }
      label _breakLabel[122273]
    }
  }
  function chpl_direct_range_iter[122301](arg low[122306] :
  (122304 call uint[86] 32), arg high[122312] :
  (122310 call uint[86] 32)) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[122331] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122332] "expr temp" "temp"
      (122341 'move' _iterator[122332](122339 call _getIterator(122319 call chpl_direct_param_stride_range_iter low high(122322 call : 1(122326 call uint[86] 32)))))
      Defer
      {
        {
          (122356 call _freeIterator _iterator[122332])
        }
      }
      { scopeless type
        (122346 'move' _indexOfInterest[122331](122343 call iteratorIndex _iterator[122332]))
      }
      ForLoop[122333]
      {
        unknown i[122316] "index var" "insert auto destroy"
        (122351 'move' i[122316] _indexOfInterest[122331])
        { scopeless
          (122328 yield i)
        }
        label _continueLabel[122336]
        _indexOfInterest[122331]
        _iterator[122332]
      }
      label _breakLabel[122337]
    }
  }
  function chpl_direct_range_iter[122365](arg low[122370] :
  (122368 call uint[86] 64), arg high[122376] :
  (122374 call uint[86] 64)) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[122395] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122396] "expr temp" "temp"
      (122405 'move' _iterator[122396](122403 call _getIterator(122383 call chpl_direct_param_stride_range_iter low high(122386 call : 1(122390 call uint[86] 64)))))
      Defer
      {
        {
          (122420 call _freeIterator _iterator[122396])
        }
      }
      { scopeless type
        (122410 'move' _indexOfInterest[122395](122407 call iteratorIndex _iterator[122396]))
      }
      ForLoop[122397]
      {
        unknown i[122380] "index var" "insert auto destroy"
        (122415 'move' i[122380] _indexOfInterest[122395])
        { scopeless
          (122392 yield i)
        }
        label _continueLabel[122400]
        _indexOfInterest[122395]
        _iterator[122396]
      }
      label _breakLabel[122401]
    }
  }
  function chpl_direct_range_iter[122429](arg low[122432] :
  enum, arg high[122436] :
  enum) : _unknown[42] "iterator fn"
  {
    { scopeless
      const r[122441] "const"(122444 call chpl_build_bounded_range low high)
      (122447 'end of statement')
    }
    {
      unknown _indexOfInterest[122454] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122455] "expr temp" "temp"
      (122464 'move' _iterator[122455](122462 call _getIterator r))
      Defer
      {
        {
          (122479 call _freeIterator _iterator[122455])
        }
      }
      { scopeless type
        (122469 'move' _indexOfInterest[122454](122466 call iteratorIndex _iterator[122455]))
      }
      ForLoop[122456]
      {
        unknown i[122448] "index var" "insert auto destroy"
        (122474 'move' i[122448] _indexOfInterest[122454])
        { scopeless
          (122451 yield i)
        }
        label _continueLabel[122459]
        _indexOfInterest[122454]
        _iterator[122455]
      }
      label _breakLabel[122460]
    }
  }
  function chpl_direct_range_iter[122488](arg low[122491] :
  bool, arg high[122495] :
  bool) : _unknown[42] "iterator fn"
  {
    { scopeless
      const r[122500] "const"(122503 call chpl_build_bounded_range low high)
      (122506 'end of statement')
    }
    {
      unknown _indexOfInterest[122513] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122514] "expr temp" "temp"
      (122523 'move' _iterator[122514](122521 call _getIterator r))
      Defer
      {
        {
          (122538 call _freeIterator _iterator[122514])
        }
      }
      { scopeless type
        (122528 'move' _indexOfInterest[122513](122525 call iteratorIndex _iterator[122514]))
      }
      ForLoop[122515]
      {
        unknown i[122507] "index var" "insert auto destroy"
        (122533 'move' i[122507] _indexOfInterest[122513])
        { scopeless
          (122510 yield i)
        }
        label _continueLabel[122518]
        _indexOfInterest[122513]
        _iterator[122514]
      }
      label _breakLabel[122519]
    }
  }
  function chpl_direct_range_iter[122547](arg low[122549]:_any[141](?), arg high[122551]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    (122567 call chpl_build_bounded_range low high)
    (122571 call compilerError(122572 call +(122574 call +(122576 call +(122578 call + "Ranges defined using bounds of type '"(122581 call :(122584 'typeof' low) string[244])) "..")(122587 call :(122590 'typeof' high) string[244])) "' are not currently supported"))
  }
  where {
    (122553 call !(122555 call &&(122558 call chpl_isValidRangeIdxType(122560 'typeof' low))(122562 call chpl_isValidRangeIdxType(122564 'typeof' high))))
  }
  function chpl_direct_strided_range_iter[122596](param arg low[122599] :
  integral, param arg high[122603] :
  integral, arg stride[122607] :
  integral) : _unknown[42] "iterator fn"
  {
    unknown idxType[122612] "type variable"(122614 call computeParamRangeIndexType low high)
    { scopeless
      const r[122619] "const"(122620 call chpl_by(122630 call chpl_build_bounded_range(122622 call : low idxType)(122626 call : high idxType)) stride)
      (122634 'end of statement')
    }
    {
      unknown _indexOfInterest[122641] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122642] "expr temp" "temp"
      (122651 'move' _iterator[122642](122649 call _getIterator r))
      Defer
      {
        {
          (122666 call _freeIterator _iterator[122642])
        }
      }
      { scopeless type
        (122656 'move' _indexOfInterest[122641](122653 call iteratorIndex _iterator[122642]))
      }
      ForLoop[122643]
      {
        unknown i[122635] "index var" "insert auto destroy"
        (122661 'move' i[122635] _indexOfInterest[122641])
        { scopeless
          (122638 yield i)
        }
        label _continueLabel[122646]
        _indexOfInterest[122641]
        _iterator[122642]
      }
      label _breakLabel[122647]
    }
  }
  function chpl_direct_strided_range_iter[122675](arg low[122680] :
  (122678 call int[10] 8), arg high[122686] :
  (122684 call int[10] 8), arg stride[122690] :
  integral) : _unknown[42] "iterator fn"
  {
    { scopeless
      const r[122695] "const"(122696 call chpl_by(122700 call chpl_build_bounded_range low high) stride)
      (122704 'end of statement')
    }
    {
      unknown _indexOfInterest[122711] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122712] "expr temp" "temp"
      (122721 'move' _iterator[122712](122719 call _getIterator r))
      Defer
      {
        {
          (122736 call _freeIterator _iterator[122712])
        }
      }
      { scopeless type
        (122726 'move' _indexOfInterest[122711](122723 call iteratorIndex _iterator[122712]))
      }
      ForLoop[122713]
      {
        unknown i[122705] "index var" "insert auto destroy"
        (122731 'move' i[122705] _indexOfInterest[122711])
        { scopeless
          (122708 yield i)
        }
        label _continueLabel[122716]
        _indexOfInterest[122711]
        _iterator[122712]
      }
      label _breakLabel[122717]
    }
  }
  function chpl_direct_strided_range_iter[122745](arg low[122750] :
  (122748 call int[10] 16), arg high[122756] :
  (122754 call int[10] 16), arg stride[122760] :
  integral) : _unknown[42] "iterator fn"
  {
    { scopeless
      const r[122765] "const"(122766 call chpl_by(122770 call chpl_build_bounded_range low high) stride)
      (122774 'end of statement')
    }
    {
      unknown _indexOfInterest[122781] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122782] "expr temp" "temp"
      (122791 'move' _iterator[122782](122789 call _getIterator r))
      Defer
      {
        {
          (122806 call _freeIterator _iterator[122782])
        }
      }
      { scopeless type
        (122796 'move' _indexOfInterest[122781](122793 call iteratorIndex _iterator[122782]))
      }
      ForLoop[122783]
      {
        unknown i[122775] "index var" "insert auto destroy"
        (122801 'move' i[122775] _indexOfInterest[122781])
        { scopeless
          (122778 yield i)
        }
        label _continueLabel[122786]
        _indexOfInterest[122781]
        _iterator[122782]
      }
      label _breakLabel[122787]
    }
  }
  function chpl_direct_strided_range_iter[122815](arg low[122820] :
  (122818 call int[10] 32), arg high[122826] :
  (122824 call int[10] 32), arg stride[122830] :
  integral) : _unknown[42] "iterator fn"
  {
    { scopeless
      const r[122835] "const"(122836 call chpl_by(122840 call chpl_build_bounded_range low high) stride)
      (122844 'end of statement')
    }
    {
      unknown _indexOfInterest[122851] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122852] "expr temp" "temp"
      (122861 'move' _iterator[122852](122859 call _getIterator r))
      Defer
      {
        {
          (122876 call _freeIterator _iterator[122852])
        }
      }
      { scopeless type
        (122866 'move' _indexOfInterest[122851](122863 call iteratorIndex _iterator[122852]))
      }
      ForLoop[122853]
      {
        unknown i[122845] "index var" "insert auto destroy"
        (122871 'move' i[122845] _indexOfInterest[122851])
        { scopeless
          (122848 yield i)
        }
        label _continueLabel[122856]
        _indexOfInterest[122851]
        _iterator[122852]
      }
      label _breakLabel[122857]
    }
  }
  function chpl_direct_strided_range_iter[122885](arg low[122890] :
  (122888 call int[10] 64), arg high[122896] :
  (122894 call int[10] 64), arg stride[122900] :
  integral) : _unknown[42] "iterator fn"
  {
    { scopeless
      const r[122905] "const"(122906 call chpl_by(122910 call chpl_build_bounded_range low high) stride)
      (122914 'end of statement')
    }
    {
      unknown _indexOfInterest[122921] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122922] "expr temp" "temp"
      (122931 'move' _iterator[122922](122929 call _getIterator r))
      Defer
      {
        {
          (122946 call _freeIterator _iterator[122922])
        }
      }
      { scopeless type
        (122936 'move' _indexOfInterest[122921](122933 call iteratorIndex _iterator[122922]))
      }
      ForLoop[122923]
      {
        unknown i[122915] "index var" "insert auto destroy"
        (122941 'move' i[122915] _indexOfInterest[122921])
        { scopeless
          (122918 yield i)
        }
        label _continueLabel[122926]
        _indexOfInterest[122921]
        _iterator[122922]
      }
      label _breakLabel[122927]
    }
  }
  function chpl_direct_strided_range_iter[122955](arg low[122960] :
  (122958 call uint[86] 8), arg high[122966] :
  (122964 call uint[86] 8), arg stride[122970] :
  integral) : _unknown[42] "iterator fn"
  {
    { scopeless
      const r[122975] "const"(122976 call chpl_by(122980 call chpl_build_bounded_range low high) stride)
      (122984 'end of statement')
    }
    {
      unknown _indexOfInterest[122991] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122992] "expr temp" "temp"
      (123001 'move' _iterator[122992](122999 call _getIterator r))
      Defer
      {
        {
          (123016 call _freeIterator _iterator[122992])
        }
      }
      { scopeless type
        (123006 'move' _indexOfInterest[122991](123003 call iteratorIndex _iterator[122992]))
      }
      ForLoop[122993]
      {
        unknown i[122985] "index var" "insert auto destroy"
        (123011 'move' i[122985] _indexOfInterest[122991])
        { scopeless
          (122988 yield i)
        }
        label _continueLabel[122996]
        _indexOfInterest[122991]
        _iterator[122992]
      }
      label _breakLabel[122997]
    }
  }
  function chpl_direct_strided_range_iter[123025](arg low[123030] :
  (123028 call uint[86] 16), arg high[123036] :
  (123034 call uint[86] 16), arg stride[123040] :
  integral) : _unknown[42] "iterator fn"
  {
    { scopeless
      const r[123045] "const"(123046 call chpl_by(123050 call chpl_build_bounded_range low high) stride)
      (123054 'end of statement')
    }
    {
      unknown _indexOfInterest[123061] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123062] "expr temp" "temp"
      (123071 'move' _iterator[123062](123069 call _getIterator r))
      Defer
      {
        {
          (123086 call _freeIterator _iterator[123062])
        }
      }
      { scopeless type
        (123076 'move' _indexOfInterest[123061](123073 call iteratorIndex _iterator[123062]))
      }
      ForLoop[123063]
      {
        unknown i[123055] "index var" "insert auto destroy"
        (123081 'move' i[123055] _indexOfInterest[123061])
        { scopeless
          (123058 yield i)
        }
        label _continueLabel[123066]
        _indexOfInterest[123061]
        _iterator[123062]
      }
      label _breakLabel[123067]
    }
  }
  function chpl_direct_strided_range_iter[123095](arg low[123100] :
  (123098 call uint[86] 32), arg high[123106] :
  (123104 call uint[86] 32), arg stride[123110] :
  integral) : _unknown[42] "iterator fn"
  {
    { scopeless
      const r[123115] "const"(123116 call chpl_by(123120 call chpl_build_bounded_range low high) stride)
      (123124 'end of statement')
    }
    {
      unknown _indexOfInterest[123131] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123132] "expr temp" "temp"
      (123141 'move' _iterator[123132](123139 call _getIterator r))
      Defer
      {
        {
          (123156 call _freeIterator _iterator[123132])
        }
      }
      { scopeless type
        (123146 'move' _indexOfInterest[123131](123143 call iteratorIndex _iterator[123132]))
      }
      ForLoop[123133]
      {
        unknown i[123125] "index var" "insert auto destroy"
        (123151 'move' i[123125] _indexOfInterest[123131])
        { scopeless
          (123128 yield i)
        }
        label _continueLabel[123136]
        _indexOfInterest[123131]
        _iterator[123132]
      }
      label _breakLabel[123137]
    }
  }
  function chpl_direct_strided_range_iter[123165](arg low[123170] :
  (123168 call uint[86] 64), arg high[123176] :
  (123174 call uint[86] 64), arg stride[123180] :
  integral) : _unknown[42] "iterator fn"
  {
    { scopeless
      const r[123185] "const"(123186 call chpl_by(123190 call chpl_build_bounded_range low high) stride)
      (123194 'end of statement')
    }
    {
      unknown _indexOfInterest[123201] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123202] "expr temp" "temp"
      (123211 'move' _iterator[123202](123209 call _getIterator r))
      Defer
      {
        {
          (123226 call _freeIterator _iterator[123202])
        }
      }
      { scopeless type
        (123216 'move' _indexOfInterest[123201](123213 call iteratorIndex _iterator[123202]))
      }
      ForLoop[123203]
      {
        unknown i[123195] "index var" "insert auto destroy"
        (123221 'move' i[123195] _indexOfInterest[123201])
        { scopeless
          (123198 yield i)
        }
        label _continueLabel[123206]
        _indexOfInterest[123201]
        _iterator[123202]
      }
      label _breakLabel[123207]
    }
  }
  function chpl_direct_strided_range_iter[123235](arg low[123238] :
  enum, arg high[123242] :
  enum, arg stride[123246] :
  integral) : _unknown[42] "iterator fn"
  {
    { scopeless
      const r[123251] "const"(123252 call chpl_by(123256 call chpl_build_bounded_range low high) stride)
      (123260 'end of statement')
    }
    {
      unknown _indexOfInterest[123267] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123268] "expr temp" "temp"
      (123277 'move' _iterator[123268](123275 call _getIterator r))
      Defer
      {
        {
          (123292 call _freeIterator _iterator[123268])
        }
      }
      { scopeless type
        (123282 'move' _indexOfInterest[123267](123279 call iteratorIndex _iterator[123268]))
      }
      ForLoop[123269]
      {
        unknown i[123261] "index var" "insert auto destroy"
        (123287 'move' i[123261] _indexOfInterest[123267])
        { scopeless
          (123264 yield i)
        }
        label _continueLabel[123272]
        _indexOfInterest[123267]
        _iterator[123268]
      }
      label _breakLabel[123273]
    }
  }
  function chpl_direct_strided_range_iter[123301](arg low[123304] :
  bool, arg high[123308] :
  bool, arg stride[123312] :
  integral) : _unknown[42] "iterator fn"
  {
    { scopeless
      const r[123317] "const"(123318 call chpl_by(123322 call chpl_build_bounded_range low high) stride)
      (123326 'end of statement')
    }
    {
      unknown _indexOfInterest[123333] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123334] "expr temp" "temp"
      (123343 'move' _iterator[123334](123341 call _getIterator r))
      Defer
      {
        {
          (123358 call _freeIterator _iterator[123334])
        }
      }
      { scopeless type
        (123348 'move' _indexOfInterest[123333](123345 call iteratorIndex _iterator[123334]))
      }
      ForLoop[123335]
      {
        unknown i[123327] "index var" "insert auto destroy"
        (123353 'move' i[123327] _indexOfInterest[123333])
        { scopeless
          (123330 yield i)
        }
        label _continueLabel[123338]
        _indexOfInterest[123333]
        _iterator[123334]
      }
      label _breakLabel[123339]
    }
  }
  function chpl_direct_strided_range_iter[123367](param arg low[123370] :
  integral, param arg high[123374] :
  integral, param arg stride[123378] :
  integral) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[123392] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123393] "expr temp" "temp"
      (123402 'move' _iterator[123393](123400 call _getIterator(123385 call chpl_direct_param_stride_range_iter low high stride)))
      Defer
      {
        {
          (123417 call _freeIterator _iterator[123393])
        }
      }
      { scopeless type
        (123407 'move' _indexOfInterest[123392](123404 call iteratorIndex _iterator[123393]))
      }
      ForLoop[123394]
      {
        unknown i[123382] "index var" "insert auto destroy"
        (123412 'move' i[123382] _indexOfInterest[123392])
        { scopeless
          (123389 yield i)
        }
        label _continueLabel[123397]
        _indexOfInterest[123392]
        _iterator[123393]
      }
      label _breakLabel[123398]
    }
  }
  function chpl_direct_strided_range_iter[123426](arg low[123431] :
  (123429 call int[10] 8), arg high[123437] :
  (123435 call int[10] 8), param arg stride[123441] :
  integral) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[123455] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123456] "expr temp" "temp"
      (123465 'move' _iterator[123456](123463 call _getIterator(123448 call chpl_direct_param_stride_range_iter low high stride)))
      Defer
      {
        {
          (123480 call _freeIterator _iterator[123456])
        }
      }
      { scopeless type
        (123470 'move' _indexOfInterest[123455](123467 call iteratorIndex _iterator[123456]))
      }
      ForLoop[123457]
      {
        unknown i[123445] "index var" "insert auto destroy"
        (123475 'move' i[123445] _indexOfInterest[123455])
        { scopeless
          (123452 yield i)
        }
        label _continueLabel[123460]
        _indexOfInterest[123455]
        _iterator[123456]
      }
      label _breakLabel[123461]
    }
  }
  function chpl_direct_strided_range_iter[123489](arg low[123494] :
  (123492 call int[10] 16), arg high[123500] :
  (123498 call int[10] 16), param arg stride[123504] :
  integral) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[123518] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123519] "expr temp" "temp"
      (123528 'move' _iterator[123519](123526 call _getIterator(123511 call chpl_direct_param_stride_range_iter low high stride)))
      Defer
      {
        {
          (123543 call _freeIterator _iterator[123519])
        }
      }
      { scopeless type
        (123533 'move' _indexOfInterest[123518](123530 call iteratorIndex _iterator[123519]))
      }
      ForLoop[123520]
      {
        unknown i[123508] "index var" "insert auto destroy"
        (123538 'move' i[123508] _indexOfInterest[123518])
        { scopeless
          (123515 yield i)
        }
        label _continueLabel[123523]
        _indexOfInterest[123518]
        _iterator[123519]
      }
      label _breakLabel[123524]
    }
  }
  function chpl_direct_strided_range_iter[123552](arg low[123557] :
  (123555 call int[10] 32), arg high[123563] :
  (123561 call int[10] 32), param arg stride[123567] :
  integral) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[123581] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123582] "expr temp" "temp"
      (123591 'move' _iterator[123582](123589 call _getIterator(123574 call chpl_direct_param_stride_range_iter low high stride)))
      Defer
      {
        {
          (123606 call _freeIterator _iterator[123582])
        }
      }
      { scopeless type
        (123596 'move' _indexOfInterest[123581](123593 call iteratorIndex _iterator[123582]))
      }
      ForLoop[123583]
      {
        unknown i[123571] "index var" "insert auto destroy"
        (123601 'move' i[123571] _indexOfInterest[123581])
        { scopeless
          (123578 yield i)
        }
        label _continueLabel[123586]
        _indexOfInterest[123581]
        _iterator[123582]
      }
      label _breakLabel[123587]
    }
  }
  function chpl_direct_strided_range_iter[123615](arg low[123620] :
  (123618 call int[10] 64), arg high[123626] :
  (123624 call int[10] 64), param arg stride[123630] :
  integral) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[123644] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123645] "expr temp" "temp"
      (123654 'move' _iterator[123645](123652 call _getIterator(123637 call chpl_direct_param_stride_range_iter low high stride)))
      Defer
      {
        {
          (123669 call _freeIterator _iterator[123645])
        }
      }
      { scopeless type
        (123659 'move' _indexOfInterest[123644](123656 call iteratorIndex _iterator[123645]))
      }
      ForLoop[123646]
      {
        unknown i[123634] "index var" "insert auto destroy"
        (123664 'move' i[123634] _indexOfInterest[123644])
        { scopeless
          (123641 yield i)
        }
        label _continueLabel[123649]
        _indexOfInterest[123644]
        _iterator[123645]
      }
      label _breakLabel[123650]
    }
  }
  function chpl_direct_strided_range_iter[123678](arg low[123683] :
  (123681 call uint[86] 8), arg high[123689] :
  (123687 call uint[86] 8), param arg stride[123693] :
  integral) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[123707] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123708] "expr temp" "temp"
      (123717 'move' _iterator[123708](123715 call _getIterator(123700 call chpl_direct_param_stride_range_iter low high stride)))
      Defer
      {
        {
          (123732 call _freeIterator _iterator[123708])
        }
      }
      { scopeless type
        (123722 'move' _indexOfInterest[123707](123719 call iteratorIndex _iterator[123708]))
      }
      ForLoop[123709]
      {
        unknown i[123697] "index var" "insert auto destroy"
        (123727 'move' i[123697] _indexOfInterest[123707])
        { scopeless
          (123704 yield i)
        }
        label _continueLabel[123712]
        _indexOfInterest[123707]
        _iterator[123708]
      }
      label _breakLabel[123713]
    }
  }
  function chpl_direct_strided_range_iter[123741](arg low[123746] :
  (123744 call uint[86] 16), arg high[123752] :
  (123750 call uint[86] 16), param arg stride[123756] :
  integral) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[123770] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123771] "expr temp" "temp"
      (123780 'move' _iterator[123771](123778 call _getIterator(123763 call chpl_direct_param_stride_range_iter low high stride)))
      Defer
      {
        {
          (123795 call _freeIterator _iterator[123771])
        }
      }
      { scopeless type
        (123785 'move' _indexOfInterest[123770](123782 call iteratorIndex _iterator[123771]))
      }
      ForLoop[123772]
      {
        unknown i[123760] "index var" "insert auto destroy"
        (123790 'move' i[123760] _indexOfInterest[123770])
        { scopeless
          (123767 yield i)
        }
        label _continueLabel[123775]
        _indexOfInterest[123770]
        _iterator[123771]
      }
      label _breakLabel[123776]
    }
  }
  function chpl_direct_strided_range_iter[123804](arg low[123809] :
  (123807 call uint[86] 32), arg high[123815] :
  (123813 call uint[86] 32), param arg stride[123819] :
  integral) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[123833] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123834] "expr temp" "temp"
      (123843 'move' _iterator[123834](123841 call _getIterator(123826 call chpl_direct_param_stride_range_iter low high stride)))
      Defer
      {
        {
          (123858 call _freeIterator _iterator[123834])
        }
      }
      { scopeless type
        (123848 'move' _indexOfInterest[123833](123845 call iteratorIndex _iterator[123834]))
      }
      ForLoop[123835]
      {
        unknown i[123823] "index var" "insert auto destroy"
        (123853 'move' i[123823] _indexOfInterest[123833])
        { scopeless
          (123830 yield i)
        }
        label _continueLabel[123838]
        _indexOfInterest[123833]
        _iterator[123834]
      }
      label _breakLabel[123839]
    }
  }
  function chpl_direct_strided_range_iter[123867](arg low[123872] :
  (123870 call uint[86] 64), arg high[123878] :
  (123876 call uint[86] 64), param arg stride[123882] :
  integral) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[123896] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123897] "expr temp" "temp"
      (123906 'move' _iterator[123897](123904 call _getIterator(123889 call chpl_direct_param_stride_range_iter low high stride)))
      Defer
      {
        {
          (123921 call _freeIterator _iterator[123897])
        }
      }
      { scopeless type
        (123911 'move' _indexOfInterest[123896](123908 call iteratorIndex _iterator[123897]))
      }
      ForLoop[123898]
      {
        unknown i[123886] "index var" "insert auto destroy"
        (123916 'move' i[123886] _indexOfInterest[123896])
        { scopeless
          (123893 yield i)
        }
        label _continueLabel[123901]
        _indexOfInterest[123896]
        _iterator[123897]
      }
      label _breakLabel[123902]
    }
  }
  function chpl_direct_strided_range_iter[123930](arg low[123933] :
  enum, arg high[123937] :
  enum, param arg stride[123941] :
  integral) : _unknown[42] "iterator fn"
  {
    if(124046 call _cond_test(124042 call == stride 1))
    {
      { scopeless
        const r[123947] "const"(123950 call chpl_build_bounded_range low high)
        (123953 'end of statement')
      }
      {
        unknown _indexOfInterest[123960] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[123961] "expr temp" "temp"
        (123970 'move' _iterator[123961](123968 call _getIterator r))
        Defer
        {
          {
            (123985 call _freeIterator _iterator[123961])
          }
        }
        { scopeless type
          (123975 'move' _indexOfInterest[123960](123972 call iteratorIndex _iterator[123961]))
        }
        ForLoop[123962]
        {
          unknown i[123954] "index var" "insert auto destroy"
          (123980 'move' i[123954] _indexOfInterest[123960])
          { scopeless
            (123957 yield i)
          }
          label _continueLabel[123965]
          _indexOfInterest[123960]
          _iterator[123961]
        }
        label _breakLabel[123966]
      }
    }
    {
      { scopeless
        const r[123994] "const"(123995 call chpl_by(123999 call chpl_build_bounded_range low high) stride)
        (124003 'end of statement')
      }
      {
        unknown _indexOfInterest[124010] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[124011] "expr temp" "temp"
        (124020 'move' _iterator[124011](124018 call _getIterator r))
        Defer
        {
          {
            (124035 call _freeIterator _iterator[124011])
          }
        }
        { scopeless type
          (124025 'move' _indexOfInterest[124010](124022 call iteratorIndex _iterator[124011]))
        }
        ForLoop[124012]
        {
          unknown i[124004] "index var" "insert auto destroy"
          (124030 'move' i[124004] _indexOfInterest[124010])
          { scopeless
            (124007 yield i)
          }
          label _continueLabel[124015]
          _indexOfInterest[124010]
          _iterator[124011]
        }
        label _breakLabel[124016]
      }
    }
  }
  function chpl_direct_strided_range_iter[124052](arg low[124055] :
  bool, arg high[124059] :
  bool, param arg stride[124063] :
  integral) : _unknown[42] "iterator fn"
  {
    if(124168 call _cond_test(124164 call == stride 1))
    {
      { scopeless
        const r[124069] "const"(124072 call chpl_build_bounded_range low high)
        (124075 'end of statement')
      }
      {
        unknown _indexOfInterest[124082] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[124083] "expr temp" "temp"
        (124092 'move' _iterator[124083](124090 call _getIterator r))
        Defer
        {
          {
            (124107 call _freeIterator _iterator[124083])
          }
        }
        { scopeless type
          (124097 'move' _indexOfInterest[124082](124094 call iteratorIndex _iterator[124083]))
        }
        ForLoop[124084]
        {
          unknown i[124076] "index var" "insert auto destroy"
          (124102 'move' i[124076] _indexOfInterest[124082])
          { scopeless
            (124079 yield i)
          }
          label _continueLabel[124087]
          _indexOfInterest[124082]
          _iterator[124083]
        }
        label _breakLabel[124088]
      }
    }
    {
      { scopeless
        const r[124116] "const"(124117 call chpl_by(124121 call chpl_build_bounded_range low high) stride)
        (124125 'end of statement')
      }
      {
        unknown _indexOfInterest[124132] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[124133] "expr temp" "temp"
        (124142 'move' _iterator[124133](124140 call _getIterator r))
        Defer
        {
          {
            (124157 call _freeIterator _iterator[124133])
          }
        }
        { scopeless type
          (124147 'move' _indexOfInterest[124132](124144 call iteratorIndex _iterator[124133]))
        }
        ForLoop[124134]
        {
          unknown i[124126] "index var" "insert auto destroy"
          (124152 'move' i[124126] _indexOfInterest[124132])
          { scopeless
            (124129 yield i)
          }
          label _continueLabel[124137]
          _indexOfInterest[124132]
          _iterator[124133]
        }
        label _breakLabel[124138]
      }
    }
  }
  function chpl_direct_strided_range_iter[124174](arg low[124179] :
  (124177 call int[10] 8), arg high[124185] :
  (124183 call int[10] 8), arg stride[124192] :
  (124189 call uint[86] unknown w2[124190])) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[124206] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124207] "expr temp" "temp"
      (124216 'move' _iterator[124207](124214 call _getIterator(124199 call chpl_direct_pos_stride_range_iter low high stride)))
      Defer
      {
        {
          (124231 call _freeIterator _iterator[124207])
        }
      }
      { scopeless type
        (124221 'move' _indexOfInterest[124206](124218 call iteratorIndex _iterator[124207]))
      }
      ForLoop[124208]
      {
        unknown i[124196] "index var" "insert auto destroy"
        (124226 'move' i[124196] _indexOfInterest[124206])
        { scopeless
          (124203 yield i)
        }
        label _continueLabel[124211]
        _indexOfInterest[124206]
        _iterator[124207]
      }
      label _breakLabel[124212]
    }
  }
  function chpl_direct_strided_range_iter[124240](arg low[124245] :
  (124243 call int[10] 16), arg high[124251] :
  (124249 call int[10] 16), arg stride[124258] :
  (124255 call uint[86] unknown w2[124256])) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[124272] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124273] "expr temp" "temp"
      (124282 'move' _iterator[124273](124280 call _getIterator(124265 call chpl_direct_pos_stride_range_iter low high stride)))
      Defer
      {
        {
          (124297 call _freeIterator _iterator[124273])
        }
      }
      { scopeless type
        (124287 'move' _indexOfInterest[124272](124284 call iteratorIndex _iterator[124273]))
      }
      ForLoop[124274]
      {
        unknown i[124262] "index var" "insert auto destroy"
        (124292 'move' i[124262] _indexOfInterest[124272])
        { scopeless
          (124269 yield i)
        }
        label _continueLabel[124277]
        _indexOfInterest[124272]
        _iterator[124273]
      }
      label _breakLabel[124278]
    }
  }
  function chpl_direct_strided_range_iter[124306](arg low[124311] :
  (124309 call int[10] 32), arg high[124317] :
  (124315 call int[10] 32), arg stride[124324] :
  (124321 call uint[86] unknown w2[124322])) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[124338] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124339] "expr temp" "temp"
      (124348 'move' _iterator[124339](124346 call _getIterator(124331 call chpl_direct_pos_stride_range_iter low high stride)))
      Defer
      {
        {
          (124363 call _freeIterator _iterator[124339])
        }
      }
      { scopeless type
        (124353 'move' _indexOfInterest[124338](124350 call iteratorIndex _iterator[124339]))
      }
      ForLoop[124340]
      {
        unknown i[124328] "index var" "insert auto destroy"
        (124358 'move' i[124328] _indexOfInterest[124338])
        { scopeless
          (124335 yield i)
        }
        label _continueLabel[124343]
        _indexOfInterest[124338]
        _iterator[124339]
      }
      label _breakLabel[124344]
    }
  }
  function chpl_direct_strided_range_iter[124372](arg low[124377] :
  (124375 call int[10] 64), arg high[124383] :
  (124381 call int[10] 64), arg stride[124390] :
  (124387 call uint[86] unknown w2[124388])) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[124404] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124405] "expr temp" "temp"
      (124414 'move' _iterator[124405](124412 call _getIterator(124397 call chpl_direct_pos_stride_range_iter low high stride)))
      Defer
      {
        {
          (124429 call _freeIterator _iterator[124405])
        }
      }
      { scopeless type
        (124419 'move' _indexOfInterest[124404](124416 call iteratorIndex _iterator[124405]))
      }
      ForLoop[124406]
      {
        unknown i[124394] "index var" "insert auto destroy"
        (124424 'move' i[124394] _indexOfInterest[124404])
        { scopeless
          (124401 yield i)
        }
        label _continueLabel[124409]
        _indexOfInterest[124404]
        _iterator[124405]
      }
      label _breakLabel[124410]
    }
  }
  function chpl_direct_strided_range_iter[124438](arg low[124443] :
  (124441 call uint[86] 8), arg high[124449] :
  (124447 call uint[86] 8), arg stride[124456] :
  (124453 call uint[86] unknown w2[124454])) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[124470] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124471] "expr temp" "temp"
      (124480 'move' _iterator[124471](124478 call _getIterator(124463 call chpl_direct_pos_stride_range_iter low high stride)))
      Defer
      {
        {
          (124495 call _freeIterator _iterator[124471])
        }
      }
      { scopeless type
        (124485 'move' _indexOfInterest[124470](124482 call iteratorIndex _iterator[124471]))
      }
      ForLoop[124472]
      {
        unknown i[124460] "index var" "insert auto destroy"
        (124490 'move' i[124460] _indexOfInterest[124470])
        { scopeless
          (124467 yield i)
        }
        label _continueLabel[124475]
        _indexOfInterest[124470]
        _iterator[124471]
      }
      label _breakLabel[124476]
    }
  }
  function chpl_direct_strided_range_iter[124504](arg low[124509] :
  (124507 call uint[86] 16), arg high[124515] :
  (124513 call uint[86] 16), arg stride[124522] :
  (124519 call uint[86] unknown w2[124520])) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[124536] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124537] "expr temp" "temp"
      (124546 'move' _iterator[124537](124544 call _getIterator(124529 call chpl_direct_pos_stride_range_iter low high stride)))
      Defer
      {
        {
          (124561 call _freeIterator _iterator[124537])
        }
      }
      { scopeless type
        (124551 'move' _indexOfInterest[124536](124548 call iteratorIndex _iterator[124537]))
      }
      ForLoop[124538]
      {
        unknown i[124526] "index var" "insert auto destroy"
        (124556 'move' i[124526] _indexOfInterest[124536])
        { scopeless
          (124533 yield i)
        }
        label _continueLabel[124541]
        _indexOfInterest[124536]
        _iterator[124537]
      }
      label _breakLabel[124542]
    }
  }
  function chpl_direct_strided_range_iter[124570](arg low[124575] :
  (124573 call uint[86] 32), arg high[124581] :
  (124579 call uint[86] 32), arg stride[124588] :
  (124585 call uint[86] unknown w2[124586])) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[124602] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124603] "expr temp" "temp"
      (124612 'move' _iterator[124603](124610 call _getIterator(124595 call chpl_direct_pos_stride_range_iter low high stride)))
      Defer
      {
        {
          (124627 call _freeIterator _iterator[124603])
        }
      }
      { scopeless type
        (124617 'move' _indexOfInterest[124602](124614 call iteratorIndex _iterator[124603]))
      }
      ForLoop[124604]
      {
        unknown i[124592] "index var" "insert auto destroy"
        (124622 'move' i[124592] _indexOfInterest[124602])
        { scopeless
          (124599 yield i)
        }
        label _continueLabel[124607]
        _indexOfInterest[124602]
        _iterator[124603]
      }
      label _breakLabel[124608]
    }
  }
  function chpl_direct_strided_range_iter[124636](arg low[124641] :
  (124639 call uint[86] 64), arg high[124647] :
  (124645 call uint[86] 64), arg stride[124654] :
  (124651 call uint[86] unknown w2[124652])) : _unknown[42] "iterator fn"
  {
    {
      unknown _indexOfInterest[124668] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124669] "expr temp" "temp"
      (124678 'move' _iterator[124669](124676 call _getIterator(124661 call chpl_direct_pos_stride_range_iter low high stride)))
      Defer
      {
        {
          (124693 call _freeIterator _iterator[124669])
        }
      }
      { scopeless type
        (124683 'move' _indexOfInterest[124668](124680 call iteratorIndex _iterator[124669]))
      }
      ForLoop[124670]
      {
        unknown i[124658] "index var" "insert auto destroy"
        (124688 'move' i[124658] _indexOfInterest[124668])
        { scopeless
          (124665 yield i)
        }
        label _continueLabel[124673]
        _indexOfInterest[124668]
        _iterator[124669]
      }
      label _breakLabel[124674]
    }
  }
  function chpl_direct_strided_range_iter[124702](arg low[124707] :
  (124705 call int[10] 8), arg high[124713] :
  (124711 call int[10] 8), arg stride[124716]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    (124720 call compilerError "can't apply 'by' to a range with idxType "(124724 call :(124727 call int[10] 8) string[244]) " using a step of type "(124733 call :(124736 'typeof' stride) string[244]))
  }
  function chpl_direct_strided_range_iter[124740](arg low[124745] :
  (124743 call int[10] 16), arg high[124751] :
  (124749 call int[10] 16), arg stride[124754]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    (124758 call compilerError "can't apply 'by' to a range with idxType "(124760 call :(124763 call int[10] 16) string[244]) " using a step of type "(124767 call :(124770 'typeof' stride) string[244]))
  }
  function chpl_direct_strided_range_iter[124774](arg low[124779] :
  (124777 call int[10] 32), arg high[124785] :
  (124783 call int[10] 32), arg stride[124788]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    (124792 call compilerError "can't apply 'by' to a range with idxType "(124794 call :(124797 call int[10] 32) string[244]) " using a step of type "(124801 call :(124804 'typeof' stride) string[244]))
  }
  function chpl_direct_strided_range_iter[124808](arg low[124813] :
  (124811 call int[10] 64), arg high[124819] :
  (124817 call int[10] 64), arg stride[124822]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    (124826 call compilerError "can't apply 'by' to a range with idxType "(124828 call :(124831 call int[10] 64) string[244]) " using a step of type "(124835 call :(124838 'typeof' stride) string[244]))
  }
  function chpl_direct_strided_range_iter[124842](arg low[124847] :
  (124845 call uint[86] 8), arg high[124853] :
  (124851 call uint[86] 8), arg stride[124856]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    (124860 call compilerError "can't apply 'by' to a range with idxType "(124862 call :(124865 call uint[86] 8) string[244]) " using a step of type "(124869 call :(124872 'typeof' stride) string[244]))
  }
  function chpl_direct_strided_range_iter[124876](arg low[124881] :
  (124879 call uint[86] 16), arg high[124887] :
  (124885 call uint[86] 16), arg stride[124890]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    (124894 call compilerError "can't apply 'by' to a range with idxType "(124896 call :(124899 call uint[86] 16) string[244]) " using a step of type "(124903 call :(124906 'typeof' stride) string[244]))
  }
  function chpl_direct_strided_range_iter[124910](arg low[124915] :
  (124913 call uint[86] 32), arg high[124921] :
  (124919 call uint[86] 32), arg stride[124924]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    (124928 call compilerError "can't apply 'by' to a range with idxType "(124930 call :(124933 call uint[86] 32) string[244]) " using a step of type "(124937 call :(124940 'typeof' stride) string[244]))
  }
  function chpl_direct_strided_range_iter[124944](arg low[124949] :
  (124947 call uint[86] 64), arg high[124955] :
  (124953 call uint[86] 64), arg stride[124958]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    (124962 call compilerError "can't apply 'by' to a range with idxType "(124964 call :(124967 call uint[86] 64) string[244]) " using a step of type "(124971 call :(124974 'typeof' stride) string[244]))
  }
  function chpl_direct_strided_range_iter[124978](arg low[124980]:_any[141](?), arg high[124982]:_any[141](?), arg stride[124984]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    (125000 call chpl_build_bounded_range low high stride)
    if(125070 call _cond_test(125064 call ==(125067 'typeof' low)(125069 'typeof' high)))
    {
      { scopeless
        (125005 call compilerError(125006 call +(125008 call +(125010 call +(125012 call + "Ranges defined using bounds of type '"(125015 call :(125018 'typeof' low) string[244])) "' and strides of type '")(125023 call :(125026 'typeof' stride) string[244])) "' are not currently supported"))
      }
    }
    {
      { scopeless
        (125031 call compilerError(125032 call +(125034 call +(125036 call +(125038 call +(125040 call +(125042 call + "Ranges defined using bounds of type '"(125045 call :(125048 'typeof' low) string[244])) "..")(125051 call :(125054 'typeof' high) string[244])) "' and strides of type '")(125057 call :(125060 'typeof' stride) string[244])) "' are not currently supported"))
      }
    }
  }
  where {
    (124986 call !(124988 call &&(124991 call chpl_isValidRangeIdxType(124993 'typeof' low))(124995 call chpl_isValidRangeIdxType(124997 'typeof' high))))
  }
  function chpl_direct_counted_range_iter[125079](arg low[125085] :
  (125082 call int[10] unknown w[125083]), arg count[125088]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    if(125118 call _cond_test(125106 call &&(125108 call !(125111 call isIntegral count))(125113 call !(125116 call isBool count))))
    {
      (125093 call compilerError "can't apply '#' to a range with idxType "(125095 call :(125098 'typeof' low) string[244]) " using a count of type "(125101 call :(125104 'typeof' count) string[244]))
    }
    {
      unknown _indexOfInterest[125131] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[125132] "expr temp" "temp"
      (125141 'move' _iterator[125132](125139 call _getIterator(125125 call chpl_direct_counted_range_iter_helper low count)))
      Defer
      {
        {
          (125156 call _freeIterator _iterator[125132])
        }
      }
      { scopeless type
        (125146 'move' _indexOfInterest[125131](125143 call iteratorIndex _iterator[125132]))
      }
      ForLoop[125133]
      {
        unknown i[125122] "index var" "insert auto destroy"
        (125151 'move' i[125122] _indexOfInterest[125131])
        { scopeless
          (125128 yield i)
        }
        label _continueLabel[125136]
        _indexOfInterest[125131]
        _iterator[125132]
      }
      label _breakLabel[125137]
    }
  }
  function chpl_direct_counted_range_iter[125165](arg low[125171] :
  (125168 call uint[86] unknown w[125169]), arg count[125174]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    if(125204 call _cond_test(125192 call &&(125194 call !(125197 call isIntegral count))(125199 call !(125202 call isBool count))))
    {
      (125179 call compilerError "can't apply '#' to a range with idxType "(125181 call :(125184 'typeof' low) string[244]) " using a count of type "(125187 call :(125190 'typeof' count) string[244]))
    }
    {
      unknown _indexOfInterest[125217] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[125218] "expr temp" "temp"
      (125227 'move' _iterator[125218](125225 call _getIterator(125211 call chpl_direct_counted_range_iter_helper low count)))
      Defer
      {
        {
          (125242 call _freeIterator _iterator[125218])
        }
      }
      { scopeless type
        (125232 'move' _indexOfInterest[125217](125229 call iteratorIndex _iterator[125218]))
      }
      ForLoop[125219]
      {
        unknown i[125208] "index var" "insert auto destroy"
        (125237 'move' i[125208] _indexOfInterest[125217])
        { scopeless
          (125214 yield i)
        }
        label _continueLabel[125222]
        _indexOfInterest[125217]
        _iterator[125218]
      }
      label _breakLabel[125223]
    }
  }
  function chpl_direct_counted_range_iter[125251](arg low[125254] :
  enum, arg count[125258] :
  integral) : _unknown[42] "iterator fn"
  {
    { scopeless
      const r[125263] "const"(125265 call chpl_build_low_bounded_range low)
      (125268 'end of statement')
    }
    {
      unknown _indexOfInterest[125278] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[125279] "expr temp" "temp"
      (125288 'move' _iterator[125279](125286 call _getIterator(125271 call # r count)))
      Defer
      {
        {
          (125305 call _freeIterator _iterator[125279])
        }
      }
      { scopeless type
        (125295 'move' _indexOfInterest[125278](125292 call iteratorIndex _iterator[125279]))
      }
      ForLoop[125280]
      {
        unknown i[125269] "index var" "insert auto destroy"
        (125300 'move' i[125269] _indexOfInterest[125278])
        { scopeless
          (125275 yield i)
        }
        label _continueLabel[125283]
        _indexOfInterest[125278]
        _iterator[125279]
      }
      label _breakLabel[125284]
    }
  }
  function chpl_direct_counted_range_iter[125314](arg low[125317] :
  bool, arg count[125321] :
  integral) : _unknown[42] "iterator fn"
  {
    { scopeless
      const r[125326] "const"(125328 call chpl_build_low_bounded_range low)
      (125331 'end of statement')
    }
    {
      unknown _indexOfInterest[125341] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[125342] "expr temp" "temp"
      (125351 'move' _iterator[125342](125349 call _getIterator(125334 call # r count)))
      Defer
      {
        {
          (125368 call _freeIterator _iterator[125342])
        }
      }
      { scopeless type
        (125358 'move' _indexOfInterest[125341](125355 call iteratorIndex _iterator[125342]))
      }
      ForLoop[125343]
      {
        unknown i[125332] "index var" "insert auto destroy"
        (125363 'move' i[125332] _indexOfInterest[125341])
        { scopeless
          (125338 yield i)
        }
        label _continueLabel[125346]
        _indexOfInterest[125341]
        _iterator[125342]
      }
      label _breakLabel[125347]
    }
  }
  function chpl_direct_counted_range_iter[125377](arg low[125379]:_any[141](?), arg count[125381]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    (125397 call chpl_build_low_bounded_range low)
    (125400 call compilerError "can't apply '#' to a range with idxType "(125402 call :(125405 'typeof' low) string[244]) " using a count of type "(125408 call :(125411 'typeof' count) string[244]))
  }
  where {
    (125383 call !(125385 call &&(125388 call chpl_isValidRangeIdxType(125390 'typeof' low))(125392 call chpl_isValidRangeIdxType(125394 'typeof' count))))
  }
  function chpl_direct_counted_range_iter_helper[125416](arg low[125418]:_any[141](?), arg count[125420]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    if(125443 call _cond_test(125430 call &&(125432 call && boundsChecking(125436 call isIntType(125438 'typeof' count)))(125439 call < count 0)))
    {
      { scopeless
        (125427 call(125424 call . HaltWrappers c"boundsCheckHalt") "With a negative count, the range must have a last index.")
      }
    }
    { scopeless
      const start[125449] "const" low
      (125452 'end of statement')
    }
    { scopeless
      const end[125454] "const"(125485 IfExpr (125455 call == count 0) then
      { scopeless
        (125459 call :(125461 call -(125463 call : low uint[86]) 1)(125469 'typeof' low))
      } else
      { scopeless
        (125470 call :(125472 call + low(125475 call -(125477 call : count(125481 'typeof' low)) 1))(125484 'typeof' low))
      } )
      (125489 'end of statement')
    }
    {
      unknown _indexOfInterest[125500] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[125501] "expr temp" "temp"
      (125510 'move' _iterator[125501](125508 call _getIterator(125493 call chpl_direct_param_stride_range_iter start end 1)))
      Defer
      {
        {
          (125525 call _freeIterator _iterator[125501])
        }
      }
      { scopeless type
        (125515 'move' _indexOfInterest[125500](125512 call iteratorIndex _iterator[125501]))
      }
      ForLoop[125502]
      {
        unknown i[125490] "index var" "insert auto destroy"
        (125520 'move' i[125490] _indexOfInterest[125500])
        { scopeless
          (125497 yield i)
        }
        label _continueLabel[125505]
        _indexOfInterest[125500]
        _iterator[125501]
      }
      label _breakLabel[125506]
    }
  }
  function chpl_direct_pos_stride_range_iter[125534](arg low[125538] :
  unknown t[125536], arg high[125541]:_any[141](?), arg stride[125543]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    if(125658 call _cond_test useOptimizedRangeIterators)
    {
      (125548 call chpl_range_check_stride stride t)
      if(125559 call _cond_test boundsChecking)
      {
        { scopeless
          (125552 call chpl_checkIfRangeIterWillOverflow t low high stride)
        }
      }
      { scopeless
        unknown i[125565] t
        (125568 'end of statement')
      }
      { scopeless
        CForLoop[125586]
        {
          {
            (125583 yield i)
          }
          label _continueLabel[125602]
          {
            (125587 '=' i low)
          }
          {
            (125590 '<=' i high)
          }
          {
            (125593 '+=' i(125596 call : stride t))
          }
        }
        label _breakLabel[125603]
      }
    }
    {
      {
        unknown _indexOfInterest[125625] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[125626] "expr temp" "temp"
        (125635 'move' _iterator[125626](125633 call _getIterator(125621 call(125618 call .(125609 call chpl_by(125613 call chpl_build_bounded_range low high) stride) c"generalIterator"))))
        Defer
        {
          {
            (125650 call _freeIterator _iterator[125626])
          }
        }
        { scopeless type
          (125640 'move' _indexOfInterest[125625](125637 call iteratorIndex _iterator[125626]))
        }
        ForLoop[125627]
        {
          unknown i[125607] "index var" "insert auto destroy"
          (125645 'move' i[125607] _indexOfInterest[125625])
          { scopeless
            (125622 yield i)
          }
          label _continueLabel[125630]
          _indexOfInterest[125625]
          _iterator[125626]
        }
        label _breakLabel[125631]
      }
    }
  }
  function chpl_direct_param_stride_range_iter[125664](arg low[125668] :
  unknown t[125666], arg high[125671]:_any[141](?), param arg stride[125673]:_any[141](?)) : _unknown[42] "iterator fn"
  {
    if(125857 call _cond_test useOptimizedRangeIterators)
    {
      (125678 call chpl_range_check_stride stride t)
      { scopeless
        unknown i[125682] t
        (125685 'end of statement')
      }
      if(125802 call _cond_test(125798 call > stride 0))
      {
        if(125695 call _cond_test boundsChecking)
        {
          { scopeless
            (125688 call chpl_checkIfRangeIterWillOverflow t low high stride)
          }
        }
        { scopeless
          CForLoop[125717]
          {
            {
              (125714 yield i)
            }
            label _continueLabel[125733]
            {
              (125718 '=' i low)
            }
            {
              (125721 '<=' i high)
            }
            {
              (125724 '+=' i(125727 call : stride t))
            }
          }
          label _breakLabel[125734]
        }
      }
      {
        { scopeless
          if(125794 call _cond_test(125790 call < stride 0))
          {
            if(125748 call _cond_test boundsChecking)
            {
              { scopeless
                (125739 call chpl_checkIfRangeIterWillOverflow t low high stride high low)
              }
            }
            { scopeless
              CForLoop[125770]
              {
                {
                  (125767 yield i)
                }
                label _continueLabel[125786]
                {
                  (125771 '=' i high)
                }
                {
                  (125774 '>=' i low)
                }
                {
                  (125777 '+=' i(125780 call : stride t))
                }
              }
              label _breakLabel[125787]
            }
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[125824] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[125825] "expr temp" "temp"
        (125834 'move' _iterator[125825](125832 call _getIterator(125820 call(125817 call .(125810 call chpl_by(125814 call chpl_build_bounded_range low high) stride) c"generalIterator"))))
        Defer
        {
          {
            (125849 call _freeIterator _iterator[125825])
          }
        }
        { scopeless type
          (125839 'move' _indexOfInterest[125824](125836 call iteratorIndex _iterator[125825]))
        }
        ForLoop[125826]
        {
          unknown i[125808] "index var" "insert auto destroy"
          (125844 'move' i[125808] _indexOfInterest[125824])
          { scopeless
            (125821 yield i)
          }
          label _continueLabel[125829]
          _indexOfInterest[125824]
          _iterator[125825]
        }
        label _breakLabel[125830]
      }
    }
  }
  function _unknown[42].these[125863](arg _mt[125869]:_MT[201], arg this[125866] :
  range) : _unknown[42] "iterator fn" "method" "order independent yielding loops"
  {
    (125886 call compilerError "iteration over a range with no bounds")
  }
  where {
    (125872 call &&(125874 call !(125877 call hasLowBoundForIter this))(125879 call !(125882 call hasHighBoundForIter this)))
  }
  { scopeless type
    nothing
  }
  function boundsCheckUnboundedRange[125894](arg r[125899] :
  (125897 call range ?[227])) : _unknown[42] "inline" "private"
  {
    if(125943 call _cond_test boundsChecking)
    {
      if(125920 call _cond_test(125913 call !(125919 call(125916 call . r c"hasFirstForIter"))))
      {
        { scopeless
          (125908 call(125905 call . HaltWrappers c"boundsCheckHalt") "iteration over range that has no first index")
        }
      }
      if(125937 call _cond_test(125935 call hasAmbiguousAlignmentForIter r))
      {
        { scopeless
          (125929 call(125926 call . HaltWrappers c"boundsCheckHalt") "these -- Attempt to iterate over a range with ambiguous alignment.")
        }
      }
    }
  }
  function _unknown[42].these[125949](arg _mt[125955]:_MT[201], arg this[125952] :
  range) : _unknown[42] "iterator fn" "method" "order independent yielding loops"
  {
    (125969 call boundsCheckUnboundedRange this)
    if(125982 call _cond_test(125981 call(125978 call . strides c"isNegative")))
    {
      { scopeless
        (125972 call compilerError "iteration over a range with no first index")
      }
    }
    { scopeless
      unknown i[125988] chpl_integralIdxType
      (125991 'end of statement')
    }
    { scopeless
      const start[125993] "const"(125995 call chpl__idxToInt(125997 call . this c"first"))
      (126001 'end of statement')
    }
    { scopeless
      const end[126003] "const"(126004 call -(126007 call max chpl_integralIdxType)(126009 call : stride chpl_integralIdxType))
      (126014 'end of statement')
    }
    { scopeless
      CForLoop[126034]
      {
        {
          (126029 yield(126031 call chpl_intToIdx i))
        }
        label _continueLabel[126050]
        {
          (126035 '=' i start)
        }
        {
          (126038 '<=' i end)
        }
        {
          (126041 '+=' i(126044 call : stride chpl_integralIdxType))
        }
      }
      label _breakLabel[126051]
    }
    if(126073 call _cond_test(126069 call > i end))
    {
      if(126064 call _cond_test(126062 call isIntegralType idxType))
      {
        { scopeless
          (126056 call halt "Loop over unbounded range surpassed representable values")
        }
      }
    }
  }
  where {
    (125957 call &&(125960 call hasLowBoundForIter this)(125962 call !(125965 call hasHighBoundForIter this)))
  }
  function _unknown[42].these[126080](arg _mt[126086]:_MT[201], arg this[126083] :
  range) : _unknown[42] "iterator fn" "method" "order independent yielding loops"
  {
    (126100 call boundsCheckUnboundedRange this)
    if(126111 call _cond_test(126110 call(126107 call . strides c"isPositive")))
    {
      { scopeless
        (126103 call compilerError "iteration over a range with no first index")
      }
    }
    { scopeless
      unknown i[126117] chpl_integralIdxType
      (126120 'end of statement')
    }
    { scopeless
      const start[126122] "const"(126124 call chpl__idxToInt(126126 call . this c"first"))
      (126130 'end of statement')
    }
    { scopeless
      const end[126132] "const"(126133 call -(126136 call min chpl_integralIdxType)(126138 call : stride chpl_integralIdxType))
      (126143 'end of statement')
    }
    { scopeless
      CForLoop[126163]
      {
        {
          (126158 yield(126160 call chpl_intToIdx i))
        }
        label _continueLabel[126179]
        {
          (126164 '=' i start)
        }
        {
          (126167 '>=' i end)
        }
        {
          (126170 '+=' i(126173 call : stride chpl_integralIdxType))
        }
      }
      label _breakLabel[126180]
    }
    if(126200 call _cond_test(126196 call < i end))
    {
      if(126191 call _cond_test(126189 call isIntegralType idxType))
      {
        { scopeless
          (126185 call halt "Loop over unbounded range surpassed representable values")
        }
      }
    }
  }
  where {
    (126088 call &&(126090 call !(126093 call hasLowBoundForIter this))(126096 call hasHighBoundForIter this))
  }
  function _unknown[42].these[126207](arg _mt[126213]:_MT[201], arg this[126210] :
  range) : _unknown[42] "iterator fn" "method" "order independent yielding loops"
  {
    if(126245 call _cond_test(126243 call chpl__singleValIdxType idxType))
    {
      if(126237 call _cond_test(126233 call > _low _high))
      {
        { scopeless
          (126231 return)
        }
      }
    }
    if(126394 call _cond_test useOptimizedRangeIterators)
    {
      if(126269 call _cond_test boundsChecking)
      {
        (126252 call checkIfIterWillOverflow)
        if(126263 call _cond_test(126261 call hasAmbiguousAlignmentForIter this))
        {
          { scopeless
            (126257 call(126254 call . HaltWrappers c"boundsCheckHalt") "these -- Attempt to iterate over a range with ambiguous alignment.")
          }
        }
      }
      { scopeless
        unknown i[126274] chpl_integralIdxType
        (126277 'end of statement')
      }
      { scopeless
        const start[126279] "const" chpl_firstAsIntForIter
        (126282 'end of statement')
      }
      { scopeless
        const end[126284] "const"(126304 IfExpr (126286 call >(126289 call . this c"_low")(126293 call . this c"_high")) then
        { scopeless
          start
        } else
        { scopeless
          (126297 call + chpl_lastAsIntForIter(126300 call : stride chpl_integralIdxType))
        } ) chpl_integralIdxType
        (126308 'end of statement')
      }
      { scopeless
        CForLoop[126328]
        {
          {
            (126323 yield(126325 call chpl_intToIdx i))
          }
          label _continueLabel[126344]
          {
            (126329 '=' i start)
          }
          {
            (126332 '!=' i end)
          }
          {
            (126335 '+=' i(126338 call : stride chpl_integralIdxType))
          }
        }
        label _breakLabel[126345]
      }
    }
    {
      {
        unknown _indexOfInterest[126361] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[126362] "expr temp" "temp"
        (126371 'move' _iterator[126362](126369 call _getIterator(126355 call(126352 call . this c"generalIterator"))))
        Defer
        {
          {
            (126386 call _freeIterator _iterator[126362])
          }
        }
        { scopeless type
          (126376 'move' _indexOfInterest[126361](126373 call iteratorIndex _iterator[126362]))
        }
        ForLoop[126363] order-independent
        {
          unknown i[126349] "index var" "insert auto destroy"
          (126381 'move' i[126349] _indexOfInterest[126361])
          { scopeless
            (126356 yield i)
          }
          label _continueLabel[126366]
          _indexOfInterest[126361]
          _iterator[126362]
        }
        label _breakLabel[126367]
      }
    }
  }
  where {
    (126215 call &&(126217 call &&(126220 call hasLowBoundForIter this)(126223 call hasHighBoundForIter this))(126225 call !(126228 call hasPosNegUnitStride)))
  }
  function _unknown[42].these[126401](arg _mt[126407]:_MT[201], arg this[126404] :
  range) : _unknown[42] "iterator fn" "method" "order independent yielding loops"
  {
    if(126437 call _cond_test(126435 call chpl__singleValIdxType idxType))
    {
      if(126429 call _cond_test(126425 call > _low _high))
      {
        { scopeless
          (126423 return)
        }
      }
    }
    if(126608 call _cond_test useOptimizedRangeIterators)
    {
      if(126446 call _cond_test boundsChecking)
      {
        { scopeless
          (126443 call checkIfIterWillOverflow)
        }
      }
      { scopeless
        unknown i[126452] chpl_integralIdxType
        (126455 'end of statement')
      }
      { scopeless
        const start[126457] "const"(126459 call chpl__idxToInt(126461 call lowBoundForIter this))
        (126464 'end of statement')
      }
      { scopeless
        const end[126466] "const"(126468 call chpl__idxToInt(126470 call highBoundForIter this))
        (126473 'end of statement')
      }
      if(126556 call _cond_test(126552 call == stride 1))
      {
        { scopeless
          CForLoop[126493]
          {
            {
              (126488 yield(126490 call chpl_intToIdx i))
            }
            label _continueLabel[126509]
            {
              (126494 '=' i start)
            }
            {
              (126497 '<=' i end)
            }
            {
              (126500 '+=' i(126503 call : 1 chpl_integralIdxType))
            }
          }
          label _breakLabel[126510]
        }
      }
      {
        { scopeless
          CForLoop[126532]
          {
            {
              (126527 yield(126529 call chpl_intToIdx i))
            }
            label _continueLabel[126548]
            {
              (126533 '=' i end)
            }
            {
              (126536 '>=' i start)
            }
            {
              (126539 '-=' i(126542 call : 1 chpl_integralIdxType))
            }
          }
          label _breakLabel[126549]
        }
      }
    }
    {
      {
        unknown _indexOfInterest[126575] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[126576] "expr temp" "temp"
        (126585 'move' _iterator[126576](126583 call _getIterator(126569 call(126566 call . this c"generalIterator"))))
        Defer
        {
          {
            (126600 call _freeIterator _iterator[126576])
          }
        }
        { scopeless type
          (126590 'move' _indexOfInterest[126575](126587 call iteratorIndex _iterator[126576]))
        }
        ForLoop[126577] order-independent
        {
          unknown i[126563] "index var" "insert auto destroy"
          (126595 'move' i[126563] _indexOfInterest[126575])
          { scopeless
            (126570 yield i)
          }
          label _continueLabel[126580]
          _indexOfInterest[126575]
          _iterator[126576]
        }
        label _breakLabel[126581]
      }
    }
  }
  where {
    (126409 call &&(126411 call &&(126414 call hasLowBoundForIter this)(126417 call hasHighBoundForIter this))(126420 call hasPosNegUnitStride))
  }
  function _unknown[42].generalIterator[126615](arg _mt[126621]:_MT[201], arg this[126618] :
  range) : _unknown[42] "iterator fn" "method" "order independent yielding loops"
  {
    if(126637 call _cond_test(126631 call && boundsChecking(126635 call hasAmbiguousAlignmentForIter this)))
    {
      { scopeless
        (126628 call(126625 call . HaltWrappers c"boundsCheckHalt") "these -- Attempt to iterate over a range with ambiguous alignment.")
      }
    }
    { scopeless
      unknown i[126643] chpl_integralIdxType
      (126646 'end of statement')
    }
    { scopeless
      const start[126648] "const"(126650 call . this c"first")
      (126654 'end of statement')
    }
    { scopeless
      const end[126656] "const"(126672 IfExpr (126657 call >(126660 call . this c"_low")(126664 call . this c"_high")) then
      { scopeless
        start
      } else
      { scopeless
        (126669 call . this c"last")
      } )
      (126676 'end of statement')
    }
    { scopeless
      CForLoop[126710]
      {
        {
          (126695 yield i)
          if(126704 call _cond_test(126700 call == i end))
          {
            { scopeless
              break nil[32]
            }
          }
        }
        label _continueLabel[126730]
        {
          (126711 '=' i start)
        }
        {
          (126714 '>='(126716 call highBoundForIter this)(126719 call lowBoundForIter this))
        }
        {
          (126721 '+=' i(126724 call : stride chpl_integralIdxType))
        }
      }
      label _breakLabel[126731]
    }
  }
  function _unknown[42].these[126736](arg _mt[126746]:_MT[201], arg this[126739] :
  range, param arg tag[126743] :
  iterKind) : _unknown[42] "iterator fn" "method"
  {
    if(126779 call _cond_test(126769 call !(126771 call &&(126774 call hasLowBoundForIter this)(126777 call hasHighBoundForIter this))))
    {
      (126765 call compilerError "parallel iteration is not currently supported over ranges without bounds")
    }
    if(126796 call _cond_test(126790 call && boundsChecking(126794 call hasAmbiguousAlignmentForIter this)))
    {
      (126788 call(126785 call . HaltWrappers c"boundsCheckHalt") "these -- Attempt to iterate over a range with ambiguous alignment.")
    }
    if(126807 call _cond_test debugChapelRange)
    {
      (126802 call chpl_debug_writeln "*** In range standalone iterator:")
    }
    { scopeless
      const len[126812] "const"(126817 call(126814 call . this c"sizeAs") chpl_integralIdxType)
      (126820 'end of statement')
    }
    { scopeless
      const numChunks[126822] "const"(126828 IfExpr (126823 'task_get_serial') then
      { scopeless
        1
      } else
      { scopeless
        (126826 call _computeNumChunks len)
      } )
      (126832 'end of statement')
    }
    if(126845 call _cond_test debugChapelRange)
    {
      (126835 call chpl_debug_writeln "*** RI: length=" len " numChunks=" numChunks)
    }
    {
      unknown tmpIter[387312] "expr temp" "maybe ref" "no copy" "temp"
      (387315 'move' tmpIter[387312](126851 call #(126854 call chpl_build_low_bounded_range 0) numChunks))
      unknown isBounded[387659] "maybe param" "temp"
      (387665 'move' isBounded[387659](387661 call chpl_supportsBoundedCoforall tmpIter[387312] 0))
      if isBounded[387659]
      {
        const _coforallCount[387528] "const" "end count" "temp"
        (387596 'move' _coforallCount[387528](387593 call _endCountAlloc 1))
        unknown numTasks[387529] "temp"
        (387580 'move' numTasks[387529](387576 call chpl_boundedCoforallSize tmpIter[387312] 0))
        (387571 call _upEndCount _coforallCount[387528] 1 numTasks[387529])
        (387568 call chpl_resetTaskSpawn numTasks[387529])
        unknown _indexOfInterest[387536] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[387537] "expr temp" "temp"
        (387546 'move' _iterator[387537](387544 call _getIterator tmpIter[387312]))
        Defer
        {
          {
            (387561 call _freeIterator _iterator[387537])
          }
        }
        { scopeless type
          (387551 'move' _indexOfInterest[387536](387548 call iteratorIndex _iterator[387537]))
        }
        ForLoop[387538]
        {
          unknown chunk[387319] "coforall index var" "index var" "insert auto destroy"
          (387556 'move' chunk[387319] _indexOfInterest[387536])
          {
            {
              if(387323 call _cond_test(387325 call !(387327 call hasUnitStride)))
              {
                { scopeless
                  const tmp[387330] "const" "temp"(387332 call _computeBlock len numChunks chunk(387337 call - len 1))
                  (387342 call _check_tuple_var_decl tmp[387330] 2)
                  const lo[387345] "const"(387347 call tmp[387330] 0)
                  const hi[387350] "const"(387352 call tmp[387330] 1)
                  (387355 'end of statement')
                }
                { scopeless
                  const mylen[387357] "const"(387359 call - hi(387362 call - lo 1))
                  (387366 'end of statement')
                }
                { scopeless
                  unknown low[387368](387370 call orderToIndex lo)
                  (387373 'end of statement')
                }
                { scopeless
                  unknown high[387375](387377 call chpl_intToIdx(387379 call +(387381 call :(387383 call chpl__idxToInt low) strType)(387387 call * stride(387390 call :(387392 call - mylen 1) strType))))
                  (387397 'end of statement')
                }
                if(387399 call _cond_test(387401 call hasNegativeStride))
                {
                  { scopeless
                    (387405 call <=> low high)
                  }
                }
                {
                  unknown _indexOfInterest[387410] "an _indexOfInterest or chpl__followIdx variable" "temp"
                  unknown _iterator[387412] "expr temp" "temp"
                  (387414 'move' _iterator[387412](387417 call _getIterator(387419 call chpl_direct_strided_range_iter low high stride)))
                  Defer
                  {
                    {
                      (387425 call _freeIterator _iterator[387412])
                    }
                  }
                  { scopeless type
                    (387429 'move' _indexOfInterest[387410](387432 call iteratorIndex _iterator[387412]))
                  }
                  ForLoop[387434] order-independent
                  {
                    unknown i[387437] "index var" "insert auto destroy"
                    (387439 'move' i[387437] _indexOfInterest[387410])
                    {
                      (387443 yield i)
                    }
                    label _continueLabel[387445]
                    _indexOfInterest[387410]
                    _iterator[387412]
                  }
                  label _breakLabel[387447]
                }
              }
              {
                { scopeless
                  const tmp[387451] "const" "temp"(387453 call _computeBlock len numChunks chunk(387458 call . this c"_high")(387462 call . this c"_low")(387466 call . this c"_low"))
                  (387471 call _check_tuple_var_decl tmp[387451] 2)
                  const lo[387474] "const"(387476 call tmp[387451] 0)
                  const hi[387479] "const"(387481 call tmp[387451] 1)
                  (387484 'end of statement')
                }
                {
                  unknown _indexOfInterest[387486] "an _indexOfInterest or chpl__followIdx variable" "temp"
                  unknown _iterator[387488] "expr temp" "temp"
                  (387490 'move' _iterator[387488](387493 call _getIterator(387495 call chpl_direct_range_iter lo hi)))
                  Defer
                  {
                    {
                      (387500 call _freeIterator _iterator[387488])
                    }
                  }
                  { scopeless type
                    (387504 'move' _indexOfInterest[387486](387507 call iteratorIndex _iterator[387488]))
                  }
                  ForLoop[387509] order-independent
                  {
                    unknown i[387512] "index var" "insert auto destroy"
                    (387514 'move' i[387512] _indexOfInterest[387486])
                    {
                      (387518 yield(387520 call chpl_intToIdx i))
                    }
                    label _continueLabel[387522]
                    _indexOfInterest[387486]
                    _iterator[387488]
                  }
                  label _breakLabel[387524]
                }
              }
            }
            (387531 call _downEndCount _coforallCount[387528] nil[32])
            (387530 'coforall loop')
          }
          label _continueLabel[387541]
          _indexOfInterest[387536]
          _iterator[387537]
        }
        label _breakLabel[387542]
        Defer
        {
          {
            (387583 call _endCountFree _coforallCount[387528])
          }
        }
        (387588 call _waitEndCount _coforallCount[387528] 1 numTasks[387529])
      }
      {
        const _coforallCount[387600] "const" "end count" "temp"
        (387656 'move' _coforallCount[387600](387653 call _endCountAlloc 1))
        unknown _indexOfInterest[387608] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[387609] "expr temp" "temp"
        (387618 'move' _iterator[387609](387616 call _getIterator tmpIter[387312]))
        Defer
        {
          {
            (387633 call _freeIterator _iterator[387609])
          }
        }
        { scopeless type
          (387623 'move' _indexOfInterest[387608](387620 call iteratorIndex _iterator[387609]))
        }
        ForLoop[387610]
        {
          unknown chunk[126849] "coforall index var" "index var" "insert auto destroy"
          (387628 'move' chunk[126849] _indexOfInterest[387608])
          (387640 call _upEndCount _coforallCount[387600] 1)
          {
            {
              if(127084 call _cond_test(127080 call !(127083 call hasUnitStride)))
              {
                { scopeless
                  const tmp[126873] "const" "temp"(126865 call _computeBlock len numChunks chunk(126869 call - len 1))
                  (126880 call _check_tuple_var_decl tmp[126873] 2)
                  const lo[126860] "const"(126874 call tmp[126873] 0)
                  const hi[126862] "const"(126877 call tmp[126873] 1)
                  (126885 'end of statement')
                }
                { scopeless
                  const mylen[126887] "const"(126888 call - hi(126891 call - lo 1))
                  (126896 'end of statement')
                }
                { scopeless
                  unknown low[126898](126900 call orderToIndex lo)
                  (126903 'end of statement')
                }
                { scopeless
                  unknown high[126905](126907 call chpl_intToIdx(126908 call +(126910 call :(126913 call chpl__idxToInt low) strType)(126916 call * stride(126919 call :(126921 call - mylen 1) strType))))
                  (126927 'end of statement')
                }
                if(126935 call _cond_test(126934 call hasNegativeStride))
                {
                  { scopeless
                    (126928 call <=> low high)
                  }
                }
                {
                  unknown _indexOfInterest[126954] "an _indexOfInterest or chpl__followIdx variable" "temp"
                  unknown _iterator[126955] "expr temp" "temp"
                  (126964 'move' _iterator[126955](126962 call _getIterator(126973 call chpl_direct_strided_range_iter low high stride)))
                  Defer
                  {
                    {
                      (126988 call _freeIterator _iterator[126955])
                    }
                  }
                  { scopeless type
                    (126978 'move' _indexOfInterest[126954](126975 call iteratorIndex _iterator[126955]))
                  }
                  ForLoop[126956] order-independent
                  {
                    unknown i[126940] "index var" "insert auto destroy"
                    (126983 'move' i[126940] _indexOfInterest[126954])
                    {
                      (126950 yield i)
                    }
                    label _continueLabel[126959]
                    _indexOfInterest[126954]
                    _iterator[126955]
                  }
                  label _breakLabel[126960]
                }
              }
              {
                { scopeless
                  const tmp[127018] "const" "temp"(127002 call _computeBlock len numChunks chunk(127007 call . this c"_high")(127011 call . this c"_low")(127015 call . this c"_low"))
                  (127025 call _check_tuple_var_decl tmp[127018] 2)
                  const lo[126997] "const"(127019 call tmp[127018] 0)
                  const hi[126999] "const"(127022 call tmp[127018] 1)
                  (127030 'end of statement')
                }
                {
                  unknown _indexOfInterest[127044] "an _indexOfInterest or chpl__followIdx variable" "temp"
                  unknown _iterator[127045] "expr temp" "temp"
                  (127054 'move' _iterator[127045](127052 call _getIterator(127058 call chpl_direct_range_iter lo hi)))
                  Defer
                  {
                    {
                      (127073 call _freeIterator _iterator[127045])
                    }
                  }
                  { scopeless type
                    (127063 'move' _indexOfInterest[127044](127060 call iteratorIndex _iterator[127045]))
                  }
                  ForLoop[127046] order-independent
                  {
                    unknown i[127031] "index var" "insert auto destroy"
                    (127068 'move' i[127031] _indexOfInterest[127044])
                    {
                      (127038 yield(127040 call chpl_intToIdx i))
                    }
                    label _continueLabel[127049]
                    _indexOfInterest[127044]
                    _iterator[127045]
                  }
                  label _breakLabel[127050]
                }
              }
            }
            (387603 call _downEndCount _coforallCount[387600] nil[32])
            (387602 'coforall loop')
          }
          label _continueLabel[387613]
          _indexOfInterest[387608]
          _iterator[387609]
        }
        label _breakLabel[387614]
        Defer
        {
          {
            (387644 call _endCountFree _coforallCount[387600])
          }
        }
        (387649 call _waitEndCount _coforallCount[387600] 1)
      }
    }
  }
  where {
    (126748 call &&(126750 call == tag(126756 call . iterKind c"standalone"))(126759 call ! localeModelPartitionsIterationOnSublocales))
  }
  function _unknown[42].these[127092](arg _mt[127102]:_MT[201], arg this[127095] :
  range, param arg tag[127099] :
  iterKind) : _unknown[42] "iterator fn" "method"
  {
    if(127126 call _cond_test(127116 call !(127118 call &&(127121 call hasLowBoundForIter this)(127124 call hasHighBoundForIter this))))
    {
      { scopeless
        (127113 call compilerError "parallel iteration is not currently supported over ranges without bounds")
      }
    }
    if(127144 call _cond_test(127138 call && boundsChecking(127142 call hasAmbiguousAlignmentForIter this)))
    {
      { scopeless
        (127135 call(127132 call . HaltWrappers c"boundsCheckHalt") "these -- Attempt to iterate over a range with ambiguous alignment.")
      }
    }
    if(127156 call _cond_test debugChapelRange)
    {
      { scopeless
        (127150 call chpl_debug_writeln "*** In range leader:")
      }
    }
    { scopeless
      const numSublocs[127162] "const"(127169 call(127166 call . here c"_getChildCount"))
      (127171 'end of statement')
    }
    if(127642 call _cond_test(127635 call && localeModelPartitionsIterationOnSublocales(127638 call != numSublocs 0)))
    {
      { scopeless
        const len[127174] "const"(127179 call(127176 call . this c"sizeAs") chpl_integralIdxType)
        (127182 'end of statement')
      }
      { scopeless
        const tasksPerLocale[127184] "const" dataParTasksPerLocale
        (127187 'end of statement')
      }
      { scopeless
        const ignoreRunning[127189] "const" dataParIgnoreRunningTasks
        (127192 'end of statement')
      }
      { scopeless
        const minIndicesPerTask[127194] "const" dataParMinGranularity
        (127197 'end of statement')
      }
      { scopeless
        unknown dptpl[127199](127209 IfExpr (127200 call == tasksPerLocale 0) then
        { scopeless
          (127205 call . here c"maxTaskPar")
        } else
        { scopeless
          tasksPerLocale
        } )
        (127213 'end of statement')
      }
      if(127248 call _cond_test(127245 call ! ignoreRunning))
      {
        { scopeless
          const otherTasks[127216] "const"(127217 call -(127223 call(127220 call . here c"runningTasks")) 1)
          (127226 'end of statement')
        }
        (127227 call = dptpl(127242 IfExpr (127230 call < otherTasks dptpl) then
        { scopeless
          (127234 call :(127236 call - dptpl otherTasks) int[10])
        } else
        { scopeless
          1
        } ))
      }
      { scopeless
        const numSublocTasks[127253] "const"(127255 call min numSublocs dptpl)
        (127259 'end of statement')
      }
      { scopeless
        const numChunks[127261] "const"(127271 IfExpr (127262 'task_get_serial') then
        { scopeless
          1
        } else
        { scopeless
          (127265 call _computeNumChunks numSublocTasks(ignoreRunning = 1) minIndicesPerTask len)
        } )
        (127275 'end of statement')
      }
      if(127304 call _cond_test debugDataParNuma)
      {
        (127278 call chpl_debug_writeln "### numSublocs = " numSublocs "\n" "### numTasksPerSubloc = " numSublocTasks "\n" "### ignoreRunning = " ignoreRunning "\n" "### minIndicesPerTask = " minIndicesPerTask "\n" "### numChunks = " numChunks)
      }
      {
        unknown tmpIter[387873] "expr temp" "maybe ref" "no copy" "temp"
        (387876 'move' tmpIter[387873](127310 call #(127313 call chpl_build_low_bounded_range 0) numChunks))
        unknown isBounded[388394] "maybe param" "temp"
        (388400 'move' isBounded[388394](388396 call chpl_supportsBoundedCoforall tmpIter[387873] 0))
        if isBounded[388394]
        {
          const _coforallCount[388263] "const" "end count" "temp"
          (388331 'move' _coforallCount[388263](388328 call _endCountAlloc 1))
          unknown numTasks[388264] "temp"
          (388315 'move' numTasks[388264](388311 call chpl_boundedCoforallSize tmpIter[387873] 0))
          (388306 call _upEndCount _coforallCount[388263] 1 numTasks[388264])
          (388303 call chpl_resetTaskSpawn numTasks[388264])
          unknown _indexOfInterest[388271] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[388272] "expr temp" "temp"
          (388281 'move' _iterator[388272](388279 call _getIterator tmpIter[387873]))
          Defer
          {
            {
              (388296 call _freeIterator _iterator[388272])
            }
          }
          { scopeless type
            (388286 'move' _indexOfInterest[388271](388283 call iteratorIndex _iterator[388272]))
          }
          ForLoop[388273]
          {
            unknown chunk[387880] "coforall index var" "index var" "insert auto destroy"
            (388291 'move' chunk[387880] _indexOfInterest[388271])
            {
              { scopeless
                {
                  const tmp[387887] "const" "temp"
                  (387889 'move' tmp[387887](387891 'deref'(387892 '_wide_get_locale'(387897 call(387894 call . here c"_getChild") chunk))))
                  {
                    if(387901 call _cond_test debugDataParNuma)
                    {
                      if(387905 call _cond_test(387907 call != chunk(387910 call chpl_getSubloc)))
                      {
                        { scopeless
                          (387914 call chpl_debug_writeln "*** ERROR: ON WRONG SUBLOC (should be " chunk ", on "(387919 call chpl_getSubloc) ") ***")
                        }
                      }
                    }
                    { scopeless
                      const tmp[387924] "const" "temp"(387926 call _computeBlock len numChunks chunk(387931 call - len 1))
                      (387936 call _check_tuple_var_decl tmp[387924] 2)
                      const lo[387939] "const"(387941 call tmp[387924] 0)
                      const hi[387944] "const"(387946 call tmp[387924] 1)
                      (387949 'end of statement')
                    }
                    { scopeless
                      const locRange[387951] "const"(387953 call chpl_build_bounded_range lo hi)
                      (387957 'end of statement')
                    }
                    { scopeless
                      const locLen[387959] "const"(387964 call(387961 call . locRange c"sizeAs") chpl_integralIdxType)
                      (387967 'end of statement')
                    }
                    { scopeless
                      const numSublocTasks[387969] "const"(387990 IfExpr (387971 call < chunk(387974 call % dptpl numChunks)) then
                      { scopeless
                        (387979 call +(387981 call / dptpl numChunks) 1)
                      } else
                      { scopeless
                        (387987 call / dptpl numChunks)
                      } )
                      (387992 'end of statement')
                    }
                    { scopeless
                      const numTasks[387994] "const"(387996 call _computeNumChunks numSublocTasks(ignoreRunning = 1) minIndicesPerTask locLen)
                      (388003 'end of statement')
                    }
                    {
                      unknown tmpIter[388005] "expr temp" "maybe ref" "no copy" "temp"
                      (388007 'move' tmpIter[388005](388010 call #(388012 call chpl_build_low_bounded_range 0) numTasks))
                      unknown isBounded[388015] "maybe param" "temp"
                      (388017 'move' isBounded[388015](388020 call chpl_supportsBoundedCoforall tmpIter[388005] 0))
                      if isBounded[388015]
                      {
                        const _coforallCount[388025] "const" "end count" "temp"
                        (388027 'move' _coforallCount[388025](388030 call _endCountAlloc 1))
                        unknown numTasks[388032] "temp"
                        (388034 'move' numTasks[388032](388037 call chpl_boundedCoforallSize tmpIter[388005] 0))
                        (388041 call _upEndCount _coforallCount[388025] 1 numTasks[388032])
                        (388046 call chpl_resetTaskSpawn numTasks[388032])
                        unknown _indexOfInterest[388048] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                        unknown _iterator[388050] "expr temp" "temp"
                        (388052 'move' _iterator[388050](388055 call _getIterator tmpIter[388005]))
                        Defer
                        {
                          {
                            (388059 call _freeIterator _iterator[388050])
                          }
                        }
                        { scopeless type
                          (388063 'move' _indexOfInterest[388048](388066 call iteratorIndex _iterator[388050]))
                        }
                        ForLoop[388068]
                        {
                          unknown core[388071] "coforall index var" "index var" "insert auto destroy"
                          (388073 'move' core[388071] _indexOfInterest[388048])
                          {
                            {
                              { scopeless
                                const tmp[388080] "const" "temp"(388082 call _computeBlock locLen numTasks core hi lo lo)
                                (388091 call _check_tuple_var_decl tmp[388080] 2)
                                const low[388094] "const"(388096 call tmp[388080] 0)
                                const high[388099] "const"(388101 call tmp[388080] 1)
                                (388104 'end of statement')
                              }
                              if(388106 call _cond_test debugDataParNuma)
                              {
                                (388110 call chpl_debug_writeln "### chunk = " chunk "  core = " core "  " "locRange = " locRange "  coreRange = "(388120 call chpl_build_bounded_range low high))
                              }
                              (388124 yield(388126 call _build_tuple(388128 call chpl_build_bounded_range low high)))
                            }
                            (388132 call _downEndCount _coforallCount[388025] nil[32])
                            (388077 'coforall loop')
                          }
                          label _continueLabel[388135]
                          _indexOfInterest[388048]
                          _iterator[388050]
                        }
                        label _breakLabel[388137]
                        Defer
                        {
                          {
                            (388141 call _endCountFree _coforallCount[388025])
                          }
                        }
                        (388145 call _waitEndCount _coforallCount[388025] 1 numTasks[388032])
                      }
                      {
                        const _coforallCount[388150] "const" "end count" "temp"
                        (388152 'move' _coforallCount[388150](388155 call _endCountAlloc 1))
                        unknown _indexOfInterest[388157] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                        unknown _iterator[388159] "expr temp" "temp"
                        (388161 'move' _iterator[388159](388164 call _getIterator tmpIter[388005]))
                        Defer
                        {
                          {
                            (388168 call _freeIterator _iterator[388159])
                          }
                        }
                        { scopeless type
                          (388172 'move' _indexOfInterest[388157](388175 call iteratorIndex _iterator[388159]))
                        }
                        ForLoop[388177]
                        {
                          unknown core[388180] "coforall index var" "index var" "insert auto destroy"
                          (388182 'move' core[388180] _indexOfInterest[388157])
                          (388186 call _upEndCount _coforallCount[388150] 1)
                          {
                            {
                              { scopeless
                                const tmp[388193] "const" "temp"(388195 call _computeBlock locLen numTasks core hi lo lo)
                                (388204 call _check_tuple_var_decl tmp[388193] 2)
                                const low[388207] "const"(388209 call tmp[388193] 0)
                                const high[388212] "const"(388214 call tmp[388193] 1)
                                (388217 'end of statement')
                              }
                              if(388219 call _cond_test debugDataParNuma)
                              {
                                (388223 call chpl_debug_writeln "### chunk = " chunk "  core = " core "  " "locRange = " locRange "  coreRange = "(388233 call chpl_build_bounded_range low high))
                              }
                              (388237 yield(388239 call _build_tuple(388241 call chpl_build_bounded_range low high)))
                            }
                            (388245 call _downEndCount _coforallCount[388150] nil[32])
                            (388190 'coforall loop')
                          }
                          label _continueLabel[388248]
                          _indexOfInterest[388157]
                          _iterator[388159]
                        }
                        label _breakLabel[388250]
                        Defer
                        {
                          {
                            (388254 call _endCountFree _coforallCount[388150])
                          }
                        }
                        (388258 call _waitEndCount _coforallCount[388150] 1)
                      }
                    }
                  }
                  (387884 'elided on block' 0 tmp[387887])
                }
              }
              (388266 call _downEndCount _coforallCount[388263] nil[32])
              (388265 'coforall loop')
            }
            label _continueLabel[388276]
            _indexOfInterest[388271]
            _iterator[388272]
          }
          label _breakLabel[388277]
          Defer
          {
            {
              (388318 call _endCountFree _coforallCount[388263])
            }
          }
          (388323 call _waitEndCount _coforallCount[388263] 1 numTasks[388264])
        }
        {
          const _coforallCount[388335] "const" "end count" "temp"
          (388391 'move' _coforallCount[388335](388388 call _endCountAlloc 1))
          unknown _indexOfInterest[388343] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[388344] "expr temp" "temp"
          (388353 'move' _iterator[388344](388351 call _getIterator tmpIter[387873]))
          Defer
          {
            {
              (388368 call _freeIterator _iterator[388344])
            }
          }
          { scopeless type
            (388358 'move' _indexOfInterest[388343](388355 call iteratorIndex _iterator[388344]))
          }
          ForLoop[388345]
          {
            unknown chunk[127308] "coforall index var" "index var" "insert auto destroy"
            (388363 'move' chunk[127308] _indexOfInterest[388343])
            (388375 call _upEndCount _coforallCount[388335] 1)
            {
              { scopeless
                {
                  const tmp[127515] "const" "temp"
                  (127516 'move' tmp[127515](127513 'deref'(127512 '_wide_get_locale'(127323 call(127320 call . here c"_getChild") chunk))))
                  {
                    if(127353 call _cond_test debugDataParNuma)
                    {
                      if(127347 call _cond_test(127342 call != chunk(127346 call chpl_getSubloc)))
                      {
                        { scopeless
                          (127328 call chpl_debug_writeln "*** ERROR: ON WRONG SUBLOC (should be " chunk ", on "(127337 call chpl_getSubloc) ") ***")
                        }
                      }
                    }
                    { scopeless
                      const tmp[127371] "const" "temp"(127363 call _computeBlock len numChunks chunk(127367 call - len 1))
                      (127378 call _check_tuple_var_decl tmp[127371] 2)
                      const lo[127358] "const"(127372 call tmp[127371] 0)
                      const hi[127360] "const"(127375 call tmp[127371] 1)
                      (127383 'end of statement')
                    }
                    { scopeless
                      const locRange[127385] "const"(127388 call chpl_build_bounded_range lo hi)
                      (127391 'end of statement')
                    }
                    { scopeless
                      const locLen[127393] "const"(127398 call(127395 call . locRange c"sizeAs") chpl_integralIdxType)
                      (127401 'end of statement')
                    }
                    { scopeless
                      const numSublocTasks[127403] "const"(127422 IfExpr (127404 call < chunk(127407 call % dptpl numChunks)) then
                      { scopeless
                        (127411 call +(127413 call / dptpl numChunks) 1)
                      } else
                      { scopeless
                        (127418 call / dptpl numChunks)
                      } )
                      (127426 'end of statement')
                    }
                    { scopeless
                      const numTasks[127428] "const"(127430 call _computeNumChunks numSublocTasks(ignoreRunning = 1) minIndicesPerTask locLen)
                      (127437 'end of statement')
                    }
                    {
                      unknown tmpIter[387669] "expr temp" "maybe ref" "no copy" "temp"
                      (387672 'move' tmpIter[387669](127440 call #(127443 call chpl_build_low_bounded_range 0) numTasks))
                      unknown isBounded[387863] "maybe param" "temp"
                      (387869 'move' isBounded[387863](387865 call chpl_supportsBoundedCoforall tmpIter[387669] 0))
                      if isBounded[387863]
                      {
                        const _coforallCount[387732] "const" "end count" "temp"
                        (387800 'move' _coforallCount[387732](387797 call _endCountAlloc 1))
                        unknown numTasks[387733] "temp"
                        (387784 'move' numTasks[387733](387780 call chpl_boundedCoforallSize tmpIter[387669] 0))
                        (387775 call _upEndCount _coforallCount[387732] 1 numTasks[387733])
                        (387772 call chpl_resetTaskSpawn numTasks[387733])
                        unknown _indexOfInterest[387740] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                        unknown _iterator[387741] "expr temp" "temp"
                        (387750 'move' _iterator[387741](387748 call _getIterator tmpIter[387669]))
                        Defer
                        {
                          {
                            (387765 call _freeIterator _iterator[387741])
                          }
                        }
                        { scopeless type
                          (387755 'move' _indexOfInterest[387740](387752 call iteratorIndex _iterator[387741]))
                        }
                        ForLoop[387742]
                        {
                          unknown core[387676] "coforall index var" "index var" "insert auto destroy"
                          (387760 'move' core[387676] _indexOfInterest[387740])
                          {
                            {
                              { scopeless
                                const tmp[387680] "const" "temp"(387682 call _computeBlock locLen numTasks core hi lo lo)
                                (387691 call _check_tuple_var_decl tmp[387680] 2)
                                const low[387694] "const"(387696 call tmp[387680] 0)
                                const high[387699] "const"(387701 call tmp[387680] 1)
                                (387704 'end of statement')
                              }
                              if(387706 call _cond_test debugDataParNuma)
                              {
                                (387710 call chpl_debug_writeln "### chunk = " chunk "  core = " core "  " "locRange = " locRange "  coreRange = "(387720 call chpl_build_bounded_range low high))
                              }
                              (387724 yield(387726 call _build_tuple(387728 call chpl_build_bounded_range low high)))
                            }
                            (387735 call _downEndCount _coforallCount[387732] nil[32])
                            (387734 'coforall loop')
                          }
                          label _continueLabel[387745]
                          _indexOfInterest[387740]
                          _iterator[387741]
                        }
                        label _breakLabel[387746]
                        Defer
                        {
                          {
                            (387787 call _endCountFree _coforallCount[387732])
                          }
                        }
                        (387792 call _waitEndCount _coforallCount[387732] 1 numTasks[387733])
                      }
                      {
                        const _coforallCount[387804] "const" "end count" "temp"
                        (387860 'move' _coforallCount[387804](387857 call _endCountAlloc 1))
                        unknown _indexOfInterest[387812] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                        unknown _iterator[387813] "expr temp" "temp"
                        (387822 'move' _iterator[387813](387820 call _getIterator tmpIter[387669]))
                        Defer
                        {
                          {
                            (387837 call _freeIterator _iterator[387813])
                          }
                        }
                        { scopeless type
                          (387827 'move' _indexOfInterest[387812](387824 call iteratorIndex _iterator[387813]))
                        }
                        ForLoop[387814]
                        {
                          unknown core[127438] "coforall index var" "index var" "insert auto destroy"
                          (387832 'move' core[127438] _indexOfInterest[387812])
                          (387844 call _upEndCount _coforallCount[387804] 1)
                          {
                            {
                              { scopeless
                                const tmp[127460] "const" "temp"(127453 call _computeBlock locLen numTasks core hi lo lo)
                                (127467 call _check_tuple_var_decl tmp[127460] 2)
                                const low[127448] "const"(127461 call tmp[127460] 0)
                                const high[127450] "const"(127464 call tmp[127460] 1)
                                (127472 'end of statement')
                              }
                              if(127499 call _cond_test debugDataParNuma)
                              {
                                (127475 call chpl_debug_writeln "### chunk = " chunk "  core = " core "  " "locRange = " locRange "  coreRange = "(127496 call chpl_build_bounded_range low high))
                              }
                              (127503 yield(127509 call _build_tuple(127507 call chpl_build_bounded_range low high)))
                            }
                            (387807 call _downEndCount _coforallCount[387804] nil[32])
                            (387806 'coforall loop')
                          }
                          label _continueLabel[387817]
                          _indexOfInterest[387812]
                          _iterator[387813]
                        }
                        label _breakLabel[387818]
                        Defer
                        {
                          {
                            (387848 call _endCountFree _coforallCount[387804])
                          }
                        }
                        (387853 call _waitEndCount _coforallCount[387804] 1)
                      }
                    }
                  }
                  (127519 'elided on block' 0 tmp[127515])
                }
              }
              (388338 call _downEndCount _coforallCount[388335] nil[32])
              (388337 'coforall loop')
            }
            label _continueLabel[388348]
            _indexOfInterest[388343]
            _iterator[388344]
          }
          label _breakLabel[388349]
          Defer
          {
            {
              (388379 call _endCountFree _coforallCount[388335])
            }
          }
          (388384 call _waitEndCount _coforallCount[388335] 1)
        }
      }
    }
    {
      { scopeless
        unknown v[127527](127534 call(127531 call . this c"chpl_sizeAsForIter") chpl_integralIdxType)
        (127537 'end of statement')
      }
      { scopeless
        const numChunks[127539] "const"(127545 IfExpr (127540 'task_get_serial') then
        { scopeless
          1
        } else
        { scopeless
          (127543 call _computeNumChunks v)
        } )
        (127549 'end of statement')
      }
      if(127567 call _cond_test debugChapelRange)
      {
        (127552 call chpl_debug_writeln "*** RI: length=" v " numChunks=" numChunks)
        (127558 call chpl_debug_writeln "*** RI: Using " numChunks " chunk(s)")
      }
      {
        unknown tmpIter[388404] "expr temp" "maybe ref" "no copy" "temp"
        (388407 'move' tmpIter[388404](127573 call #(127576 call chpl_build_low_bounded_range 0) numChunks))
        unknown isBounded[388595] "maybe param" "temp"
        (388601 'move' isBounded[388595](388597 call chpl_supportsBoundedCoforall tmpIter[388404] 0))
        if isBounded[388595]
        {
          const _coforallCount[388464] "const" "end count" "temp"
          (388532 'move' _coforallCount[388464](388529 call _endCountAlloc 1))
          unknown numTasks[388465] "temp"
          (388516 'move' numTasks[388465](388512 call chpl_boundedCoforallSize tmpIter[388404] 0))
          (388507 call _upEndCount _coforallCount[388464] 1 numTasks[388465])
          (388504 call chpl_resetTaskSpawn numTasks[388465])
          unknown _indexOfInterest[388472] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[388473] "expr temp" "temp"
          (388482 'move' _iterator[388473](388480 call _getIterator tmpIter[388404]))
          Defer
          {
            {
              (388497 call _freeIterator _iterator[388473])
            }
          }
          { scopeless type
            (388487 'move' _indexOfInterest[388472](388484 call iteratorIndex _iterator[388473]))
          }
          ForLoop[388474]
          {
            unknown chunk[388411] "coforall index var" "index var" "insert auto destroy"
            (388492 'move' chunk[388411] _indexOfInterest[388472])
            {
              {
                { scopeless
                  const tmp[388415] "const" "temp"(388417 call _computeBlock v numChunks chunk(388422 call - v 1))
                  (388427 call _check_tuple_var_decl tmp[388415] 2)
                  const lo[388430] "const"(388432 call tmp[388415] 0)
                  const hi[388435] "const"(388437 call tmp[388415] 1)
                  (388440 'end of statement')
                }
                if(388442 call _cond_test debugChapelRange)
                {
                  { scopeless
                    (388447 call chpl_debug_writeln "*** RI: tuple = "(388450 call _build_tuple(388452 call chpl_build_bounded_range lo hi)))
                  }
                }
                (388456 yield(388458 call _build_tuple(388460 call chpl_build_bounded_range lo hi)))
              }
              (388467 call _downEndCount _coforallCount[388464] nil[32])
              (388466 'coforall loop')
            }
            label _continueLabel[388477]
            _indexOfInterest[388472]
            _iterator[388473]
          }
          label _breakLabel[388478]
          Defer
          {
            {
              (388519 call _endCountFree _coforallCount[388464])
            }
          }
          (388524 call _waitEndCount _coforallCount[388464] 1 numTasks[388465])
        }
        {
          const _coforallCount[388536] "const" "end count" "temp"
          (388592 'move' _coforallCount[388536](388589 call _endCountAlloc 1))
          unknown _indexOfInterest[388544] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[388545] "expr temp" "temp"
          (388554 'move' _iterator[388545](388552 call _getIterator tmpIter[388404]))
          Defer
          {
            {
              (388569 call _freeIterator _iterator[388545])
            }
          }
          { scopeless type
            (388559 'move' _indexOfInterest[388544](388556 call iteratorIndex _iterator[388545]))
          }
          ForLoop[388546]
          {
            unknown chunk[127571] "coforall index var" "index var" "insert auto destroy"
            (388564 'move' chunk[127571] _indexOfInterest[388544])
            (388576 call _upEndCount _coforallCount[388536] 1)
            {
              {
                { scopeless
                  const tmp[127594] "const" "temp"(127586 call _computeBlock v numChunks chunk(127590 call - v 1))
                  (127601 call _check_tuple_var_decl tmp[127594] 2)
                  const lo[127581] "const"(127595 call tmp[127594] 0)
                  const hi[127583] "const"(127598 call tmp[127594] 1)
                  (127606 'end of statement')
                }
                if(127621 call _cond_test debugChapelRange)
                {
                  { scopeless
                    (127608 call chpl_debug_writeln "*** RI: tuple = "(127617 call _build_tuple(127615 call chpl_build_bounded_range lo hi)))
                  }
                }
                (127626 yield(127632 call _build_tuple(127630 call chpl_build_bounded_range lo hi)))
              }
              (388539 call _downEndCount _coforallCount[388536] nil[32])
              (388538 'coforall loop')
            }
            label _continueLabel[388549]
            _indexOfInterest[388544]
            _iterator[388545]
          }
          label _breakLabel[388550]
          Defer
          {
            {
              (388580 call _endCountFree _coforallCount[388536])
            }
          }
          (388585 call _waitEndCount _coforallCount[388536] 1)
        }
      }
    }
  }
  where {
    (127104 call == tag(127108 call . iterKind c"leader"))
  }
  function _unknown[42].these[127649](arg _mt[127661]:_MT[201], arg this[127652] :
  range, param arg tag[127656] :
  iterKind, arg followThis[127659]:_any[141](?)) : _unknown[42] "iterator fn" "method"
  {
    if(127684 call _cond_test(127678 call && boundsChecking(127682 call hasAmbiguousAlignmentForIter this)))
    {
      { scopeless
        (127675 call(127672 call . HaltWrappers c"boundsCheckHalt") "these -- Attempt to iterate over a range with ambiguous alignment.")
      }
    }
    if(127700 call _cond_test(127693 call == bounds(127697 call . boundKind c"neither")))
    {
      { scopeless
        (127690 call compilerError "iteration over a range with no bounds")
      }
    }
    if(127723 call _cond_test(127709 call &&(127715 call(127712 call . strides c"isPositive"))(127716 call == bounds(127720 call . boundKind c"high"))))
    {
      { scopeless
        (127706 call compilerError "iteration over a range with no first index")
      }
    }
    if(127746 call _cond_test(127732 call &&(127738 call(127735 call . strides c"isNegative"))(127739 call == bounds(127743 call . boundKind c"low"))))
    {
      { scopeless
        (127729 call compilerError "iteration over a range with no first index")
      }
    }
    if(127778 call _cond_test(127771 call !=(127774 call . followThis c"size") 1))
    {
      { scopeless
        (127752 call compilerError(127753 call +(127755 call + "rank mismatch in zippered iteration (can't zip a "(127760 call :(127763 call . followThis c"size") string[244])) "D expression with a range, which is 1D)"))
      }
    }
    if(127791 call _cond_test debugChapelRange)
    {
      { scopeless
        (127784 call chpl_debug_writeln "In range follower code: Following " followThis)
      }
    }
    { scopeless
      unknown myFollowThis[127797](127799 call followThis 0)
      (127802 'end of statement')
    }
    if(127811 call _cond_test debugChapelRange)
    {
      { scopeless
        (127804 call chpl_debug_writeln "Range = " myFollowThis)
      }
    }
    if(127865 call _cond_test(127855 call && boundsChecking(127858 call !(127864 call(127861 call . this c"hasFirstForIter")))))
    {
      if(127851 call _cond_test(127850 call(127847 call . this c"isEmpty")))
      {
        if(127834 call _cond_test(127827 call !(127833 call(127830 call . myFollowThis c"isEmpty"))))
        {
          { scopeless
            (127822 call(127819 call . HaltWrappers c"boundsCheckHalt") "size mismatch in zippered iteration")
          }
        }
      }
      {
        (127844 call(127841 call . HaltWrappers c"boundsCheckHalt") "iteration over a range with no first index")
      }
    }
    if(127908 call _cond_test(127898 call && boundsChecking(127901 call !(127907 call(127904 call . myFollowThis c"hasFirstForIter")))))
    {
      if(127893 call _cond_test(127879 call !(127881 call &&(127887 call(127884 call . myFollowThis c"isAligned"))(127892 call(127889 call . myFollowThis c"isEmpty")))))
      {
        { scopeless
          (127874 call(127871 call . HaltWrappers c"boundsCheckHalt") "zippered iteration over a range with no first index")
        }
      }
    }
    { scopeless
      unknown newStrides[127913] "param"(127915 call chpl_strideProduct this myFollowThis)
      (127919 'end of statement')
    }
    if(128405 call _cond_test(128381 call ||(128383 call &&(128385 call ==(128388 call . myFollowThis c"bounds")(128392 call . boundKind c"both"))(128399 call(128396 call . myFollowThis c"hasPosNegUnitStride")))(128404 call(128401 call . myFollowThis c"hasLastForIter"))))
    {
      { scopeless
        const flwlen[127922] "const"(127927 call(127924 call . myFollowThis c"sizeAs")(127929 call . myFollowThis c"chpl_integralIdxType"))
        (127933 'end of statement')
      }
      if(128020 call _cond_test boundsChecking)
      {
        if(127970 call _cond_test(127969 call(127966 call . this c"hasLastForIter")))
        {
          if(127960 call _cond_test(127943 call &&(127945 call !=(127948 call . this c"bounds")(127952 call . boundKind c"both"))(127955 call !(127958 call isFiniteIdxType idxType))))
          {
            { scopeless
              (127937 call assert 0 "hasFirstForIter && hasLastForIter do not imply a range is bounded")
            }
          }
        }
        if(128014 call _cond_test(128010 call != flwlen 0))
        {
          { scopeless
            if(128005 call _cond_test(127981 call &&(127983 call ==(127986 call . this c"bounds")(127990 call . boundKind c"both"))(127993 call >=(127996 call . myFollowThis c"highBound")(128003 call(128000 call . this c"sizeAs") uint[86]))))
            {
              { scopeless
                (127978 call(127975 call . HaltWrappers c"boundsCheckHalt") "size mismatch in zippered iteration")
              }
            }
          }
        }
      }
      { scopeless
        unknown r[128025](128027 call range idxType(strides = newStrides))
        (128032 'end of statement')
      }
      if(128106 call _cond_test(128102 call != flwlen 0))
      {
        { scopeless
          unknown low[128035](128040 call(128037 call . this c"orderToIndex")(128042 call . myFollowThis c"first"))
          (128046 'end of statement')
        }
        { scopeless
          unknown high[128048](128053 call(128050 call . this c"orderToIndex")(128055 call . myFollowThis c"last"))
          (128059 'end of statement')
        }
        if(128078 call _cond_test(128066 call isNegativeStride newStrides(128068 call *(128071 call . this c"stride")(128075 call . myFollowThis c"stride"))))
        {
          { scopeless
            (128060 call <=> low high)
          }
        }
        (128089 call(128086 call . r c"chpl_setFields") low high(128092 call *(128095 call . this c"stride")(128099 call . myFollowThis c"stride")))
      }
      if(128118 call _cond_test debugChapelRange)
      {
        { scopeless
          (128111 call chpl_debug_writeln "Expanded range = " r)
        }
      }
      {
        unknown _indexOfInterest[128129] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[128130] "expr temp" "temp"
        (128139 'move' _iterator[128130](128137 call _getIterator r))
        Defer
        {
          {
            (128154 call _freeIterator _iterator[128130])
          }
        }
        { scopeless type
          (128144 'move' _indexOfInterest[128129](128141 call iteratorIndex _iterator[128130]))
        }
        ForLoop[128131]
        {
          unknown i[128123] "index var" "insert auto destroy"
          (128149 'move' i[128123] _indexOfInterest[128129])
          { scopeless
            (128126 yield i)
          }
          label _continueLabel[128134]
          _indexOfInterest[128129]
          _iterator[128130]
        }
        label _breakLabel[128135]
      }
    }
    {
      if(128181 call _cond_test(128173 call && boundsChecking(128180 call(128177 call . this c"hasLastForIter"))))
      {
        { scopeless
          (128168 call(128165 call . HaltWrappers c"zipLengthHalt") "zippered iteration where a bounded range follows an unbounded iterator")
        }
      }
      { scopeless
        const first[128187] "const"(128192 call(128189 call . this c"orderToIndex")(128194 call . myFollowThis c"first"))
        (128198 'end of statement')
      }
      { scopeless
        const stride[128200] "const"(128201 call *(128204 call . this c"stride")(128208 call . myFollowThis c"stride"))
        (128212 'end of statement')
      }
      if(128377 call _cond_test(128374 call isPositiveStride newStrides stride))
      {
        { scopeless
          const r[128215] "const"(128216 call chpl_by(128219 call chpl_build_low_bounded_range first)(128231 IfExpr (128225 call(128222 call . newStrides c"isOne")) then
          { scopeless
            1
          } else
          { scopeless
            (128227 call : stride uint[86])
          } ))
          (128235 'end of statement')
        }
        if(128242 call _cond_test debugChapelRange)
        {
          { scopeless
            (128237 call chpl_debug_writeln "Expanded range = " r)
          }
        }
        {
          unknown _indexOfInterest[128253] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[128254] "expr temp" "temp"
          (128263 'move' _iterator[128254](128261 call _getIterator r))
          Defer
          {
            {
              (128278 call _freeIterator _iterator[128254])
            }
          }
          { scopeless type
            (128268 'move' _indexOfInterest[128253](128265 call iteratorIndex _iterator[128254]))
          }
          ForLoop[128255]
          {
            unknown i[128247] "index var" "insert auto destroy"
            (128273 'move' i[128247] _indexOfInterest[128253])
            { scopeless
              (128250 yield i)
            }
            label _continueLabel[128258]
            _indexOfInterest[128253]
            _iterator[128254]
          }
          label _breakLabel[128259]
        }
      }
      {
        { scopeless
          unknown r[128287](128289 call range idxType(128292 call . boundKind c"high")(128308 IfExpr (128299 call(128296 call . newStrides c"isNegOne")) then
          { scopeless
            (128301 call . strideKind c"negOne")
          } else
          { scopeless
            (128305 call . strideKind c"negative")
          } ))
          (128312 'end of statement')
        }
        (128317 call(128314 call . r c"chpl_setFields")(128318 call : 0 idxType) first stride)
        if(128330 call _cond_test debugChapelRange)
        {
          { scopeless
            (128325 call chpl_debug_writeln "Expanded range = " r)
          }
        }
        {
          unknown _indexOfInterest[128341] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[128342] "expr temp" "temp"
          (128351 'move' _iterator[128342](128349 call _getIterator r))
          Defer
          {
            {
              (128366 call _freeIterator _iterator[128342])
            }
          }
          { scopeless type
            (128356 'move' _indexOfInterest[128341](128353 call iteratorIndex _iterator[128342]))
          }
          ForLoop[128343]
          {
            unknown i[128335] "index var" "insert auto destroy"
            (128361 'move' i[128335] _indexOfInterest[128341])
            { scopeless
              (128338 yield i)
            }
            label _continueLabel[128346]
            _indexOfInterest[128341]
            _iterator[128342]
          }
          label _breakLabel[128347]
        }
      }
    }
  }
  where {
    (127663 call == tag(127667 call . iterKind c"follower"))
  }
  function :[128412](arg x[128417] :
  (128415 call range ?[227]), arg t[128421] :
  string[244]) : _unknown[42] "operator"
  {
    { scopeless
      unknown ret[128426] string[244]
      (128429 'end of statement')
    }
    if(128446 call _cond_test(128445 call(128442 call . x c"hasLowBound")))
    {
      { scopeless
        (128430 call += ret(128433 call :(128436 call . x c"lowBound") string[244]))
      }
    }
    (128451 call += ret "..")
    if(128510 call _cond_test(128509 call(128506 call . x c"hasHighBound")))
    {
      if(128501 call _cond_test(128483 call &&(128486 call chpl__singleValIdxType(128488 call . x c"idxType"))(128491 call !=(128494 call . x c"_high")(128498 call . x c"_low"))))
      {
        (128457 call += ret(128460 call + "<"(128465 call :(128468 call . x c"lowBound") string[244])))
      }
      {
        (128473 call += ret(128476 call :(128479 call . x c"highBound") string[244]))
      }
    }
    if(128581 call _cond_test(128574 call !=(128577 call . x c"stride") 1))
    {
      (128515 call += ret(128518 call + " by "(128521 call :(128524 call . x c"stride") string[244])))
      if(128569 call _cond_test(128542 call &&(128544 call &&(128546 call !=(128549 call . x c"stride")(128552 call - 1))(128559 call(128556 call . x c"isAligned")))(128560 call !(128568 call(128565 call . x c"chpl_isNaturallyAligned")))))
      {
        { scopeless
          (128528 call += ret(128531 call + " align "(128534 call :(128537 call . x c"alignment") string[244])))
        }
      }
    }
    (128585 return ret)
  }
  function _unknown[42].chpl__unTranslate[128589](arg _mt[128597]:_MT[201], arg this[128592] :
  range, arg i[128595]:_any[141](?)) : _unknown[42] "inline" "method"
  {
    (128600 return(128601 call - this i))
  }
  function chpl__mod[128607](arg dividend[128610] :
  integral, arg modulus[128614] :
  integral) : _unknown[42]
  {
    unknown t[128629] "type variable"(128631 'typeof' modulus)
    { scopeless
      unknown m[128634] modulus
      (128637 'end of statement')
    }
    if(128662 call _cond_test(128645 call &&(128647 call &&(128650 call isIntType t)(128652 call < m 0))(128656 call != m(128660 call min t))))
    {
      { scopeless
        (128638 call = m(128641 call - m))
      }
    }
    { scopeless
      unknown tmp[128668](128669 call % dividend(128672 call : m(128676 'typeof' dividend)))
      (128678 'end of statement')
    }
    if(128700 call _cond_test(128698 call isInt dividend))
    {
      { scopeless
        if(128692 call _cond_test(128688 call < tmp 0))
        {
          { scopeless
            (128679 call += tmp(128682 call : m(128686 'typeof' dividend)))
          }
        }
      }
    }
    (128705 return tmp)
  }
  where {
    (128617 call >=(128620 call numBits(128622 'typeof' dividend))(128624 call numBits(128626 'typeof' modulus)))
  }
  function chpl__mod[128710](arg dividend[128713] :
  integral, arg modulus[128717] :
  integral) : _unknown[42]
  {
    unknown t[128737] "type variable"(128739 'typeof' modulus)
    { scopeless
      unknown m[128742] modulus
      (128745 'end of statement')
    }
    if(128770 call _cond_test(128753 call &&(128755 call &&(128758 call isIntType t)(128760 call < m 0))(128764 call != m(128768 call min t))))
    {
      { scopeless
        (128746 call = m(128749 call - m))
      }
    }
    { scopeless
      unknown tmp[128776](128777 call %(128779 call : dividend t) m)
      (128785 'end of statement')
    }
    if(128803 call _cond_test(128801 call isInt dividend))
    {
      { scopeless
        if(128795 call _cond_test(128791 call < tmp 0))
        {
          { scopeless
            (128786 call += tmp m)
          }
        }
      }
    }
    (128808 return(128809 call : tmp(128813 'typeof' dividend)))
  }
  where {
    (128720 call &&(128722 call <(128725 call numBits(128727 'typeof' dividend))(128729 call numBits(128731 'typeof' modulus)))(128733 call isInt modulus))
  }
  function chpl__diffMod[128817](arg minuend[128820] :
  integral, arg subtrahend[128824] :
  integral, arg modulus[128828] :
  integral) : _unknown[42]
  {
    { scopeless
      const m[128841] "const"(128843 call abs modulus)
      (128846 'end of statement')
    }
    { scopeless
      unknown minMod[128848](128850 call chpl__mod minuend m)
      (128854 'end of statement')
    }
    { scopeless
      unknown subMod[128856](128858 call chpl__mod subtrahend m)
      (128862 'end of statement')
    }
    (128863 return(128883 IfExpr (128864 call < minMod subMod) then
    { scopeless
      (128868 call -(128870 call : m(128874 'typeof' minuend))(128875 call - subMod minMod))
    } else
    { scopeless
      (128879 call - minMod subMod)
    } ))
  }
  where {
    (128833 call ==(128836 'typeof' minuend)(128838 'typeof' subtrahend))
  }
  { scopeless type
    (128832 'typeof' minuend)
  }
  function chpl__diffMod[128890](arg minuend[128893] :
  integral, arg subtrahend[128897] :
  integral, arg modulus[128901] :
  integral) : _unknown[42]
  {
    (128906 call compilerError "chpl__diffMod -- Operand types must match.")
  }
  function chpl__add[128912](arg a[128916] :
  unknown t[128914], arg b[128920] :
  t, arg resultType[128923]:_any[141](?)) : _unknown[42]
  {
    if(128937 call _cond_test(128932 call !(128935 call isIntegralType t)))
    {
      { scopeless
        (128927 call compilerError "Values must be of integral type.")
      }
    }
    if(128968 call _cond_test(128947 call &&(128949 call &&(128951 call > a 0)(128955 call > b 0))(128959 call > b(128962 call -(128965 call max t) a))))
    {
      { scopeless
        (128942 return(128944 call max resultType))
      }
    }
    if(128999 call _cond_test(128978 call &&(128980 call &&(128982 call < a 0)(128986 call < b 0))(128990 call < b(128993 call -(128996 call min t) a))))
    {
      { scopeless
        (128973 return(128975 call min resultType))
      }
    }
    if(129077 call _cond_test(129075 call isUintType resultType))
    {
      if(129069 call _cond_test(129011 call ||(129013 call &&(129015 call &&(129017 call < a 0)(129021 call > b 0))(129025 call ||(129027 call == a(129031 call min t))(129033 call >(129036 call abs a)(129039 call abs b))))(129041 call &&(129043 call &&(129045 call > a 0)(129049 call < b 0))(129053 call ||(129055 call == b(129059 call min t))(129061 call >(129064 call abs b)(129067 call abs a))))))
      {
        { scopeless
          (129005 return(129006 call : 0 resultType))
        }
      }
    }
    (129081 return(129082 call :(129084 call + a b) resultType))
  }
  function chpl__addRangeStrides[129091](arg start[129093]:_any[141](?), arg stride[129095]:_any[141](?), arg count[129097]:_any[141](?)) : _unknown[42]
  {
    function convert[129102](arg a[129104]:_any[141](?), arg b[129106]:_any[141](?)) param : _unknown[42]
    {
      (129109 return(129110 call ||(129112 call &&(129115 call isIntType(129117 'typeof' a))(129119 call isUintType(129121 'typeof' b)))(129122 call &&(129125 call isUintType(129127 'typeof' a))(129129 call isIntType(129131 'typeof' b)))))
    }
    function mul[129134](arg a[129136]:_any[141](?), arg b[129138]:_any[141](?)) : _unknown[42]
    {
      (129141 return(129164 IfExpr (129143 call convert a b) then
      { scopeless
        (129146 call *(129148 call : a(129152 call int[10] 64))(129154 call : b(129158 call int[10] 64)))
      } else
      { scopeless
        (129160 call * a b)
      } ))
    }
    function add[129169](arg a[129171]:_any[141](?), arg b[129173]:_any[141](?)) : _unknown[42]
    {
      (129176 return(129199 IfExpr (129178 call convert a b) then
      { scopeless
        (129181 call +(129183 call : a(129187 call int[10] 64))(129189 call : b(129193 call int[10] 64)))
      } else
      { scopeless
        (129195 call + a b)
      } ))
    }
    (129204 return(129205 call :(129208 call add start(129211 call mul stride count))(129215 'typeof' start)))
  }
  { scopeless type
    (129100 'typeof' start)
  }
  function chpl__extendedEuclidHelper[129219](arg u[129221]:_any[141](?), arg v[129223]:_any[141](?)) : _unknown[42]
  {
    { scopeless
      unknown zero[129227] 0(129229 'typeof' u)
      (129232 'end of statement')
    }
    { scopeless
      unknown one[129234] 1(129236 'typeof' u)
      (129239 'end of statement')
    }
    { scopeless
      unknown U[129241](129246 call _build_tuple one zero u)
      (129249 'end of statement')
    }
    { scopeless
      unknown V[129251](129256 call _build_tuple zero one v)
      (129259 'end of statement')
    }
    {
      unknown tmp[129303] "temp"
      (129331 'move' tmp[129303](129324 call _cond_test(129326 call !=(129328 call V 2) 0)))
      WhileDo[129308]
      {
        {
          { scopeless
            unknown oldU[129268] U
            (129271 'end of statement')
          }
          { scopeless
            unknown q[129273](129274 call /(129277 call U 2)(129280 call V 2))
            (129283 'end of statement')
          }
          (129284 call = U V)
          (129288 call = V(129291 call - oldU(129294 call * V(129301 call _build_tuple q q q))))
        }
        label _continueLabel[129306]
        (129319 'move' tmp[129303](129312 call _cond_test(129314 call !=(129316 call V 2) 0)))
        tmp[129303]
      }
      label _breakLabel[129307]
    }
    (129334 return(129342 call _build_tuple(129337 call U 2)(129340 call U 0)))
  }
  function chpl__extendedEuclid[129346](arg u[129351] :
  (129349 call int[10] 32), arg v[129357] :
  (129355 call int[10] 32)) : _unknown[42] "inline"
  {
    (129361 return(129363 call chpl__extendedEuclidHelper u v))
  }
  function chpl__extendedEuclid[129368](arg u[129373] :
  (129371 call int[10] 64), arg v[129379] :
  (129377 call int[10] 64)) : _unknown[42] "inline"
  {
    (129383 return(129385 call chpl__extendedEuclidHelper u v))
  }
  function chpl__rangeIdxTypeError[129390](arg idxType[129392]:_any[141](?)) : _unknown[42] "private"
  {
    (129396 call compilerError "ranges don't support '"(129400 call : idxType string[244]) "' as their idxType")
  }
  function chpl__rangeStrideType[129409](arg idxType[129411]:_any[141](?)) type : _unknown[42] "private"
  {
    if(129436 call _cond_test(129434 call isIntegralType idxType))
    {
      (129415 return(129417 call chpl__signedType idxType))
    }
    {
      { scopeless
        if(129429 call _cond_test(129427 call isFiniteIdxType idxType))
        {
          (129420 return int[10])
        }
        {
          (129424 call chpl__rangeIdxTypeError idxType)
        }
      }
    }
  }
  function chpl__rangeUnsignedType[129443](arg idxType[129445]:_any[141](?)) type : _unknown[42] "private"
  {
    if(129470 call _cond_test(129468 call isIntegralType idxType))
    {
      (129449 return(129451 call chpl__unsignedType idxType))
    }
    {
      { scopeless
        if(129463 call _cond_test(129461 call isFiniteIdxType idxType))
        {
          (129454 return uint[86])
        }
        {
          (129458 call chpl__rangeIdxTypeError idxType)
        }
      }
    }
  }
  function chpl__idxTypeToIntIdxType[129477](arg idxType[129479]:_any[141](?)) type : _unknown[42]
  {
    if(129491 call _cond_test(129489 call isIntegralType idxType))
    {
      (129483 return idxType)
    }
    {
      (129486 return int[10])
    }
  }
  function _unknown[42].chpl_intToIdx[129497](arg _mt[129505]:_MT[201], arg this[129500] :
  range, arg i[129503]:_any[141](?)) : _unknown[42] "inline" "method"
  {
    (129508 return(129510 call chpl__intToIdx(129512 call . this c"idxType") i))
  }
  function chpl__intToIdx[129518](arg idxType[129521] :
  integral, arg i[129525] :
  integral) : _unknown[42] "inline"
  {
    if(129543 call _cond_test(129538 call ==(129541 'typeof' i) idxType))
    {
      { scopeless
        (129529 return i)
      }
    }
    {
      { scopeless
        (129532 return(129533 call : i idxType))
      }
    }
  }
  function chpl__intToIdx[129551](arg idxType[129554] :
  integral, param arg i[129558] :
  integral) param : _unknown[42] "inline"
  {
    if(129576 call _cond_test(129571 call ==(129574 'typeof' i) idxType))
    {
      { scopeless
        (129562 return i)
      }
    }
    {
      { scopeless
        (129565 return(129566 call : i idxType))
      }
    }
  }
  function chpl__intToIdx[129584](arg idxType[129587] :
  enum, arg i[129591] :
  integral) : _unknown[42] "inline"
  {
    (129595 return(129597 call chpl__orderToEnum i idxType))
  }
  function chpl__intToIdx[129602](arg idxType[129605] :
  enum, param arg i[129609] :
  integral) param : _unknown[42] "inline"
  {
    (129613 return(129615 call chpl__orderToEnum i idxType))
  }
  function chpl__intToIdx[129620](arg idxType[129622]:_any[141](?), arg i[129625] :
  integral) : _unknown[42] "inline"
  {
    (129632 return(129633 call : i bool))
  }
  where {
    (129629 call isBoolType idxType)
  }
  function chpl__intToIdx[129640](arg idxType[129642]:_any[141](?), param arg i[129645] :
  integral) param : _unknown[42] "inline"
  {
    (129652 return(129653 call : i bool))
  }
  where {
    (129649 call isBoolType idxType)
  }
  function chpl__intToIdx[129660](arg idxType[129662]:_any[141](?), arg i[129665] :
  nothing) : _unknown[42] "inline"
  {
    (129669 return none)
  }
  function chpl__idxToInt[129673](arg i[129676] :
  integral) : _unknown[42] "inline"
  {
    (129680 return i)
  }
  function chpl__idxToInt[129684](param arg i[129687] :
  integral) param : _unknown[42] "inline"
  {
    (129691 return i)
  }
  function chpl__idxToInt[129695](arg i[129698] :
  enum) : _unknown[42] "inline"
  {
    (129702 return(129704 call chpl__enumToOrder i))
  }
  function chpl__idxToInt[129708](param arg i[129711] :
  enum) param : _unknown[42] "inline"
  {
    (129715 return(129717 call chpl__enumToOrder i))
  }
  function chpl__idxToInt[129721](arg i[129724] :
  bool) : _unknown[42] "inline"
  {
    (129728 return(129729 call : i int[10]))
  }
  function chpl__idxToInt[129735](param arg i[129738] :
  bool) param : _unknown[42] "inline"
  {
    (129742 return(129743 call : i int[10]))
  }
  function chpl__singleValIdxType[129749](arg t[129751]:_any[141](?)) param : _unknown[42]
  {
    (129754 return(129755 call &&(129758 call isEnumType t)(129760 call ==(129763 call . t c"size") 1)))
  }
  function chpl__defaultLowBound[129769](arg t[129771]:_any[141](?), param arg bounds[129774] :
  boundKind) param : _unknown[42] "private"
  {
    if(129825 call _cond_test(129823 call chpl__singleValIdxType t))
    {
      (129779 return(129780 call : 0(129784 call chpl__idxTypeToIntIdxType t)))
    }
    {
      { scopeless
        if(129818 call _cond_test(129802 call ||(129804 call == bounds(129808 call . boundKind c"high"))(129811 call == bounds(129815 call . boundKind c"neither"))))
        {
          (129787 return(129788 call : 0(129792 call chpl__idxTypeToIntIdxType t)))
        }
        {
          (129795 return(129796 call : 1(129800 call chpl__idxTypeToIntIdxType t)))
        }
      }
    }
  }
  function chpl__defaultHighBound[129832](arg t[129834]:_any[141](?), param arg bounds[129837] :
  boundKind) param : _unknown[42] "private"
  {
    if(129908 call _cond_test(129906 call chpl__singleValIdxType t))
    {
      (129842 return(129843 call -(129845 call : 1(129849 call chpl__idxTypeToIntIdxType t))))
    }
    {
      { scopeless
        if(129901 call _cond_test(129885 call ||(129887 call == bounds(129891 call . boundKind c"low"))(129894 call == bounds(129898 call . boundKind c"neither"))))
        {
          if(129873 call _cond_test(129871 call isFiniteIdxType t))
          {
            (129853 return(129854 call :(129857 call finiteIdxTypeHigh t)(129860 call chpl__idxTypeToIntIdxType t)))
          }
          {
            (129863 return(129864 call : 0(129868 call chpl__idxTypeToIntIdxType t)))
          }
        }
        {
          (129878 return(129879 call : 0(129883 call chpl__idxTypeToIntIdxType t)))
        }
      }
    }
  }
}